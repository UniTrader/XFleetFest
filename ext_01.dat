<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="boarding.pod.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="target" />
    <param name="targetpos" />
    <param name="targetrot" />
    <param name="initialwaittime" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <attention min="unknown">
    <actions>
      <set_value name="$startship" exact="this.ship" />
      <wait exact="$initialwaittime" />

      <!-- find a not destroyed component-->
      <find_object_component object="$target" name="$comp" multiple="false" surfaceelement="true" />

      <!-- find surface and move to it -->
      <find_object_surface object="$target" posname="$targetpos" rotname="$targetrot" space="$target" component="$comp" chance="0" >
        <position object="this.ship" />
      </find_object_surface>

      <set_avoid_collisions enabled="false" object="this.ship"/>

      <move_to destination="$target" object="this.ship" flightbehaviour="flightbehaviour.droneattach" usehighways="false" forcesteering="true" finishonapproach="true" >
        <position value="$targetpos" />
        <rotation value="$targetrot" />
        <interrupt_after_time time="30s" comment="finish if not reach the first position in 30s" />
        <interrupt>
          <conditions>
            <event_object_approaching_waypoint object="this.ship" />
          </conditions>
        </interrupt>
      </move_to>

      <!-- Activate animation -->
      <set_object_active object="$startship" activate="true"  />

      <debug_text text="'Moving towards ' + $targetpos + $targetrot" chance="$debugoutputchance" />

      <move_to destination="$target" object="this.ship" flightbehaviour="flightbehaviour.droneattach" usehighways="false" forcesteering="true" abortpath="true"  finishonapproach="false">
        <position value="$targetpos" />
        <rotation value="$targetrot.inverse" />
      </move_to>

      <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.forced" />
      <debug_text text="'Boarding pod reached hull, activating'" chance="$debugoutputchance" />

      <!-- attach it -->
      <attach_object_to_target object="this.ship" target="$target" keepoffset="true" />

      <wait min="100ms" max="250ms" />
      
      <!--Fire a signal the MD Boarding script is waiting for-->
      <signal_objects object="$startship" param="'boarding.pod'" param2="'attached'"/>
      <debug_text text="'Boarding done!! '" chance="$debugoutputchance" />

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="command.collect.cargo.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="2" version="1" >
  <!--
  Wrapper script for player cargo collect mode
  by Adrian
  -->
  <params>
    <param name="debugchance" default="0"/>
  </params>
  <init>
    <set_command command="command.support" param="player.primaryship" />
  </init>
  <attention min="unknown">
    <actions>

      <set_value name="$debugchance" exact="0" />
      <set_value name="$target" exact="player.primaryship" />

      <set_value name="$bigship" exact="this.ship.isclass.ship_xl or this.ship.isclass.ship_l" />

      <!-- Label to allow us to repeat indefinitely -->
      <label name="start" />
      
      <!-- command action for waiting time -->
      <set_command_action commandaction="commandaction.calculating" />

      <do_if value="not $target.exists">
        <return />
      </do_if>

      <!-- recall drones -->
      <run_script name="'lib.recall.drones.vanilla40'" />      
      
      <run_script name="'move.undock.vanilla40'" />

      <do_if value="$target.zone.isclass.highway">
        <wait exact="3s" />
        <resume label="start" />
      </do_if>

      <!-- Warp to different zone -->
      <label name="warp" />

      <do_if value="this.ship.zone != $target.zone">
        <!-- TODO @Owen add check if jumping is actually possible ! -->
        <wait exact="10s"/>
        <do_if value="$target.zone.isclass.highway">
          <resume label="start" />
        </do_if>
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$target"/>
          <param name="forcesteering" value="not $bigship" />
          <param name="endintargetzone" value="true" />
          <param name="debugchance" value="$debugchance"/>
        </run_script>
        <wait exact="3s" />
      </do_if>

      <!-- ...and go there! -->
      <label name="move" />
      <do_if value="not $target.exists">
        <return />
      </do_if>
      
      <do_if value="$bigship">
        <!-- go close to player or wait-->
        <do_if value="this.ship.distanceto.{$target}" min="3km + this.ship.size">
          <get_safe_pos object="$target" zone="$target.zone" min="this.ship.size*2" radius="this.ship.size" result="$safepos" allowyaxis="false" />
          <!-- Pick a target point near the object we need to follow -->
          <move_to object="this.ship" destination="$target.zone" usehighways="not $bigship" forceposition="false" forcesteering="not $bigship" finishonapproach="true" sinceversion="1" >
            <position value="$safepos" />
            <interrupt_after_time time="10s" />
          </move_to>
        </do_if>
        <do_else>
          <stop_moving object="this.ship" />
          <wait exact="1s" />
        </do_else>

        <do_if value="this.$taggedobjects?">
          <set_value name="$i" exact="this.$taggedobjects.count" />
          <do_if value="$i gt 0">
            <set_value name="$pickuptarget" exact="this.$taggedobjects.{$i}"/>
            <!-- launch transpoter ship and collect the crate -->
            <launch_masstraffic_drone name="$drone" object="this.ship" category="unitcategory.transport" pickup="true" target="$pickuptarget" />
            <do_if value="$drone.isoperational">
              <remove_value name="this.$taggedobjects.{$i}" />
              <debug_text text="'%1 drone launched [pickup count: %2]'.[player.age, $i]" chance="$debugchance"/>
              <start_script name="'move.collect.drone.vanilla40'" object="$drone.pilot">
                <param name="homebase" value="this.ship" />
                <param name="target" value="$pickuptarget"/>
                <param name="masstraffic" value="true"/>
                <param name="stayactive" value="false" comment="deactivate animation after picked up" />
              </start_script>
              <set_owner object="$pickuptarget" faction="this.ship.owner"/>
            </do_if>
            <do_else>
              <debug_text text="'%1 no drone available [pickup count: %2]'.[player.age, $i]" chance="$debugchance"/>
            </do_else>
          </do_if>
          <do_if value="$i gt 1">
            <!-- speed up sending out of collector ships if there are multiple items tagged -->
            <resume label="move" />
          </do_if>
        </do_if>

        <wait exact="200ms" />

      </do_if>

      <wait exact="1s" />

      <!-- Restart the script from the top -->
      <resume label="start" />

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="command.fight.attack.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="2" version="3">
  <!--
      Wrapper script for player ship attack command.
      Target can be any object: station, ship, component.
  by Adrian
  -->
  <params>
    <param name="target" />
    <param name="escort" default="null" comment="Objects to escort - stay at 'pursuedistance' and shoot enemies attacking this" />
    <param name="speak" default="true" comment="Boolean Speak NPC voice. Default is true" />
    <param name="checkrelation" default="true"/>
    <param name="debugchance" default="0"/>
  </params>
  <init>
    <set_command command="command.attackenemies" />
  </init>
  <patch sinceversion="1" early="true">
    <set_value name="$speak" exact="true" />
  </patch>
  <patch sinceversion="3">
    <set_value name="$checkrelation" exact="true" />
  </patch>
  <attention min="unknown">
    <actions>

      <!-- Initial checks -->
      <label name="start" />
      <debug_text text="'command attack object %1'.[$target.knownname]" chance="$debugchance" />
      
      <!-- <t id="10810">(triggering prepared attack)Albion Skunk to the fleet, commence attack!</t> -->
      <!-- <t id="10811">(triggering prepared order)All ships, move out.</t>-->
      <!-- <speak actor="player.copilot" line="[10810,10811].random" comment="." caninterrupt="false" /> -->

      <do_if value="$target.isoperational">

        <!-- if different zone, go there -->
        <do_if value="this.ship.zone != $target.zone">
          <run_script name="'move.generic.vanilla40'" sinceversion="1">
            <param name="destination" value="$target" />
            <param name="endintargetzone" value="true" />
          </run_script>
        </do_if>
        
        <run_script name="'fight.attack.object.vanilla40'" >
          <param name="target" value="$target" />
          <param name="escort" value="$escort" />
          <param name="pursuetargets" value="not @$escort" />
          <param name="allowothertargets" value="false" />
          <param name="checkrelation" value="$checkrelation"/>
        </run_script>

      </do_if>

      <do_if value="$speak">
        <!-- (task completed)Task finished, Sir -->
        <!-- Awaiting orders -->
        <!-- We await your new orders, Sir -->
        <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[1035, 1301, 1058].random" />
      </do_if>

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="command.fight.enemies.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="2" version="1">
  <!--
      Wrapper script for player ship fight enemies command
      Search and attack all enemies in targetzone, and then return.
      If no enmeies, search for a 5 min.
  by Adrian
  -->
  <params>
    <param name="targetzone" />
    <param name="endtime" default="null" />
    <param name="debugchance" default="0"/>
  </params>
  <init>    
    <!-- Set the timeout, and command -->
    <do_if value="$endtime">
      <set_command command="command.attackenemies"  />
    </do_if>
    <do_else>
      <set_command command="command.patrol"  />
    </do_else>
  </init>
  <patch sinceversion="1" early="true">
    <set_value name="$endtime" exact="player.age + 10min" />
  </patch>
  <attention min="unknown">
    <actions>

      <!-- Initial checks -->
      <label name="start" />
      <debug_text text="'command attack enemies in %1'.[$targetzone.knownname]" chance="$debugchance" />

      <!-- if different zone, go there -->
      <do_if value="this.zone != $targetzone">
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$targetzone" />
          <param name="endintargetzone" value="true" />
        </run_script>
      </do_if>
      
      <!-- If no endtime endless, otherwise use that timeout -->
      <do_while value="(not $endtime or player.age lt $endtime) and $targetzone.exists">   
        <!-- initial random position in zone -->
        <create_random_position_in_boundingbox name="$pos" component="$targetzone" />
        <set_value name="$Y" min="-5000m" max="5000m"/>
        <get_safe_pos result="$pos" radius="this.ship.size" value="position.[$pos.x, $Y, $pos.z]" zone="$targetzone" />

        <run_script name="'move.seekenemies.vanilla40'" >
          <param name="destination" value="$targetzone" />
          <param name="pos" value="$pos" />
          <param name="debugoutputchance" value="$debugchance" />
        </run_script>
        
        <wait exact="500ms" />        
      </do_while>

      <!-- <t id="1035">(task completed)Task finished, Sir.</t> -->
      <!-- <t id="1301">Awaiting orders.</t> -->
      <!-- <t id="1058">We await your new orders, Sir.</t> -->
      <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[1035, 1301, 1058].random" />

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="command.mining.player.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="2" version="1">
  <!--
  Wrapper script for player mining, starting mining.ship.collect
  by Florian
  -->
  <params>
    <param name="miningmode" default="false" />
    <param name="ware" default="null" />
    <param name="zone" default="null" />
    <param name="secwares" default="null" />
    <param name="debugchance" default="0"/>
  </params>
  <attention min="unknown">
    <actions>

      <do_if value="$miningmode">
        <do_if value="player.activity == activity.collect_ore">
          <debug_text text="'now working in mining mode'" />
        </do_if>
        <do_else>
          <debug_text text="'activity / script request mismatch!'" />
        </do_else>
        <set_command command="command.support" param="player.primaryship" />
        <do_if value="this.zone != player.zone">
          <debug_text text="'moving to %1 to begin collecting ore'.[player.zone.knownname]" chance="$debugchance" />
          <!-- say we're on our way -->
          <run_script name="'move.generic.vanilla40'">
            <param name="destination" value="player.primaryship" />
            <param name="abortpath" value="true" />
          </run_script>
        </do_if>
        <run_script name="'mining.ship.player.vanilla40'"/>
      </do_if>
      <do_elseif value="$ware">
        <do_if value="not $zone">
          <find_closest_resource ware="$ware" zone="$zone" refobject="player.ship" />
        </do_if>
        <set_command command="command.mining" param="$zone" />
        <run_script name="'mining.ship.collect.vanilla40'" result="$collectresult">
          <param name="zone" value="$zone" />
          <param name="ware" value="$ware" />
          <param name="secwares" value="$secwares" />
          <param name="debugchance" value="$debugchance" />
        </run_script>
        <run_script name="'lib.recall.drones.vanilla40'" sinceversion="1" />

        <do_if value="not ($collectresult == 'aborted')">
          <do_if value="$ware.tags.indexof.{tag.liquid}">
            <set_value name="$infomining" exact="{1015,24}" comment="Info: 24 mining stopped" />
          </do_if>
          <do_else>
            <set_value name="$infomining" exact="{1015,25}" comment="Info: mineral mining stopped" />
          </do_else>
          
          <run_script name="'player.interaction.vanilla40'" result="$result">
            <param name="Line" value="1210" comment="We stopped mining, sir. If you don't have new orders for us, we will follow you again." />
            <param name="UIText" value="$infomining" comment="Info: (24: gas, 25: mineral) mining stopped" />
            <param name="ConversationParam" value="'g_gas_mining_stopped'" />
          </run_script>

          <remove_value name="$infomining" />
          <debug_text text="'$result: ' + $result" chance="$debugchance" />
          <do_if value="$result" exact="'wait'">
            <set_command command="command.wait" />
            <set_command_action commandaction="commandaction.standingby" />
            <wait />
          </do_if>
        </do_if>
      </do_elseif>
      <do_else>
        <debug_text text="'error, either miningmode or ware must be specified'" chance="$debugchance" />
      </do_else>

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="command.move.dockat.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="2">
  <!--
   Wrapper script for explicit order to 'dock at..'
  by Adrian
  -->
  <params>    
    <param name="destination" default="null" />
    <param name="dockingslot" default="null" />
    <param name="debugchance" default="0"/>
  </params>
  <init>
    <set_command command="command.move" param="$destination" />
  </init>
  <attention min="unknown">
    <actions>

      <debug_text text="'command dock at' + $destination" chance="$debugchance" />
      <!-- Lines for inform of 'Going dock at target' -->

      <run_script name="'move.dockat.vanilla40'" result="$result">
        <param name="destination" value="$destination" />
        <param name="dockingslot" value="$dockingslot" />
      </run_script>

      <wait min="50ms" max="100ms" />
      <debug_text text="'result: ' + $result" chance="$debugchance" />

      <!-- Lines for inform of success or error (which one) -->
      <do_if value="$result == 'success'">
        
      </do_if>
      <do_else>
        <debug_text text="'Error not handled'" />
      </do_else>     

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="command.move.refuel.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="2" version="1">
  <!--
   Wrapper script for explicit order to Refuel
  by Adrian
  -->
  <params>
    <param name="budget" comment="Money (ct) for buy fuel (will be limited if exceed capacity, money account or trade price change)"/>
    <param name="debugchance" default="0"/>
  </params>
  <attention min="unknown">
    <actions>

      <!-- Command is set on refuel script -->

      <set_value name="$result" exact="null" />

      <!-- Star checking for refuel command -->
      <label name="start" />
      <debug_text text="'command refuel. money %1, : '.[$budget]" chance="$debugchance" />

      <do_if value="$budget" exact="0">
        <debug_text text="'budget is 0. Finish'" chance="$debugchance" />
        <resume label="finish"/>
      </do_if>

      <!-- Approx amount of fuel to buy -->
      <set_value name="$amount" exact="$budget/ware.fuelcells.averageprice - this.ship.cargo.{ware.fuelcells}.count"/>
      <debug_text text="'money %1, average price %2, amount: %3'.[$budget, ware.fuelcells.averageprice, $amount]" chance="$debugchance" />

      <do_if value="$amount" exact="0">
        <debug_text text="'trying to buy 0 fuel cells. Finish'" chance="$debugchance" />
        <resume label="finish"/>
      </do_if>

      <!-- Go to refuel at nearest guel station (excluding Shipyards)-->
      <run_script name="'move.refuel.vanilla40'" result="$result">
        <param name="amount" value="$amount" />
        <param name="debugchance" value="$debugchance" />
      </run_script>

      <label name="finish" />

      <wait min="1s" max="2s" />
      <debug_text text="'result: ' + $result" chance="$debugchance" />

      <!-- Lines for inform of success or error (which one) -->
      <do_if value="$result == 'success'">
        <!-- 1035 = (task completed) -->
        <set_value name="$line" exact="1035"/>
        <set_value name="$logline" exact="10" comment="$SHIP$ in sector $SECTOR$ has successfully refueled." />
      </do_if>
      <do_elseif value="$result == 'ERR_JUMPDRIVE_BROKEN'">
        <!-- 1074 = Our Jump Drive is damaged. We need to repair it first -->
        <set_value name="$line" exact="1074" />
        <set_value name="$logline" exact="11" comment="$SHIP$ in sector $SECTOR$ cannot refuel because the Jump Drive is damaged." />
      </do_elseif>
      <do_elseif value="$result == 'ERR_FUEL_STORAGE_MISSING'">
        <!-- 4690 = (can also be used for ships)We are full to our maximum cargo capacity. -->
        <!-- 4691 = (can also be used for ships)We have no free storage space. -->
        <set_value name="$line" exact="[4690,4691].random" />
        <set_value name="$logline" exact="12" comment="$SHIP$ in sector $SECTOR$ cannot refuel because there is no free storage space." />
      </do_elseif>
      <do_elseif value="$result == 'ERR_FIND_FUEL_FAILED'" chance="0" comment="disabled because no lines">
      </do_elseif>
      <do_elseif value="$result == 'ERR_JUMP_FAILED'" chance="0" comment="disabled because no lines">
      </do_elseif>
      <do_elseif value="$result == 'ERR_DOCKING_FAILED'" chance="0" comment="disabled because no lines">
      </do_elseif>
      <do_elseif value="$result == 'ERR_EXECUTE_TRADE_FAILED'">
        <!-- 1163">(Fail)That trade will not be possible here, please advise. -->
        <set_value name="$line" exact="1163" />
        <set_value name="$logline" exact="13" comment="$SHIP$ in sector $SECTOR$ is not able to buy jump fuel." />
      </do_elseif>
      <do_else>
        <debug_text text="'Error not handled'" chance="$debugchance" />
        <!-- (reject order 1)Sorry, Sir, I can't do that. -->
        <!-- (reject order 2)That's not possible. -->
        <set_value name="$line" exact="[1014,1015].random" />
      </do_else>

      <!-- If there is something to say, inform player with the result -->
      <do_if value="@$line">
        <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="$line" />
        <wait min="1s" max="2s" sinceversion="1" />
      </do_if>
      <do_if value="@$logline and this.sector">
        <substitute_text text="$logtext" source="readtext.{1016}.{$logline}">
          <replace string="'$SHIP$'" with="this.ship.name" />
          <replace string="'$SECTOR$'" with="this.sector.name" />
        </substitute_text>
        <write_to_logbook category="upkeep" text="$logtext" />
      </do_if>

      <!-- Return remaining money (if there is)-->
      <do_if value="this.hasownaccount">
        <remove_actor_account actor="this" transfer="true" />
      </do_if>

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="command.move.taxi.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="2">
  <!--
  Wait for the player to dock (if he's not docked yet) and move(boost) to the target zone
  -->
  <params>
    <param name="destination" />
    <param name="debugchance" default="0"/>
  </params>
  <init>
    <set_command command="command.movetozone" param="$destination" />
    <set_command_action commandaction="commandaction.standingby" />
  </init>
  <attention min="unknown">
    <actions>

      <do_if value="player.ship != this.ship">
        <speak actor="player.entity" line="1053" comment="Captain, wait for me to dock. I'm coming with you." />
      </do_if>

      <!-- recall drones -->
      <run_script name="'lib.recall.drones.vanilla40'" />

      <!--
      <do_if value="player.primaryship.distanceto.{this.ship} gt 15km">
        <run_script name="'move.follow'">
          <param name="destination" value="player.primaryship.zone" />
        </run_script>
      </do_if>
      <do_if value="player.primaryship.distanceto.{this.ship} le 15km">

      </do_if>
      -->

      <set_value name="$docked" exact="false" />
      <do_while value="player.ship != this.ship">
        <wait>
          <interrupt>
            <conditions>
              <event_object_docked object="player.primaryship" dock="this.ship" />
            </conditions>
            <actions>
              <set_value name="$docked" exact="true" />
              <debug_text text="'Player docked at %1, now moving to %2\ndebug info: obj=%3, param=%4, param2=%5'.[this.ship.knownname, $destination.knownname, event.object.knownname, event.param.knownname, event.param2.knownname]" chance="$debugchance" />
            </actions>
          </interrupt>
        </wait>
        <do_if value="$docked">
          <break />
        </do_if>
      </do_while>

      <run_script name="'move.generic.vanilla40'">
        <param name="destination" value="$destination" />
        <param name="endintargetzone" value="$destination.isclass.zone" />
      </run_script>

      <do_if value="player.ship == this.ship">
        <speak actor="this" line="[1037,1038].random" comment="We're in position, Sir. OR We've arrived." />
      </do_if>

      <!--
      <t id="1029">(engage boost)Engaging boosters.</t>
      <t id="1032">(moveto)Confirmed. Moving out.</t>
      <t id="1037">(arrived)We're in position, Sir.</t>
      <t id="1038">(arrived)We've arrived.</t>
      
      Ren Otani:
      <t id="1053">Captain, wait for me to dock. I'm coming with you.</t>
      -->


    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="command.move.wait.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="2" version="3">
  <!--
   Wrapper script for explicit order to Move and Wait command
   by Adrian
   
   Variations:
    - Hold Position
    - Fly to me and wait
    - Fly to X and wait
    - Withdraw from battle
  
  -->
  <params>
    <param name="destination" default="null" comment="Object or Zone. If highway, will use the exit" />
    <param name="position" default="null" comment="Position relative to destination. Null by default" />
    <param name="withdraw" default="false" />
    <param name="debugchance" default="0"/>
  </params>
  <patch sinceversion="2" >
    <debug_text text="'patch'" />
    <set_value name="$withdraw" exact="false" />
  </patch>
  <attention min="unknown">
    <actions>

      <!-- Initial checks -->
      <label name="start" />
      <debug_text text="'command move to %1 and wait'.[$destination.knownname]" chance="$debugchance" />

      <!-- Withdraw from battle -->
      <do_if value="$withdraw">
        <!-- Command -->
        <set_command command="command.withdrawbattle" />
        <!-- savegame compat -->
        <move_to object="this.ship" destination="this.zone" forceposition="false" finishonapproach="true" boost="true" sinceversion="2" chance="0">
          <position object="this.ship" value="$finalpos" />
          <interrupt_after_time time="0s" />
        </move_to>
        <!-- flee boosting  -->
        <run_script name="'move.flee.boost.vanilla40'" sinceversion="3"/>
      </do_if>
      
      <!-- If no destination is provided, just a wait -->
      <do_elseif value="$destination">
        <!-- Command Info -->
        <do_if value="$destination.isclass.zone">
          <set_command command="command.movetozone" param="$destination"/>
        </do_if>
        <do_else>
          <set_command command="command.move" param="$destination"/>
        </do_else>

        <!-- Move there -->
        <!-- <t id="1301">Awaiting orders.</t> -->
        <!-- <t id="1058">We await your new orders, Sir.</t> -->
        <!-- <speak actor="this" line="[1301,1058].random" comment="" caninterrupt="false" /> -->

        <do_if value="$destination.zone.isclass.highway" >
          <set_value name="$destination" exact="$destination.zone.exit"  />
        </do_if>

        <!-- Move generic to destitnation wiht optional position. End in zone if destination is zone and there is no position -->
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$destination" />
          <param name="position" value="$position" />
          <param name="endintargetzone" value="$destination.isclass.{class.zone} and not $position" />
          <param name="rotation" value="rotation.[0,0,0]" />
        </run_script>
      </do_elseif>

      <!-- Wait for orders -->
      <set_command command="command.wait" />
      <set_command_action commandaction="commandaction.standingby" />

      <!-- <t id="1035">(task completed)Task finished, Sir.</t> -->
      <!-- <t id="1301">Awaiting orders.</t> -->
      <!-- <t id="1058">We await your new orders, Sir.</t> -->
      <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[1035, 1301, 1058].random" />

      <stop_moving object="this.ship" />
      <stop_boost object="this.ship" />

      <label name="wait" />
      
      <wait />

    </actions>
  </attention>
  <on_abort>
    <do_if value="$withdraw and this.ship.defencenpc.exists">
      <signal_objects object="this.ship.defencenpc" param="'stop attack'" param2="'stop permanent'" comment="Set Hold Fire Mode" />
    </do_if>

    <stop_moving object="this.ship" />
    <stop_boost object="this.ship" />
  </on_abort>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<!--
this script sends a drone to pick up an object (crate or rock)
-->
<aiscript name="drone.pickup.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="target" />
    <param name="stayactive" default="true" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler comment="target destroyed">
      <conditions>
        <check_any>
          <event_object_destroyed object="$target" />
          <event_object_picked_up object="$target"/>
        </check_any>
        <check_value value="event.param" exact="this.ship" negate="true" />
      </conditions>
      <actions>
        <abort_called_scripts resume="targetlost" />
      </actions>
    </handler>
  </interrupts>
  <attention min="visible">
    <actions>

      <label name="start" />

      <!-- Check if it exists or it is already picked up. TODO: check friendship for steal or not -->
      <do_if value="not $target.exists or @$target.ship">
        <resume label="targetlost" />
      </do_if>

      <set_value name="this.$pickuptarget" exact="$target"/>
      <!--<set_command_action commandaction="commandaction.flyingto" param="$target"/>-->

      <!-- this will default to generic steering behaviour until the drone is close enough to the target -->
      <move_to object="this.ship" destination="$target" finishonapproach="true" forcesteering="true" />
      <do_if value="not $target.exists or @$target.ship">
        <resume label="targetlost" />
      </do_if>

      <!-- disable collision and collision avoidance -->
      <disable_collisions_between object="this.ship" target="$target" />
      <set_avoid_collisions object="this.ship" enabled="false" />
      <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.pickupdrone" forcesteering="true" />

      <do_if value="not $target.exists or @$target.ship">
        <resume label="targetlost" />
      </do_if>

      <debug_text text="player.age+' prepare pickup'" chance="$debugoutputchance"/>

      <!-- this starts the StopAndAlign movement of the target object which stops rotation and aligns it for pickup -->
      <pickup_target ship="this.ship" target="$target" prepare="true" />

      <do_if value="not $target.exists or @$target.ship">
        <resume label="targetlost" />
      </do_if>

      <!-- start pickup animation on drone -->
      <set_object_active object="this.ship" activate="true"/>

      <!-- wait for activate animation to finish -->
      <wait exact="4s" />

      <do_if value="not $target.exists or @$target.ship">
        <resume label="targetlost" />
      </do_if>

      <!-- pick up object -->
      <pickup_target ship="this.ship" target="$target" />
      <do_if value="$target.parent" exact="this.ship">
        <set_owner object="$target" faction="this.ship.owner"/>
      </do_if>
      <do_else>
        <debug_text text="player.age + ' $target is not connected properly.'" chance="$debugoutputchance"/>
        <resume label="targetlost"/>
      </do_else>

      <!-- if the drone should remain in activated state (ore collector), skip this. Otherwise deactivate and wait for that animation to finish before returning -->
      <do_if value="not $stayactive">
        <wait exact="250ms" />
        <set_object_active object="this.ship" activate="false"/>
        <wait exact="3s" />
      </do_if>

      <!-- yay, we picked up the object -->
      <!-- restore collision avoidance -->
      <set_avoid_collisions object="this.ship" enabled="true" />
      <return value="true" />

      <!-- something went wrong, the target does no longer exist -->
      <label name="targetlost" />
      <debug_text text="player.age+' target lost'" chance="$debugoutputchance"/>
      <set_avoid_collisions object="this.ship" enabled="true" />
      <stop_moving object="this.ship"/>
      <return value="false" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <label name="start" />
      <do_if value="this.ship.pickedupobject.exists">
        <set_avoid_collisions object="this.ship" enabled="true" />
        <return value="true" />
      </do_if>
      <label name="targetlost" />
      <set_avoid_collisions object="this.ship" enabled="true" />
      <return value="false" />
    </actions>
  </attention>
  <on_abort>
    <set_object_active object="this.ship" activate="false"/>
    <set_avoid_collisions object="this.ship" enabled="true" />
    <stop_moving object="this.ship"/>
  </on_abort>
</aiscript>

<?xml version="1.0" encoding="iso-8859-1" ?>
<!--
this script is run on a drone launched from a dronelaunchpad
Author: Michael
-->
<aiscript name="drone.requestorders.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <attention min="visible">
    <actions>

      <!-- wait until launch completes -->
      <wait>
        <interrupt>
          <conditions>
            <check_any>
              <!--<event_object_approaching_waypoint object="this.ship" lastwaypoint="true" />-->
              <event_object_arrived_at_waypoint object="this.ship" lastwaypoint="true" />
            </check_any>
          </conditions>
        </interrupt>
      </wait>

      <clear_collision_filter object="this.ship" />

      <join_formation leader="this.ship.commander" object="this.ship" />
      <!-- TEMP HACK to cancel relative-movement -->
      <move_to object="this.ship" abortpath="true" relativemovement="false" destination="this.ship.commander" >
        <interrupt_after_time time="10ms" />
      </move_to>

      <!-- Start the follower routine -->
      <run_script name="'fight.attack.object.drone.follower.vanilla40'"/>
      <wait min="2s" max="10s" />
      
    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <run_script name="'fight.attack.object.drone.follower.vanilla40'" sinceversion="1" />
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="utf-8" ?>
<aiscript name="drone.transport.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--
  this script is run on a drone launched from a platform launchpad
  Author: Michael
  -->
  <params>
    <param name="target" default="null" />
    <param name="targetnpc" default="null" />
    <param name="origin" default="null" />
  </params>
  <attention min="visible">
    <actions>

      <!-- 
      TODO:
      - handle player room change
     
      -->

      <label name="launch" />
      <disable_collision_response object="this.ship" />
      <set_avoid_collisions object="this.ship" enabled="false" />
      <set_value name="$starttime" exact="player.age" />
      <set_value name="$drone" exact="this.ship" comment="keep a reference to the drone, since it won't be accessible with this.ship once the actor has been moved!" />
      <do_if value="$target == player.primaryship or $targetnpc == player.entity">
        <signal_objects object="player.entity" param="'launch_remote_transport'" param2="this.ship"/>
        <register_player_remote_transport object="$drone" />
      </do_if>
      <!-- we start this script while we are launching -->
      <wait max="5s">
        <interrupt>
          <conditions>
            <check_any>
              <event_object_approaching_waypoint object="this.ship" lastwaypoint="true" />
              <event_object_arrived_at_waypoint object="this.ship" lastwaypoint="true" />
            </check_any>
          </conditions>
        </interrupt>
      </wait>
      <wait exact="100ms" comment="we just want to wait 1 frame to make sure the events have been processed" />

      <label name="flytotarget" />
      <do_if value="$target.exists">
        <set_owner object="this" faction="$target.trueowner" />
        <set_owner object="this.ship" faction="$target.trueowner" />
        <do_if value="$target.isclass.launchpad">
          <set_value name="$targetobject" exact="$target.container" />
          <debug_text text="'fly to ' + $targetobject.knownname" />
          <get_docking_approach_pos dronedock="$target" ship="this.ship" position="$approachpos" rotation="$approachrot" />
          <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.remotetransportdrone" avoid="false" forcesteering="true" finishonapproach="true" usehighways="false">
            <position value="$approachpos" />
            <rotation value="$approachrot" />
          </move_to>
          <debug_text text="'dock at launchpad'" />
          <move_docking object="this.ship" dronedock="$target" flightbehaviour="flightbehaviour.dock_highspeed">
            <interrupt_after_time time="30s" />
          </move_docking>
        </do_if>
        <do_elseif value="$target.isclass.container">
          <set_value name="$targetobject" exact="$target" />
          <do_if value="$target == player.primaryship">
            <debug_text text="'fly to playership'" />
            <find_dock_location container="$target" name="$dock" size="this.ship.docksize" />
            <do_if value="$dock">
              <get_docking_approach_pos dock="$dock" ship="this.ship" position="$approachpos" rotation="$approachrot" />

              <!-- <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.spline" /> -->
              <move_to object="this.ship" destination="$dock.component" flightbehaviour="flightbehaviour.remotetransportdrone" avoid="false" finishonapproach="true" usehighways="false">
                <position value="$approachpos" />
                <rotation value="$approachrot" />
                <interrupt_after_time time="30s" />
              </move_to>
              <debug_text text="'move_docking'" />
              <move_docking object="this.ship" dock="$dock" flightbehaviour="flightbehaviour.dock_highspeed">
                <interrupt_after_time time="30s" />
              </move_docking>
              <debug_text text="'docked at playership'" />
            </do_if>
            <do_else>
              <set_remote_transport_target object="this.ship" target="$target" />
              <debug_text text="'ramming speed'" />
              <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.remotetransportdrone" avoid="false" forcesteering="true" finishonapproach="true" usehighways="false">
                <interrupt>
                  <conditions>
                    <event_object_signalled object="this.ship" param="'remote_transport_arrived'" />
                  </conditions>
                  <actions>
                    <debug_text text="'received arrived signal for playership (1)'" />
                    <set_value name="$arrived" exact="true" />
                  </actions>
                </interrupt>
              </move_to>
              <do_if value="not $arrived?">
                <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.remotetransportdrone" avoid="false" forcesteering="true" relativemovement="true" usehighways="false">
                  <interrupt>
                    <conditions>
                      <event_object_signalled object="this.ship" param="'remote_transport_arrived'" />
                    </conditions>
                    <actions>
                      <debug_text text="'received arrived signal for playership (2)'" />
                    </actions>
                  </interrupt>
                </move_to>
              </do_if>
              <remove_value name="$arrived" />
            </do_else>
          </do_if>
          <do_else>
            <!-- find a dock location, try administrative platform first, then accept any platform -->
            <find_dock_location container="$target" name="$dock" numfreeactorslots="1" size="player.primaryship.docksize" dockpopulationtype="dockpopulationtype.administrative" />
            <do_if value="not $dock">
              <find_dock_location container="$target" name="$dock" numfreeactorslots="1" size="player.primaryship.docksize" />
            </do_if>
            <do_if value="$dock">
              <!-- check if we can find a launchpad at this dock -->
              <find_object_component object="$dock.component.parent" exactclass="class.launchpad" name="$launchpad" />
              <do_if value="$launchpad.exists">
                <set_value name="$target" exact="$launchpad" />
                <resume label="flytotarget" />
              </do_if>
              <move_to object="this.ship" destination="$dock.component" flightbehaviour="flightbehaviour.remotetransportdrone" avoid="false" forcesteering="true" finishonapproach="true" usehighways="false" />
              <debug_text text="'move_docking'" />
              <move_docking object="this.ship" dock="$dock" flightbehaviour="flightbehaviour.dock_highspeed">
                <interrupt_after_time time="30s" />
              </move_docking>
              <debug_text text="'docked at target'" />
            </do_if>
            <do_else>
              <debug_text text="'fly collision course'" />
              <set_remote_transport_target object="this.ship" target="$target" />
              <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.remotetransportdrone" avoid="false" forcesteering="true" finishonapproach="true" usehighways="false">
                <interrupt>
                  <conditions>
                    <event_object_signalled object="this.ship" param="'remote_transport_arrived'" />
                  </conditions>
                  <actions>
                    <debug_text text="'received arrived signal for target (1)'" />
                    <set_value name="$arrived" exact="true" />
                  </actions>
                </interrupt>
              </move_to>
              <do_if value="not $arrived?">
                <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.remotetransportdrone" avoid="false" forcesteering="true" relativemovement="true" usehighways="false">
                  <interrupt>
                    <conditions>
                      <event_object_signalled object="this.ship" param="'remote_transport_arrived'" />
                    </conditions>
                    <actions>
                      <debug_text text="'received arrived signal for target (2)'" />
                    </actions>
                  </interrupt>
                </move_to>
                <remove_value name="$arrived" />
              </do_if>
            </do_else>
          </do_else>
        </do_elseif>
        <do_else>
          <debug_text text="'ERROR, target invalid!'" />
        </do_else>
      </do_if>
      <do_elseif value="$targetnpc.exists">
        <set_value name="$target" exact="$targetnpc.container" />
        <debug_text text="'no target but targetnpc is valid, set target to ' + $target" />
        <resume label="flytotarget" />
      </do_elseif>
      <do_else>
        <!-- we have no target, find one -->
        <set_owner object="this" faction="faction.civilian" />
        <set_owner object="this.ship" faction="faction.civilian" />
        <find_station space="this.zone" name="$target">
          <match_relation faction="faction.civilian" relation="neutral" comparison="ge" />
        </find_station>
        <do_if value="$target.exists">
          <resume label="flytotarget" />
        </do_if>
        <do_else>
          <debug_text text="'fly into open space'" />
          <create_position name="$sectorpos" space="this.sector" min="100km" max="200km" object="this.ship" />
          <move_to object="this.ship" destination="this.sector" usehighways="false">
            <position value="$sectorpos" />
            <interrupt_after_time time="1min" />
          </move_to>
        </do_else>
        <resume label="end" />
      </do_else>

      <label name="transfer" />
      <!-- if we are here we assume we have arrived at the target -->
      <set_value name="$success" exact="false" />
      <do_if value="$target.exists">
        <do_if value="$target == player.primaryship">
          <do_if value="this.isclass.npc">
            <!-- transfer npc to playership -->
            <do_if value="this.iscontrolentity">
              <debug_text text="'remove this as pilot control entity'" />
              <dismiss_pilot object="this.ship" />
            </do_if>
            <do_if value="player.ship == player.primaryship and not player.room.isclass.cockpit">
              <play_cutscene key="'EnterPlayerShipWithDrone'">
                <param name="npcref" object="this" />
              </play_cutscene>
            </do_if>
            <add_actor_to_playership actor="this" result="$success" />
            <do_if value="$success">
              <debug_text text="'successfully transferred actor to playership'" />
              <play_sound object="player.primaryship" sound="'tdrone_dockat_pship'" />
              <set_value name="$sendsignal" exact="true" />
              <do_if value="$origin != player.primaryship">
                <!-- this will trigger the arrived conversation with a delay at the end of the script (after the drone has already been destroyed) -->
                <set_value name="$startconversation" exact="true" />
              </do_if>
            </do_if>
            <do_else>
              <!-- moving the actor failed! -->
              <signal_objects object="player.entity" param="'remote_passenger_transport_failed'" param2="this" />
              <do_if value="$origin.isoperational and ($target != $origin)">
                <set_value name="$target" exact="$origin" />
              </do_if>
              <do_else>
                <find_station space="this.zone" name="$target">
                  <match_relation object="this" relation="neutral" comparison="ge" />
                </find_station>
              </do_else>
              <set_value name="$targetnpc" exact="null" />
              <debug_text text="'transferring actor to playership failed! Flying back to ' + $target" />
              <resume label="flytotarget" />
            </do_else>
          </do_if>
          <do_elseif value="$targetnpc.exists">
            <debug_text text="'transfer_inventory_to_target on playership'" />
            <transfer_remote_inventory_to entity="this" target="$targetnpc" />
            <set_value name="$success" exact="true" />
          </do_elseif>
          <do_else>
            <debug_text text="'ERROR, target NPC invalid!'" />
          </do_else>
        </do_if>
        <do_else>
          <!-- target is not the playership -->
          <do_if value="not this.isclass.npc">
            <do_if value="$targetnpc.exists">
              <!-- we want to transfer inventory -->
              <debug_text text="'transfer_inventory_to_target'" />
              <transfer_remote_inventory_to entity="this" target="$targetnpc" />
              <set_value name="$success" exact="true" />
            </do_if>
          </do_if>
          <do_elseif value="$target.isplayerowned">
            <!-- we want to transfer a passenger to a player owned object -->
            <do_if value="$target.isclass.launchpad">
              <find_object_component name="$dockingbay" class="class.dockingbay" object="$target.parent" />
            </do_if>
            <do_elseif value="@$dock">
              <set_value name="$dockingbay" exact="$dock.component"/>
            </do_elseif>
            <set_value name="$success" exact="false" />
            <do_if value="@$dockingbay">
              <do_if value="this.iscontrolentity">
                <debug_text text="'remove this as pilot control entity'" />
                <dismiss_pilot object="this.ship" />
              </do_if>
              <add_actor_to_platform actor="this" dockingbay="$dockingbay" result="$success" />
            </do_if>
            <do_else>
              <debug_text text="'add actor to room'" />
              <add_actor_to_room actor="this" object="$target" result="$success" />
            </do_else>
            <do_if value="not $success">
              <!-- ok, adding actor to originally intended platform did not work, try to find another one -->
              <find_dock_location container="$target" name="$dock" numfreeactorslots="1" size="player.primaryship.docksize" dockpopulationtype="dockpopulationtype.administrative" />
              <do_if value="not $dock">
                <find_dock_location container="$target" name="$dock" numfreeactorslots="1" size="player.primaryship.docksize" />
              </do_if>
              <do_if value="$dock">
                <do_if value="this.iscontrolentity">
                  <debug_text text="'remove this as pilot control entity'" />
                  <dismiss_pilot object="this.ship" />
                </do_if>
                <add_actor_to_platform actor="this" dockingbay="$dock.component" result="$success" />
              </do_if>
            </do_if>
            <do_if value="$success">
              <debug_text text="'successfully transferred actor to player object'" />
              <signal_objects object="this" param="'remote_passenger_arrived'" />
            </do_if>
            <do_elseif value="$origin.isoperational and ($target != $origin)">
              <signal_objects object="player.entity" param="'remote_passenger_transport_failed'" param2="this" />
              <set_value name="$target" exact="$origin" />
              <resume label="flytotarget" />
            </do_elseif>
          </do_elseif>
        </do_else>
      </do_if>
      <do_else>
        <!-- target does not exist -->
        <debug_text text="'ERROR, target no longer exists! Destroyed during transit?'" />
      </do_else>


      <label name="end" />
      <debug_text text="'total flight time: %1s'.[player.age - $starttime]" />
      <do_if value="$target == player.primaryship or $targetnpc == player.entity">
        <unregister_player_remote_transport object="$drone" />
      </do_if>
      <do_if value="$success or @$origin.isplayerowned">
        <unlock_achievement name="REMOTE_DRONE" />
      </do_if>
      <do_if value="(not $success) and $targetnpc.exists">
        <abort_remote_transport entity="this" target="$targetnpc" />
        <remove_value name="$sendsignal" />
        <remove_value name="$startconversation" />
      </do_if>
      <debug_text text="'self destruct'" />
      <do_if value="$drone.exists">
        <destroy_object object="$drone" explosion="false" />
      </do_if>
      <do_else>
        <debug_text text="'drone already killed?'" />
      </do_else>
      <do_if value="$startconversation?">
        <!-- Start queued conversation because typically this happens while still in a menu -->
        <wait exact="2s" />
        <start_conversation conversation="Speak" type="normal" actor="this" convparam="3163" comment="All right, I'm on board." />
      </do_if>
      <do_if value="$sendsignal?">
        <signal_objects object="this" param="'remote_passenger_arrived'" />
      </do_if>
    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <label name="launch" />
      <set_value name="$drone" exact="this.ship" comment="keep a reference to the drone, since it won't be accessible with this.ship once the actor has been moved!" />
      <do_if value="$target == player.primaryship or $targetnpc == player.entity">
        <signal_objects object="player.entity" param="'launch_remote_transport'" param2="this.ship"/>
        <register_player_remote_transport object="$drone" />
      </do_if>
      <resume label="end" />

      <label name="flytotarget" />

      <label name="transfer" />
      <set_value name="$success" exact="false" />
      <do_if value="$target.exists">
        <do_if value="$target.isplayerowned">
          <debug_text text="'jump to destination in low attention, transfer anyway'" />
          <do_if value="not this.isclass.npc">
            <do_if value="$targetnpc.exists">
              <!-- we want to transfer inventory -->
              <debug_text text="'transfer_inventory_to_target'" />
              <transfer_remote_inventory_to entity="this" target="$targetnpc" />
              <set_value name="$success" exact="true" />
            </do_if>
          </do_if>
          <do_elseif value="$target != player.primaryship">
            <do_if value="$target.isclass.launchpad">
              <find_object_component name="$dockingbay" class="class.dockingbay" object="$target.parent" />
            </do_if>
            <do_elseif value="$dock?">
              <set_value name="$dockingbay" exact="$dock.component"/>
            </do_elseif>
            <do_if value="$dockingbay?">
              <do_if value="this.iscontrolentity">
                <debug_text text="'remove this as pilot control entity'" />
                <dismiss_pilot object="this.ship" />
              </do_if>
              <add_actor_to_platform actor="this" dockingbay="$dockingbay" result="$success" />
            </do_if>
            <do_if value="not $success">
              <!-- ok, adding actor to originally intended platform did not work, try to find another one -->
              <find_dock_location container="$target" name="$dock" numfreeactorslots="1" size="player.primaryship.docksize" dockpopulationtype="dockpopulationtype.administrative" />
              <do_if value="not $dock">
                <find_dock_location container="$target" name="$dock" numfreeactorslots="1" size="player.primaryship.docksize" />
              </do_if>
              <do_if value="$dock">
                <do_if value="this.iscontrolentity">
                  <debug_text text="'remove this as pilot control entity'" />
                  <dismiss_pilot object="this.ship" />
                </do_if>
                <add_actor_to_platform actor="this" dockingbay="$dock.component" result="$success" />
              </do_if>
            </do_if>
            <do_if value="$success">
              <debug_text text="'successfully transferred actor to player object'" />
            </do_if>
            <do_elseif value="$origin == player.primaryship">
              <!-- transfer npc back to playership, instant transfer -->
              <do_if value="this.iscontrolentity">
                <debug_text text="'remove this as pilot control entity'" />
                <dismiss_pilot object="this.ship" />
              </do_if>
              <do_if value="player.ship == player.primaryship and not player.room.isclass.cockpit">
                <play_cutscene key="'EnterPlayerShipWithDrone'">
                  <param name="npcref" object="this" />
                </play_cutscene>
              </do_if>
              <add_actor_to_playership actor="this" result="$success" />
              <do_if value="$success">
                <debug_text text="'successfully returned actor to playership'" />
                <signal_objects object="this" param="'remote_passenger_arrived'" />
                <play_sound object="player.primaryship" sound="'tdrone_dockat_pship'" />
              </do_if>
              <do_else>
                <signal_objects object="player.entity" param="'remote_passenger_transport_failed'" param2="this" />
              </do_else>
            </do_elseif>
          </do_elseif>
          <do_else>
            <debug_text text="'no transfer to playership when playership flies away!'" />
            <signal_objects object="player.entity" param="'remote_passenger_transport_failed'" param2="this" />
          </do_else>
        </do_if>
      </do_if>

      <label name="end" />
      <do_if value="$target == player.primaryship or $targetnpc == player.entity">
        <unregister_player_remote_transport object="$drone" />
      </do_if>
      <do_if value="(not $success) and $targetnpc.exists">
        <abort_remote_transport entity="this" target="$targetnpc" />
      </do_if>
      <do_if value="$success or @$origin.isplayerowned">
        <unlock_achievement name="REMOTE_DRONE" />
      </do_if>
      <debug_text text="'transport drone going into low attention... all untransferred goods / passengers are now lost!'" />
      <destroy_object object="$drone" explosion="false" />
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="droneability.attack.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="2">
  <params>
    <param name="target" default="null" />
    <param name="debugoutputchance" default="0" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
  </interrupts>
  <init>
    <set_command command="command.attackenemies" />
  </init>
  <attention min="visible">
    <actions>

      <do_if value="not this.ship.dronecommander.isoperational">
        <!-- no valid commander -->
        <return />
      </do_if>

      <set_value name="$usetarget" exact="$target.isoperational" />
      <do_if value="$usetarget">
        <set_value name="$usetarget" exact="$target.mayattack.{this.ship.dronecommander}" />
      </do_if>
      <set_value name="$startinspace" exact="true" />

      <do_if value="this.ship.dockslot">
        <run_script name="'droneability.launch.vanilla40'" />
        <!-- begin in idle move with formation, to not merge drones flight -->
        <resume label="idle" />
      </do_if>

      <label name="start" />

      <set_object_active object="this.ship" activate="true"/>

      <!-- Find additional enemy targets (and chose primary target if none supplied) -->
      <label name="findtarget" />
      <create_group groupname="$targetgroup" />
      <find_gravidar_contact object="this.ship.dronecommander" functional="true" multiple="true" integrated="false" invulnerable="false" groupname="$targetgroup">
        <match_relation object="this.ship.dronecommander" relation="enemy" />
        <match_distance object="this.ship.dronecommander" space="this.ship.dronecommander.zone"  max="1.9km" />
      </find_gravidar_contact>
      <do_if value="(not $targetgroup.count) and (not $findtargettimeout?)">
        <set_value name="$findtargettimeout" exact="player.age + 120s" />
      </do_if>

      <!-- Calculate distances and select the closet -->
      <do_if value="(not $usetarget) and ($targetgroup.count)">
        <create_list name="$targetdists" exact="$targetgroup.count" />
        <do_all exact="$targetgroup.count" counter="$i">
          <set_value name="$targetdists.{$i}" exact="this.ship.dronecommander.distanceto.{$targetgroup.{$i}}" />
        </do_all>
        <!-- If there is a min distance -->
        <set_value name="$min_dist" exact="$targetdists.min" />
        <do_if value="$min_dist lt 2km">
          <set_value name="$target" exact="$targetgroup.{$targetdists.indexof.{$min_dist}}" />
        </do_if>
        <remove_value name="$min_dist" />
        <remove_value name="$targetdists" />
      </do_if>
      <!-- Check target -->
      <do_if value="not $target.isoperational">
        <wait min="100ms" max="200ms" />
        <resume label="idle" />
      </do_if>

      <!-- Set up weapons to fire on target(s) -->
      <label name="openfire" />
      <leave_formation object="this.ship" />
      <shoot_at object="this.ship" target="$target" additional_targets="$targetgroup.list" locktarget="true" slot="tag.primary_slot" tolerance="7.5deg" />
      <shoot_at object="this.ship" target="$target" locktarget="true" slot="tag.secondary_slot" tolerance="10.0deg" />
      <remove_value name="$findtargettimeout" />

      <!-- Repeat until target is dead or timeout reached -->
      <label name="loop" />
      <do_while value="$target.isoperational">

        <do_if value="(not $usetarget) and ($target.distanceto.{this.ship.dronecommander} gt 2km)">
          <resume label="ceasefire" />
        </do_if>

        <do_if value="not $target.mayattack.{this.ship.dronecommander}">
          <resume label="ceasefire" />
        </do_if>

        <!-- Move towards target position -->
        <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.dogfight1" abortpath="true" forcesteering="true">
          <interrupt>
            <conditions>
              <check_any>
                <event_object_destroyed object="$target" />
                <check_all>
                  <event_object_changed_owner object="$target" />
                  <check_value value="not $target.mayattack.{this.ship.dronecommander}" />
                </check_all>
              </check_any>
            </conditions>
            <actions>
              <resume label="ceasefire" />
            </actions>
          </interrupt>
        </move_to>

        <do_if value="$target.isoperational">
          <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.gaindistance" abortpath="true" forcesteering="true">
            <interrupt_after_time time="30s" />
          </move_to>
        </do_if>

      </do_while>

      <label name="ceasefire" />
      <set_value name="$target" exact="null" />
      <set_value name="$usetarget" exact="false" />
      <stop_shooting object="this.ship" slot="tag.primary_slot" />
      <stop_shooting object="this.ship" slot="tag.secondary_slot" />

      <label name="idle" />
      <do_if value="not $findtargettimeout?">
        <set_value name="$findtargettimeout" exact="player.age + 120s" />
      </do_if>

      <do_if value="player.age lt $findtargettimeout">
        <!-- if I don't have formation, or my actual formation is not in dronecommader-->
        <do_if value="this.ship.dronecommander != this.ship.formationleader">
          <!-- small wait to avoid simultaneous formation joins -->
          <wait max="2s" sinceversion="2" />
          <!-- If on different formation, leave -->
          <leave_formation object="this.ship" />
          <!-- if commander has no formation, create one, otherwise change the shape -->
          <create_formation object="this.ship.dronecommander" formation="formationshape.invvshape" param="100m" />
          <!-- Join the commanders formation -->
          <join_formation leader="this.ship.dronecommander" object="this.ship" />
          <debug_text text="'join formation with %1'.[this.ship.dronecommander]" chance="$debugoutputchance" />
        </do_if>
        <!-- wait and return to find targets -->
        <wait min="2s" max="10s" />
        <resume label="findtarget" />
      </do_if>

      <!-- all done, return to formation and cease fire -->
      <label name="end" />
      <stop_shooting object="this.ship" slot="tag.primary_slot" />
      <stop_shooting object="this.ship" slot="tag.secondary_slot" />
      <set_object_active object="this.ship" activate="false"/>

      <!-- set flight behaviour to the default again -->
      <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.default" />
      <run_script name="'move.dockat.playerdrone.vanilla40'"/>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <label name="start" />
      <label name="findtarget" />
      <label name="openfire" />
      <label name="loop" />
      <label name="ceasefire" />
      <label name="idle" />
      <label name="end" />

      <!-- Compatibility blocks -->
      <run_script name="'move.dockat.playerdrone.vanilla40'" sinceversion="1" chance="0">
        <param name="immediate" value="true"/>
      </run_script>

      <!-- cleanup -->
      <destroy_object object="this.ship" explosion="false" />

      <!-- drone no longer exists if the drone docked successfully -->
      <debug_text text="player.age+' drone docked.'" chance="$debugoutputchance"/>

    </actions>
  </attention>
  <on_abort>
    <cease_fire object="this.ship" />
  </on_abort>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<!--
this script handles launching a drone from the current dock
Author: Michael
-->
<aiscript name="droneability.launch.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <attention min="visible">
    <actions>

      <set_value name="$debugoutputchance" exact="0" />
      
      <label name="start" />
      <debug_text text="'undock start'" chance="$debugoutputchance" />

      <!-- check if we are currently docked -->
      <do_if value="this.ship.dockslot != null">

        <!-- store dockslot here because we can't access it via this.ship later -->
        <set_value name="$olddockslot" exact="this.ship.dockslot" />

        <!-- ok, everything checks out, now start the undocking procedure -->
        <request_undocking ship="this.ship" queued="1" result="$success" />
        <do_while value="$success" exact="0">
          <wait min="2s" max="10s" />
          <request_undocking ship="this.ship" queued="1" result="$success" />
        </do_while>

        <!-- ok, got a clear departure path -->
        <request_undocking ship="this.ship" result="$success" />
        <do_while value="$success" exact="0">
          <wait min="1s" max="5s" />
          <request_undocking ship="this.ship" result="$success" />
        </do_while>

        <!-- disconnect from dock -->
        <undock ship="this.ship" />
        <close_dockingbay_doors dock="$olddockslot" />

      </do_if>
      <do_else>
        <debug_text text="'drone is not docked, cannot launch from nowhere!'" chance="$debugoutputchance" />
      </do_else>
    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <label name="start" />
      <do_while value="1">
        <wait exact="10s" />
      </do_while>
    </actions>
  </attention>
</aiscript>

<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="droneability.shieldboost.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="duration" />
    <param name="debugoutputchance" default="0" />
  </params>
  <attention min="visible">
    <actions>
      <set_value name="$returntime" exact="player.age + $duration" />
      <do_if value="this.ship.dockslot != null">
        <run_script name="'droneability.launch.vanilla40'" />
      </do_if>

      <do_if value="this.ship.dronecommander != this.ship.formationleader">
        <!-- If on different formation, leave -->
        <leave_formation object="this.ship" />
        <!-- if commander has no formation, create one, otherwise change the shape -->
        <create_formation object="this.ship.dronecommander" formation="formationshape.invvshape" param="100m" />
        <!-- Join the commanders formation -->
        <join_formation leader="this.ship.dronecommander" object="this.ship" />
        <debug_text text="'join formation with %1'.[this.ship.dronecommander]" chance="$debugoutputchance" />
      </do_if>

      <do_if value="player.age lt $returntime">
        <wait exact="$returntime - player.age" />
      </do_if>

      <leave_formation object="this.ship" />

      <do_if value="this.ship.isoperational">
        <run_script name="'move.dockat.playerdrone.vanilla40'" />
      </do_if>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <!-- cleanup -->
      <destroy_object object="this.ship" explosion="false" />
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="droneability.shieldwall.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="targetpos" />
  </params>
  <attention min="visible">
    <actions>
      <set_value name="$finishtime" exact="60 + player.age" />

      <label name="start" />
      <do_if value="this.ship.dockslot != null">
        <run_script name="'droneability.launch.vanilla40'" />
      </do_if>
      
      <leave_formation object="this.ship" />

      <!-- move to target position -->
      <label name="movetotarget" />
      <move_to object="this.ship" destination="this.ship.zone" flightbehaviour="flightbehaviour.playershielddrone" forcesteering="true">
        <position value="$targetpos" />
        <interrupt_after_time time="10s" />
      </move_to>
      
      <!-- start unfolding animation -->
      <set_object_active object="this.ship" activate="true"/>

      <label name="loop" />

      <!-- Repeat until drone is dead or timeout reached -->
      <wait exact="$finishtime" />

      <!-- start folding animation -->
      <set_object_active object="this.ship" activate="false"/>

      <label name="end" />
      <set_to_default_flight_control_model object="this.ship" />
      <do_if value="this.ship.isoperational">
        <!-- set flight behaviour to the default again -->
        <!--<set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.default" />
        <join_formation object="this.ship" leader="player.primaryship" />-->

        <run_script name="'move.dockat.playerdrone.vanilla40'" />
      </do_if>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <label name="start" />
      <label name="movetotarget" />
      <label name="loop" />
      <label name="end" />

      <!-- Compatibility blocks -->
      <dock_drone homebase="this.ship.dronecommander" object="this.ship" chance="0" />

      <!-- cleanup -->
      <destroy_object object="this.ship" explosion="false" />

      <!-- drone no longer exists if the drone docked successfully -->
      <debug_text text="player.age+' drone docked.'" chance="$debugoutputchance"/>

    </actions>
  </attention>
  <on_abort>
    <set_object_active object="this.ship" activate="false"/>
  </on_abort>
</aiscript><?xml version="1.0" encoding="utf-8" ?>
<aiscript name="engineer.ai.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="9">
  <params>
    <param name="debugoutputchance" default="0"/>
    <param name="debugoutputchance2" default="0"/>
  </params>
  <interrupts>
    <handler comment="Engineer hacked">
      <conditions>
        <event_object_signalled object="this.object" param="'engineer_hacked'" />
      </conditions>
      <actions>
        <debug_text text="'engineer_hacked'" chance="$debugoutputchance" />
        <set_value name="this.$hacked" exact="player.age + event.param2" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.repair" />
    <set_command_action commandaction="commandaction.repairchecking" />
  </init>
  <patch sinceversion="3">
    <set_value name="$baserepairrate" exact="50" />
  </patch>
  <patch sinceversion="8">
    <do_if value="this.defensible.exists">
      <find_active_repair_mass_traffic object="this.defensible" result="$networkid" />
    </do_if>
    <remove_value name="$networkcreated" />
  </patch>
  <patch sinceversion="9">
    <do_if value="this.defensible.isclass.station">
      <set_value name="$hulldamagelimit" exact="100" comment="below what percentage hull is a component considered damaged"/>
    </do_if>
    <do_else>
      <set_value name="$hulldamagelimit" exact="60 + (40 * this.combinedskill / 100)" comment="below what percentage hull is a component considered damaged (ship engineer repairs up to a value between 60% and 100%, dependent on skill)"/>
    </do_else>
  </patch>
  <attention min="unknown">
    <actions>
      <!--###REMOVED######
      Script rewrite in 1.19. Previous blocking actions set to chance="0"
      #######REMOVED######-->
      <wait exact="0s" chance="0"/>
      <wait exact="0s" chance="0"/>
      <wait exact="0s" chance="0"/>
      <wait exact="0s" sinceversion="2" chance="0" />
      <do_if value="$operationalelements?">
        <remove_value name="$operationalelements"/>
      </do_if>

      <!--Patch in value-->
      <do_if value="not $debugoutputchance2?">
        <set_value name="$debugoutputchance2" exact="0"/>
      </do_if>

      <!-- init -->
      <set_value name="$repairfrequency" exact="10s" />
      <set_value name="$nextelementcheck" exact="0" />
      <set_value name="$baserepairrate" exact="50" />
      <set_value name="$CurrentElement" exact="null"/>

      <label name="checkforrepair" />

      <do_if value="this.defensible.isclass.station">
        <set_value name="$hulldamagelimit" exact="100" comment="below what percentage hull is a component considered damaged"/>
      </do_if>
      <do_else>
        <set_value name="$hulldamagelimit" exact="60 + (40 * this.combinedskill / 100)" comment="below what percentage hull is a component considered damaged (ship engineer repairs up to a value between 60% and 100%, dependent on skill)"/>
      </do_else>

      <do_if value="player.age le @this.$hacked">
        <wait exact="@this.$hacked - player.age" sinceversion="4" />
      </do_if>

      <!-- If no elements or main hull to repair -->
      <do_if value="not $CurrentElement.exists and this.defensible.hullpercentage ge $hulldamagelimit">
        <wait min="5min" max="10min" sinceversion="3" />
      </do_if>

      <debug_text text="'Begin wait'" chance="$debugoutputchance2"/>
      <wait min="$repairfrequency" max="$repairfrequency + 1s" sinceversion="2"/>

      <set_value name="$Defensible" exact="this.defensible"/>

      <do_if value="$CurrentElement.exists">
        <do_if value="$CurrentElement.iswreck">
          <!--Do not fix wrecked components where the parent is also a wreck-->
          <do_if value="not $CurrentElement.parent.iswreck">
            <resume label="startrepair"/>
          </do_if>
        </do_if>

        <do_if value="$CurrentElement.hullpercentage lt $hulldamagelimit">
          <!--Have a chance to break out if the component is already functional again-->
          <do_if value="$CurrentElement.isfunctional">
            <resume label="startrepair" chance="70"/>
          </do_if>
          <do_else>
            <resume label="startrepair"/>
          </do_else>
        </do_if>
      </do_if>
      <set_value name="$CurrentElement" exact="null"/>

      <!--Find surface elements and put them in the correct lists/groups-->
      <!--This can be quite expensive so only do it once finished with the $CurrentElement-->
      <do_if value="player.age" min="$nextelementcheck">
        <set_value name="$nextelementcheck" min="player.age + 1min" max="player.age + 2min"/>
        <create_group groupname="$PossibleElements"/>
        <set_value name="$FindChance" exact="100"/>

        <!--If ship, find engines and jumpdrives - High priority-->
        <do_if value="$Defensible.isclass.ship">
          <find_object_component chance="$FindChance" groupname="$PossibleElements" object="$Defensible" class="[class.jumpdrive, class.engine]" checkoperational="false" multiple="true">
            <match_any>
              <match restorable="true" comment="wrecked"/>
              <match repairable="true" invulnerable="false">
                <match_hull min="$hulldamagelimit" negate="true" />
              </match>
            </match_any>
          </find_object_component>
        </do_if>
        <!--find large, non surface element destructibles-->
        <find_object_component chance="$FindChance" groupname="$PossibleElements" object="$Defensible" class="class.destructible" surfaceelement="false" checkoperational="false" multiple="true">
          <match class="[class.adsign, class.ship]" checkoperational="false" negate="true"/>
          <match_macro_children min="1" comment="Does this component have children, use macro so collapsed surface elements also count"/>
          <match_any>
            <match restorable="true" comment="wrecked"/>
            <match repairable="true" invulnerable="false">
              <match_hull min="$hulldamagelimit" negate="true" />
            </match>
          </match_any>
        </find_object_component>
        <debug_text text="$PossibleElements.count + ' priority things to repair found'" chance="$debugoutputchance2"/>
        <do_all exact="$PossibleElements.count" counter="$Counter" chance="$debugoutputchance2">
          <debug_text text="'Priority Destructible: ' + $PossibleElements.{$Counter} + ' ' + $PossibleElements.{$Counter}.macro.id"/>
        </do_all>
        <do_if value="$PossibleElements.count" min="1">
          <!--If something important was found there is only a small chance of finding something small to fix instead-->
          <!--TODO: Could be based on Engineer skill-->
          <set_value name="$FindChance" exact="5"/>
        </do_if>
        <!--A chance to find something small to fix. (100% if nothing important was found)-->
        <find_object_component chance="$FindChance" groupname="$PossibleElements" object="$Defensible" class="class.destructible" checkoperational="false" multiple="true">
          <match class="class.ship" checkoperational="false" negate="true"/>
          <match_any>
            <match restorable="true" comment="wrecked"/>
            <match repairable="true" invulnerable="false">
              <match_hull min="$hulldamagelimit" negate="true" />
            </match>
          </match_any>
        </find_object_component>
        <debug_text text="$PossibleElements.count + ' potential things to repair found'" chance="$debugoutputchance2"/>

        <do_if value="$PossibleElements.count" min="1">
          <set_value name="$MassTrafficTargets" exact="$PossibleElements.list"/>
          <set_value name="$CurrentElement" exact="$PossibleElements.random"/>
          <set_value name="$nextelementcheck" exact="0"/>
          <do_if value="$CurrentElement.iswreck">
            <debug_text text="'CurrentElement is now the wreck of ' + $CurrentElement + ' ' + $CurrentElement.knownname" chance="$debugoutputchance"/>
            <set_value name="$BaseRestoreTime" exact="($CurrentElement.size)s"/>
            <do_if value="$BaseRestoreTime" min="20min">
              <set_value name="$BaseRestoreTime" exact="20min" comment="cap time for large components"/>
            </do_if>
            <do_elseif value="$BaseRestoreTime" max="1min">
              <set_value name="$BaseRestoreTime" exact="1min" comment="cap time for small components"/>
            </do_elseif>
            <debug_text text="'BaseRestoreTime is ' + $BaseRestoreTime" chance="$debugoutputchance"/>
            <set_value name="$RestoreTime" min="player.age + $BaseRestoreTime" max="player.age + $BaseRestoreTime + 1s"/>
          </do_if>
          <do_else>
            <debug_text text="'CurrentElement is now the damaged ' + $CurrentElement + ' ' + $CurrentElement.knownname" chance="$debugoutputchance"/>
          </do_else>
        </do_if>
        <clear_group group="$PossibleElements"/>
      </do_if>

      <!--Check if there is nothing to fix-->
      <do_if value="not $CurrentElement.exists">
        <do_if value="$Defensible.hullpercentage ge $hulldamagelimit">
          <!--Remove mass traffic. Don't care about damaged summaries-->
          <debug_text text="$Defensible.knownname + ' is ending mass traffic (nothing left to repair)'" chance="$debugoutputchance" />
          <end_repair_mass_traffic object="$Defensible" />
          <remove_value name="$networkid" />

          <do_if value="$Defensible.summary.numadsigns.wreck
          + $Defensible.summary.numefficiencyupgrades.wreck
          + $Defensible.summary.numshields.wreck
          + $Defensible.summary.numsurfacedestructible.wreck
          + $Defensible.summary.numturrets.wreck" exact="0">

            <!-- set command action to repair checking -->
            <set_command_action commandaction="commandaction.repairchecking" />

            <resume label="checkforrepair"/>
          </do_if>
        </do_if>
      </do_if>

      <label name="startrepair" />
      <!-- send out the repair drones -->
      <do_if value="not @$networkid">
        <do_if value="not $MassTrafficTargets?">
          <set_value name="$MassTrafficTargets" exact="[$Defensible]" />
        </do_if>
        <launch_repair_drones object="$Defensible" target="$Defensible" components="$MassTrafficTargets" result="$networkid" />
        <debug_text text="$Defensible.knownname + ' launched mass traffic - network id: ' + $networkid" chance="$debugoutputchance" />
        <set_value name="$MassTrafficTargets" exact="[]"/>
      </do_if>

      <!-- calculate repair speed -->
      <set_value name="$repairratefactor" exact="0" />
      <do_if value="@$networkid">
        <find_active_repair_mass_traffic object="$Defensible" result="$networkid" />
        <get_units_in_mass_traffic masstraffic="$networkid" category="unitcategory.welder" amounts="$unitamounts" />

        <do_if value="$unitamounts">
          <do_all exact="unitcategory.welder.maxmk" counter="$i">
            <debug_text text="$unitamounts.{$i} + ' welders mk ' + $i" chance="$debugoutputchance" />
            <set_value name="$repairratefactor" operation="add" exact="$unitamounts.{$i} * $i" />
          </do_all>
          <remove_value name="$unitamounts" />
        </do_if>
      </do_if>
      <do_if value="$repairratefactor == 0">
        <do_if value="@$networkid">
          <debug_text text="$Defensible.knownname + ' is ending mass traffic (no more units are flying)'" chance="$debugoutputchance" />
          <end_repair_mass_traffic object="$Defensible" />
          <remove_value name="$networkid" />
        </do_if>
        <!-- if no welders are underway, repair 10 times more slowly than with just one mk1 drone -->
        <set_value name="$repairratefactor" exact="0.1" />
      </do_if>
      <set_value name="$repairratefactor" operation="add" exact="$repairratefactor * this.combinedskill / 25" comment="engineer speeds up repair by up to 400% (meaning a fifth of the normal repair time)" />

      <set_value name="$repairrate" exact="$baserepairrate * $repairratefactor" />
      <debug_text text="'Repairrate: ' + $repairrate" chance="$debugoutputchance" />

      <!--Fix summary components first-->
      <!--Currently only attempt to fix one. Only fix those which have an operational parent-->
      <!--TODO: Balance-->
      <do_if value="$Defensible.attention lt attention.visible">
        <do_if value="$Defensible.summary.numadsigns.wreck" min="1">
          <set_summarised_adsign_state object="$Defensible" state="operational" parentstate="operational" previous="wreck" exact="1"/>
        </do_if>
        <do_if value="$Defensible.summary.numefficiencyupgrades.wreck" min="1">
          <set_summarised_efficiencyupgrade_state object="$Defensible" state="operational" parentstate="operational" previous="wreck" exact="1"/>
        </do_if>
        <do_if value="$Defensible.summary.numshields.wreck" min="1">
          <set_summarised_shield_state object="$Defensible" state="operational" parentstate="operational" previous="wreck" exact="1"/>
        </do_if>
        <do_if value="$Defensible.summary.numsurfacedestructible.wreck" min="1">
          <set_summarised_surfacedestructible_state object="$Defensible" state="operational" parentstate="operational" previous="wreck" exact="1"/>
        </do_if>
        <do_if value="$Defensible.summary.numturrets.wreck" min="1">
          <set_summarised_turret_state object="$Defensible" state="operational" parentstate="operational" previous="wreck" exact="1"/>
        </do_if>
      </do_if>

      <!--Repair Defensible Hull-->
      <do_if value="not $Defensible.isclass.station and $Defensible.maxhull ge 1">
        <do_if value="$Defensible.hullpercentage lt $hulldamagelimit">
          <set_value name="$addedhullpercentage" exact="100f * $repairrate / $Defensible.maxhull" />
          <!-- handle the case of the percentage being < 0 -->
          <do_if value="$addedhullpercentage lt 1">
            <set_value name="$addedhullpercentage" exact="1"/>
          </do_if>
          <do_if value="$addedhullpercentage" min="1">
            <!-- set the repair command action -->
            <set_command_action commandaction="commandaction.repairingto" param="$Defensible" />
            <!-- repair the hull -->
            <set_object_hull object="$Defensible" exact="$Defensible.hullpercentage + $addedhullpercentage" />
            <debug_text text="'repaired main object ' + $Defensible + ' ' + $Defensible.knownname + ' to hull value ' + $Defensible.hull + ' (' + $Defensible.hullpercentage + '%)'" chance="$debugoutputchance" />
            <do_if value="$Defensible.hullpercentage ge $hulldamagelimit">
              <debug_text text="$Defensible + ' ' + $Defensible.knownname + ' was repaired as much as possible.'" chance="$debugoutputchance"/>
            </do_if>
          </do_if>
        </do_if>
      </do_if>

      <do_if value="$CurrentElement">
        <do_if value="$CurrentElement.iswreck">
          <do_if value="@$RestoreTime" min="1">
            <do_if value="player.age" min="$RestoreTime">
              <!--Restore the $CurrentElement and all of its contained components to 1% hull-->
              <restore_object object="$CurrentElement" hull="1" recursive="true" />
              <set_value name="$RestoreTime" exact="0"/>
              <debug_text text="'Restoring ' + $CurrentElement + ' ' + $CurrentElement.knownname" chance="$debugoutputchance"/>
            </do_if>
          </do_if>
          <do_else>
            <!--Component is wrecked but no restore time is defined. It may have been recently wrecked.-->
            <set_value name="$CurrentElement" exact="null"/>
          </do_else>
        </do_if>
        <do_else>
          <do_if value="$CurrentElement.maxhull" min="1">
            <do_if value="$CurrentElement.hullpercentage ge $hulldamagelimit">
              <!--Component is as repaired as possible-->
              <debug_text text="$CurrentElement + ' ' + $CurrentElement.knownname + ' was repaired as much as possible.'" chance="$debugoutputchance"/>
            </do_if>
            <do_else>
              <!--Repair Damaged Component-->
              <set_value name="$addedhullpercentage" exact="100f * $repairrate / $CurrentElement.maxhull" />
              <!-- handle the case of the percentage being < 0 -->
              <do_if value="$addedhullpercentage lt 1">
                <set_value name="$addedhullpercentage" exact="1"/>
              </do_if>
              <do_if value="$addedhullpercentage" min="1">
                <!-- set the repair command action -->
                <set_command_action commandaction="commandaction.repairingto" param="$CurrentElement" />
                <!-- repair the hull -->
                <set_object_hull object="$CurrentElement" exact="$CurrentElement.hullpercentage + $addedhullpercentage" />
                <debug_text text="player.age + ' repaired ' + $CurrentElement + ' ' + $CurrentElement.knownname + ' to hull value ' + $CurrentElement.hull + ' (' + $CurrentElement.hullpercentage + '%)'" chance="$debugoutputchance" />
                <do_if value="$CurrentElement.hullpercentage ge $hulldamagelimit">
                  <debug_text text="$CurrentElement + ' ' + $CurrentElement.knownname + ' was repaired as much as possible.'" chance="$debugoutputchance"/>
                </do_if>
              </do_if>
            </do_else>
          </do_if>
        </do_else>
      </do_if>

      <resume label="checkforrepair" />
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="engineer.player.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <init>
    <set_command command="command.repair" />
    <!-- initialization -->
    <set_value name="$debugoutputchance" exact="0" />
    <set_value name="$makepriority" exact="false" />
    <debug_text text="'Script initialized'" chance="$debugoutputchance" />
    <set_value name="$nextsoundtime" exact="player.age" />
    <!-- Get any component already needing repair -->
    <create_list name="this.$repairqueue" />
    <!-- This should match the conditions of potentially damaged components in md/DamagePlayerComponents.xml -->
    <create_group groupname="$damageableobjects" />
    <find_object_component groupname="$damageableobjects" object="player.primaryship" functional="true" hullinvulnerable="false" multiple="true">
      <match_parent macro="player.primaryship.macro" />
      <match_any>
        <match class="class.engine" />
        <match class="class.shieldgenerator" />
        <match class="class.weapon" tag="tag.primary_slot" />
      </match_any>
    </find_object_component>
    <set_value name="$maxhullpercent" exact="60 + (40 * this.combinedskill / 100)" comment="between 60% and 100%"/>
    <do_all exact="$damageableobjects.count" counter="$i">
      <debug_text text="$damageableobjects.{$i}.knownname + ' hull percentage ' + $damageableobjects.{$i}.hullpercentage" chance="$debugoutputchance" />
      <do_if value="$damageableobjects.{$i}.hullpercentage lt $maxhullpercent">
        <debug_text text="'adding to list of component to repair'" chance="$debugoutputchance" />
        <append_to_list name="this.$repairqueue" exact="$damageableobjects.{$i}" />
        <set_value name="$repairstarttime" exact="player.age" />
      </do_if>
    </do_all>
    <clear_group group="$damageableobjects" />
  </init>
  <attention min="unknown">
    <actions>
      <label name="start" />
      <!-- calculate values based on engineer skill -->
      <set_value name="$repairpersec" exact="(1.0 + (this.combinedskill / 25.0)) * 0.3" comment="between 1 and 5 times the base repair speed (the factor at the end)" />
      <set_value name="$maxhullpercent" exact="60 + (40 * this.combinedskill / 100)" comment="between 60% and 100%"/>
      <do_if value="this.$repairqueue.count">
        <debug_text text="'repair queue contains %1 entries'.[this.$repairqueue.count]" chance="$debugoutputchance" />
        <debug_text text="'restoring hull of ' + this.$repairqueue.{1}.knownname" chance="$debugoutputchance" />
        <!-- repair the object at the front of the list -->
        <set_value name="$repairedpercent" exact="$repairpersec * (player.age - $repairstarttime)" />
        <set_value name="$damagedhullpercent" exact="this.$repairqueue.{1}.hullpercentage" />
        <set_value name="$repairedhullpercent" exact="$damagedhullpercent + $repairedpercent" />
        <do_if value="$repairedhullpercent gt $maxhullpercent">
          <set_value name="$repairedhullpercent" exact="$maxhullpercent" />
        </do_if>
        <set_object_hull object="this.$repairqueue.{1}" exact="$repairedhullpercent" />
        <debug_text text="'hull value is now ' + this.$repairqueue.{1}.hullpercentage + ' of ' + $maxhullpercent" chance="$debugoutputchance" />
        <do_if value="player.age ge $nextsoundtime and player.room.isclass.cockpit">
          <debug_text text="'playing repair sound'" chance="$debugoutputchance" />
          <play_sound object="this" sound="'cpit_engi_repairs'" />
          <set_value name="$nextsoundtime" min="player.age + 2s" max="player.age + 4s" />
        </do_if>
        <do_if value="$repairedhullpercent == $maxhullpercent">
          <debug_text text="'fully repaired, removing from list and letting computer speak'" chance="$debugoutputchance" />
          <speak actor="player.computer">
            <name value="this.$repairqueue.{1}" />
            <text page="10002" line="94" />
          </speak>
          <!-- finished repairing for now -->
          <remove_value name="this.$repairqueue.{1}" />
        </do_if>
      </do_if>

      <do_if value="$newdamaged?">
        <!-- check if it's already in the list first -->
        <do_all exact="this.$repairqueue.count" counter="$i">
          <do_if value="$newdamaged == this.$repairqueue.{$i}">
            <remove_value name="$newdamaged" />
            <break />
          </do_if>
        </do_all>
        <do_if value="$newdamaged?">
          <do_if value="$makepriority">
            <set_value name="this.$repairqueue.{1}" exact="$newdamaged" operation="insert" />
          </do_if>
          <do_else>
            <append_to_list name="this.$repairqueue" exact="$newdamaged" />
          </do_else>
          <remove_value name="$newdamaged" />
        </do_if>
        <remove_value name="$makepriority" />
      </do_if>

      <do_if value="this.$repairqueue.count">
        <set_value name="$waittime" exact="1s" />
        <set_value name="$repairstarttime" exact="player.age" />

        <!-- set to repaireng component -->
        <set_command_action commandaction="commandaction.repairingto" param="this.$repairqueue.{1}" />
      </do_if>
      <do_else>
        <!-- nothing to repair right now, just wait for a really long time -->
        <set_value name="$waittime" exact="1h" />

        <!-- set to repaireng check -->
        <set_command_action commandaction="commandaction.repairchecking" />

        <debug_text text="'nothing to repair'" chance="$debugoutputchance" />
      </do_else>

      <wait exact="$waittime">
        <interrupt>
          <conditions>
            <event_repair_requested object="this.ship" />
          </conditions>
          <actions>
            <!-- change the object to be repaired -->
            <set_value name="$newdamaged" exact="event.param" />
            <set_value name="$makepriority" exact="event.param2" />
            <debug_text text="'repair requested %1(%2)'.[$newdamaged.knownname, $makepriority]" chance="$debugoutputchance" />
            <do_if value="this.$repairqueue.count == 0">
              <set_value name="$repairstarttime" exact="player.age" />
            </do_if>
          </actions>
        </interrupt>
      </wait>
      <resume label="start" />
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="fight.attack.object.capital.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="5">
  <!--

  Capital ship (defense officer NPC) vs Object (any class)
  by Adrian
  
  Attack of a capital ship (made by defense noc), to enemys in weapon range
  Set turrets and launch drones 
  Not movement: see 'move.attack.object.capital'
  
  Optional target (object) as a parameter.
  Optional endwheninactive, to finish when there are no enemies.

  -->
  <params>
    <param name="target" default="null"/>
    <param name="allowothertargets" default="true" comment="Whether the script shall keep running when primary target have been destroyed (ignore if not target provided)" />
    <param name="checkrelation" default="true" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler>
      <conditions>
        <event_object_attacked object="this.ship"/>
        <check_value value="event.param.isclass.defensible or event.param.defensible.exists"/>
        <check_value value="this.ship.mayattack.{event.param}" />
        <check_value value="not $attackers.indexof.{event.param} and not $enemies.indexof.{event.param}" />
      </conditions>
      <actions>
        <!--Get the top-level defensible of the attacker in low attention case-->
        <set_value name="$attacker" exact="if event.param.isclass.defensible then event.param else event.param.defensible"/>
        <add_to_group groupname="$attackers" object="$attacker"/>
        <debug_text text="' %1 attention. add attacker %2 (%3) to $attackers (%4) | enemies %5.'.[this.ship.attention, $attacker.knownname, $attacker, $attackers.count, $enemies.count]" chance="$debugoutputchance" />
        <!-- Only break the current blocking high attention -->
        <do_if value="this.ship.attention ge attention.visible">
          <abort_called_scripts resume="FindEnemies" />
        </do_if>
      </actions>
    </handler>
  </interrupts>
  <init>
    <!-- Command on defense officer-->
    <set_command command="command.attackenemies" />
    <!-- initial variables -->
    <set_value name="$lastdronelaunch" exact="player.age - 500s" />
    <set_value name="$nextammocheck" exact="player.age + 100s" />
    <set_value name="$nextenemycheck" exact="player.age"/>
    <set_value name="$FiringRange" exact="this.ship.maxcombatrange.all"/>
    <create_group groupname="$attackers"/>
    <create_list name="$enemies" />
  </init>
  <patch sinceversion="2" early="true">
    <set_value name="$checkrelation" exact="true" />
    <set_value name="$waittime" min="500ms" max="10s" profile="decreasing" />
  </patch>
  <patch sinceversion="3">
    <set_value name="$MaxEnemies" exact="0"/>
  </patch>
  <patch sinceversion="4">
    <create_group groupname="$attackers"/>
  </patch>
  <patch sinceversion="5" early="true">
    <set_value name="$nextenemycheck" min="player.age + 10s" max="player.age + 20s"/>    
    <set_value name="$FiringRange" exact="this.ship.maxcombatrange.all"/>
    <!-- set enemies if the variable does not exist yet -->
    <do_if value="not $enemies?">
      <create_list name="$enemies" />
    </do_if>    
  </patch>
  <attention min="visible">
    <actions>

      <debug_text text="'Firing range for: ' + this.ship.knownname + ' is: ' + $FiringRange" chance="$debugoutputchance"/>

      <label name="FindEnemies" />

      <!-- Only update enemies with some delay -->
      <do_if value="player.age ge $nextenemycheck">
        <!--TODO: Based on skill?-->
        <set_value name="$nextenemycheck" min="player.age + 10s" max="player.age + 20s"/>

        <!-- Create/clean list of enemies -->
        <create_list name="$enemies" />

        <!-- Find (more) enemies if no target or other targets are allowed -->
        <do_if value="not $target or @$allowothertargets">
          <find_gravidar_contact name="$enemies" object="this.ship" functional="true" maybeattackedby="this.ship" multiple="true">
            <match_distance object="this.ship" max="$FiringRange"/>
          </find_gravidar_contact>
        </do_if>

        <!-- Main target (parameter) -->
        <do_if value="$target.isoperational">
          <do_if value="(this.ship.mayattack.{$target} or not $checkrelation) and not @$target.dockslot" comment="check relation of ship (not defense NPC)" >
            <debug_text text="'Prefered target of: ' + this.ship.knownname + ' is: ' + $target.knownname" chance="$debugoutputchance"/>
            <!--check if target is already in list of enemies-->
            <do_if value="not $enemies.indexof.{$target}">
              <append_to_list name="$enemies" exact="$target" />
            </do_if>
          </do_if>
          <do_else>
            <!-- Target is not an enemy anymore -->
            <set_value name="$target" exact="null" />
          </do_else>
        </do_if>

        <create_group groupname="$targets" />
        <create_group groupname="$dronetargets" />
      </do_if>

      <!-- include attackers -->
      <do_all exact="$attackers.count" counter="$i">
        <do_if value="not $enemies.indexof.{$attackers.{$i}} and this.ship.mayattack.{$attackers.{$i}}">
          <append_to_list name="$enemies" exact="$attackers.{$i}" />
        </do_if>
      </do_all>
      <clear_group group="$attackers"/>

      <!-- ok, we have found enemies, let's do something about them -->
      <do_if value="$enemies.count" min="1">

        <!-- Simulate the attack -->
        <set_command_action commandaction="commandaction.attacking" />

        <activate_battlestate object="this.ship" state="battlestate_red" />

        <do_all counter="$i" exact="$enemies.count">
          <do_if value="$enemies.{$i}.isoperational">
            <!--This section can be unperformant-->
            <do_if value="$enemies.{$i}.isclass.station">
              <find_object_component object="$enemies.{$i}" multiple="true" functional="true" groupname="$targets">
                <match_size min="100m"/>
              </find_object_component>
              <do_if value="$targets.count" exact="0">
                <!--No subtargets found, just attack the main object-->
                <add_to_group groupname="$targets" object="$enemies.{$i}"/>
              </do_if>
            </do_if>
            <do_else>
              <add_to_group groupname="$targets" object="$enemies.{$i}" />
              <do_if value="$enemies.{$i}.isclass.[class.ship_xs, class.ship_s, class.ship_m]">
                <add_to_group groupname="$dronetargets" object="$enemies.{$i}" />
              </do_if>
            </do_else>
          </do_if>
        </do_all>

        <do_all exact="$targets.count" counter="$Count" chance="$debugoutputchance">
          <debug_text text="'target for: ' + this.ship.knownname + ' is: ' + $targets.{$Count}.knownname + ' of class: ' + $targets.{$Count}.class + ' size: ' + $targets.{$Count}.size"/>
        </do_all>

        <do_if value="$target.isoperational">
          <set_turret_targets object="this.ship" target="$targets.list" preferredtarget="$target"/>
          <!-- If has, set primary and secondary weapons -->
          <shoot_at object="this.ship" target="$target" slot="tag.primary_slot" tolerance="10.0deg" locktarget="true" weapontype="combat" />
          <shoot_at object="this.ship" target="$target" slot="tag.secondary_slot" tolerance="360.0deg" locktarget="true" weapontype="combat" />
        </do_if>
        <do_else>
          <set_turret_targets object="this.ship" target="$targets.list"/>
        </do_else>

        <!-- Launch drones (every 60s) -->
        <!-- Improve with NPC skills and not only defense drones -->
        <do_if value="$dronetargets.count">
          <do_if value="player.age" min="$lastdronelaunch + 60s">
            <set_value name="$lastdronelaunch" exact="player.age"/>
            <launch_drone name="$drone" object="this.ship" exact="5" group="unitcategory.defence"/>
            <do_if value="$drone">
              <start_script object="$drone.pilot" name="'fight.attack.object.drone.leader'">
                <param name="target" value="$dronetargets.random" />
                <param name="additionaltargets" value="$dronetargets" />
                <param name="checkrelation" value="$checkrelation" />
              </start_script>
            </do_if>
          </do_if>
        </do_if>

        <wait min="10s" max="20s" chance="0" />
      </do_if>
      <do_else>
        <cease_fire object="this.ship" weapontype="combat"/>

        <!-- Simulate the stand by -->
        <set_command_action commandaction="commandaction.standingby" />

      </do_else>

      <!-- wait until the next enemy check (this can be interrupted if new attacker attack) -->
      <wait exact="$nextenemycheck - player.age" />

      <!-- Continue if the Config is Attack, or if there is still a PROVIDED target -->
      <do_if value="@this.$config_attackenemies or $target.isoperational">
        <resume label="FindEnemies"/>
      </do_if>

      <cease_fire object="this.ship" weapontype="combat"/>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <debug_text text="'Firing range for: ' + this.ship.knownname + ' is: ' + $FiringRange" chance="$debugoutputchance"/>

      <label name="FindEnemies" />

      <!-- ammo check -->
      <do_if value="player.age gt @$nextammocheck">
        <set_value name="$ammodelay" min="8min" max="12min" />
        <set_value name="$nextammocheck" exact="player.age + $ammodelay" />

        <run_script name="'lib.ammo.missiles.vanilla40'" result="$needammo" sinceversion="1">
          <save_retval name="macros" variable="$order_macrolist" />
          <save_retval name="amounts" variable="$order_amountlist" />
        </run_script>

        <do_if value="$needammo">
          <do_all exact="$order_macrolist.count" counter="$i">
            <add_ammo object="this.ship" macro="$order_macrolist.{$i}" amount="$order_amountlist.{$i}" />
          </do_all>
        </do_if>

        <remove_value name="$order_macrolist" />
        <remove_value name="$order_amountlist" />
      </do_if>

      <!-- Create/clean list of enemies -->
      <create_list name="$enemies" />

      <!-- Find (more) enemies if no target or other targets are allowed -->
      <do_if value="not $target or @$allowothertargets">
        <find_gravidar_contact name="$enemies" object="this.ship" functional="true" maybeattackedby="this.ship" multiple="true">
          <match_distance object="this.ship" max="$FiringRange"/>
        </find_gravidar_contact>
      </do_if>

      <do_all exact="$attackers.count" counter="$i">
        <do_if value="not $enemies.indexof.{$attackers.{$i}} and this.ship.mayattack.{$attackers.{$i}}">
          <append_to_list name="$enemies" exact="$attackers.{$i}" />
        </do_if>
      </do_all>
      <clear_group group="$attackers"/>

      <do_if value="$target.isoperational">
        <!--check if target is already in list of enemies-->
        <do_if value="not $enemies.indexof.{$target}">
          <do_if value="this.ship.mayattack.{$target} or not $checkrelation" comment="check relation of ship (not defense NPC)" >
            <debug_text text="'Prefered target of: ' + this.ship.knownname + ' is: ' + $target.knownname" chance="$debugoutputchance"/>
            <append_to_list name="$enemies" exact="$target" />
          </do_if>
        </do_if>
      </do_if>

      <!-- ok, we have found enemies, let's do something about them -->
      <set_value name="$attacktime" min="player.age + 30s" max="player.age + 40s" />
      <!-- Fight -->
      <do_if value="$enemies.count" min="1">
        <!-- Simulate the attack -->
        <set_command_action commandaction="commandaction.attacking" />

        <activate_battlestate object="this.ship" state="battlestate_red" />
      </do_if>
      <do_else>
        <!-- Simulate the stand by -->
        <set_command_action commandaction="commandaction.standingby" />
      </do_else>

      <set_value name="$waittime" exact="1s" />
      <!-- For each enemy, apply strength-->
      <do_while value="$enemies.count" min="1">
        <debug_text text=" ' unknown. ' + this.ship + ' fight. enemies: ' + $enemies " chance="$debugoutputchance" />

        <do_all exact="$enemies.count" counter="$i" reverse="true">
          <do_if value="not @$MaxEnemies">
            <!-- Search/Attacking waiting time -->
            <set_value name="$waittime" min="1s" max="4s" profile="increasing" />
            <wait exact="$waittime"/>

            <!--The maximum amount of enemies to be hit in this volley, based on the number of operational turrets-->
            <set_value name="$MaxEnemies" exact="[this.ship.summary.numturrets.operational / 5, 3, $enemies.count].min"/>
            <set_value name="$MaxEnemies" min="1" max="$MaxEnemies" profile="increasing"/>
          </do_if>

          <do_if value="@$enemies.{$i}.isoperational">
            <set_value name="$target" exact="$enemies.{$i}" />
            <!-- exclude the player ship in OOS case, this scenario wouldn't make any sense anyway -->
            <do_if value="$target != player.primaryship">
              <!-- Get and apply strengths-->
              <do_if value="$target.isoperational" chance="[this.combinedskill, 90].max" comment="chance of succeed">
                <!-- do not attack objects that are too far away, gravidar range can be 50km+ !! -->
                <do_if value="this.ship.distanceto.{$target} lt ($FiringRange + $target.size/2.0)">
                  <!-- Get the strength in 'result'-->
                  <get_attackstrength object="this.ship" target="$target" usedrones="$target.isclass.[class.ship_xs, class.ship_s, class.ship_m]" result="$result" />
                  <!-- Apply the strength to target -->
                  <apply_attackstrength object="$target" attacker="this.ship" strength="$result * ($waittime)f" result="$isdead" />
                  <debug_text text="'%1 OOS. Apply strength of %2 against %3 is: %4(%5|%6). Is killed: %7'.[player.age,this.ship.knownname,$target.knownname,$result * ($waittime)f,$target.hull,$target.shield,$isdead]" chance="$debugoutputchance" />
                  <!--Wait so that attack/killed events are processed-->
                  <wait exact="1ms" sinceversion="3"/>
                </do_if>
                <do_else>
                  <debug_text text="'%1 OOS. Apply out of range of %2 against %3. Distance %4, fire range %5'.[player.age,this.ship.knownname,$target.knownname,this.ship.distanceto.{$target},$FiringRange]" chance="$debugoutputchance" />
                </do_else>
              </do_if>
              <do_else>
                <debug_text text="'%1 OOS. Apply attack fail of %2 against %3'.[player.age,this.ship.knownname,$target.knownname]" chance="$debugoutputchance" />
              </do_else>
            </do_if>
          </do_if>
          <do_else>
            <remove_value name="$enemies.{$i}" />
          </do_else>

          <do_if value="$MaxEnemies gt 0">
            <set_value name="$MaxEnemies" operation="subtract"/>
          </do_if>
        </do_all>
        <!-- Avoid an infite loop-->
        <do_if value="player.age" min="$attacktime">
          <break/>
        </do_if>
      </do_while>

      <!-- Continue if the Config is Attack  or if there is still a target -->
      <do_if value="@this.$config_attackenemies or $target.isoperational">
        <wait min="5s" max="10s" />
        <resume label="FindEnemies"/>
      </do_if>

      <cease_fire object="this.ship" weapontype="combat"/>

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="fight.attack.object.drone.follower.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="2">
  <!--

  Drone follower vs Small ships
  
  Attack of a drone esortting a drone leader (commander).  
    
  Follower drone run:
	1 - Set weapons against leader's target
	2 - Fly in formation with leader
	3 - Promote to leader if leader is destroyed

	Will break the follow behavior if:
	- commander not operational (if cannot promote to leader)

  -->
  <params>
    <param name="leaderscript" default="'fight.attack.object.drone.leader.vanilla40'" comment="The script that will be run on this entity if it is promoted to squad commander" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="AttackHandler.vanilla40"/>
    <handler ref="TargetInvalidHandler.vanilla40" />
  </interrupts>
  <init>
    <set_command command="command.escort" param="this.ship.commander" />
  </init>
  <attention min="visible">
    <actions>

      <label name="start" />
      <join_formation object="this.ship" leader="this.ship.commander" />
      <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.default" />

      <do_while value="this.ship.commander.isoperational and this.ship.commander.isclass.drone">
        <!-- query leader blackboard for orders -->
        <set_value name="$target" exact="@this.ship.commander.pilot.$subordinatetarget" />
        <do_if value="$target.isoperational">
          <do_if value="not this.ship.isplayerowned">
            <set_relation_boost object="this.ship" faction="$target.owner" value="this.ship.commander.relationto.{$target}" silent="true" />
          </do_if>
          <!-- subordinateextratargets on blackboard is a group, additional_targets needs a list -->
          <shoot_at object="this.ship" target="$target" locktarget="true" slot="tag.primary_slot" tolerance="10.0deg" />
          <shoot_at object="this.ship" target="$target" locktarget="true" slot="tag.secondary_slot" tolerance="10.0deg" />
        </do_if>
        <do_else>
          <debug_text text="'stop shooting!'" chance="$debugoutputchance" />
          <cease_fire object="this.ship" />
        </do_else>

        <wait min="2s" max="5s" >
          <interrupt>
            <conditions>
              <event_object_destroyed object="this.ship.commander" />
            </conditions>
            <actions>
              <set_value name="$timeout" exact="player.age + 2min" />
              <resume label="lostleader"/>
            </actions>
          </interrupt>
        </wait>
      </do_while>

      <!-- we have lost our leader, wait until timeout for a new one -->
      <set_value name="$timeout" exact="player.age + 2min" />

      <label name="lostleader" />
      <cease_fire object="this.ship" />
      <leave_formation object="this.ship"/>
      <debug_text text="'Commander has gone bye-bye!'" chance="$debugoutputchance" />

      <move_to object="this.ship" destination="this.ship.zone" abortpath="true">
        <position min="1km" max="20km" />
        <interrupt_after_time time="1s" />
      </move_to>

      <do_while value="not this.ship.commander.isoperational">
        <do_if value="player.age" min="$timeout">
          <resume label="selfdestruct" />
        </do_if>

        <wait min="1s" max="4s">
          <interrupt>
            <conditions>
              <check_any>
                <event_object_approaching_waypoint object="this.ship" lastwaypoint="true" />
                <event_object_arrived_at_waypoint object="this.ship" lastwaypoint="true" />
              </check_any>
            </conditions>
            <actions>
              <resume label="lostleader" />
            </actions>
          </interrupt>
        </wait>
      </do_while>

      <!-- new commander detected, check if it's another drone or if we should take the lead -->
      <label name="newleader" />
      <do_if value="not this.ship.commander.isclass.drone">
        <debug_text text="'Self-promoting to new swarm commander. Starting script ' + $leaderscript" chance="$debugoutputchance" />
        <do_if value="$leaderscript" exact="'fight.attack.object.drone.leader.vanilla40'">
          <run_script name="$leaderscript">
            <param name="target" value="@$target"/>
            <param name="islaunched" value="true"/>
          </run_script>
        </do_if>
        <do_else>
          <run_script name="$leaderscript" sinceversion="2"/>
        </do_else>
        <return />
      </do_if>
      <do_elseif value="not this.ship.commander.isclass.ship">
        <!-- TEMP / TODO handle case where command is a station for example -->
        <resume label="selfdestruct" />
      </do_elseif>
      <do_else>
        <debug_text text="'There is a new commander, following that guy...'" chance="$debugoutputchance" />
        <resume label="start" />
      </do_else>

      <!-- timeout reached, we still don't have a commander, just take the easy way out -->
      <label name="selfdestruct" />
      <debug_text text="'Drone without commander reached timeout, self-destructing...'" chance="$debugoutputchance" />
      <destroy_object object="this.ship" explosion="true" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <label name="start" />
      <label name="lostleader" />
      <label name="newleader" />
      <label name="selfdestruct" />

      <!-- cleanup -->
      <do_if value="this.ship.commander.isoperational">
        <run_script name="'move.dockat.drone.vanilla40'" sinceversion="1">
          <param name="destination" value="this.ship.commander" />
        </run_script>
        <assert value="false" text="'\'move.dockat.drone\' returned to unknown-block of \'fight.attack.object.drone.follower\' for drone %1 [%2] [ Michael ]'.[this.ship.knownname, this.ship]" />
      </do_if>
      <do_else>
        <destroy_object object="this.ship" explosion="false" />
      </do_else>

      <!-- drone no longer exists if the drone docked successfully -->
      <debug_text text="player.age+' drone docked.'" chance="$debugoutputchance"/>

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="fight.attack.object.drone.leader.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <!--

  Drone leader vs Small ships
  
  Attack of a drone against non-big object (drone, xs, s, m).
  Select main target, and continue if additional targets provided
    
  Leader attack run:
	2 - Fly with a selected behavior (NPC skill)
	3 - Gain distance (after time)
		3.1 - Evade under attack (NPC skill)
	4 - Go to 1

	Will break the attack (and dock at home) when:
	- target destroyed/docked/not enemy
	- commander not operational
	- 'range' away from commander
	- commander not enemy of target

  -->
  <params>
    <param name="target" default="null" comment="The object to fight with" />
    <param name="additionaltargets" default="null" />
    <param name="islaunched" default="false"/>
    <param name="RequiresCommander" default="true"/>
    <param name="DestroyWhenOrphaned" default="true"/>
    <param name="checkrelation" default="true" />
    <param name="range" default="10km" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler>
      <conditions>
        <event_object_changed_owner object="$target" check="false" />
      </conditions>
      <actions>
        <!-- Remove the target to stop shotting at it, when owner changes -->
        <do_if value="$additionaltargets">
          <remove_from_group group="$additionaltargets" object="$target" />
        </do_if>
        <set_value name="$target" exact="null" />
        <abort_called_scripts/>
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.attackenemies" />
  </init>
  <patch sinceversion="2">
    <set_value name="$checkrelation" exact="true" />
  </patch>
  <patch sinceversion="3">
    <set_value name="$range" exact="10km" />
  </patch>
  <attention min="visible">
    <actions>

      <!-- post current order to blackboard so follower can attack the same target -->
      <set_value name="this.$subordinatescript" exact="'fight.attack.object.drone.follower'" />
      <set_value name="this.$subordinatetarget" exact="$target" />

      <create_formation object="this.ship" formation="formationshape.invpointguard" param="100m"/>

      <!-- Initialize evasive maneuver variables -->
      <set_value name="$lastevadetime" exact="0" />
      <set_value name="$lastboosttime" exact="0" />
      <set_value name="$safetydistance" min="this.ship.size * 4m" max="this.ship.size * 6m" />
      <set_value name="$doevade" exact="false" />

      <do_if value="$target.isoperational and not this.ship.isplayerowned">
        <do_if value="this.ship.commander.isoperational">
          <set_relation_boost object="this.ship" faction="$target.owner" value="this.ship.commander.relationto.{$target}" silent="true" />
        </do_if>
      </do_if>

      <!-- wait until we're done launching -->
      <do_if value="not $islaunched">
        <wait>
          <interrupt>
            <conditions>
              <check_any>
                <!-- <event_object_approaching_waypoint object="this.ship" lastwaypoint="true" /> -->
                <event_object_arrived_at_waypoint object="this.ship" lastwaypoint="true" />
              </check_any>
            </conditions>
          </interrupt>
        </wait>
        <set_value name="$islaunched" exact="true"/>
      </do_if>

      <clear_collision_filter object="this.ship" />
      <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.default" />

      <do_if value="$target.isoperational" chance="$debugoutputchance">
        <debug_text text="this.ship.knownname + ': attacking '+ $target.knownname +'!'" />
      </do_if>

      <!-- Set up primary weapons to fire on target -->
      <label name="fireandmaneuver" />

      <!-- Repeat until target is dead -->
      <do_while value="$target.isoperational">

        <do_if value="$RequiresCommander">
          <do_if value="not this.ship.commander.isoperational">
            <!-- if we don't have a homebase any longer we have to deal with that -->
            <resume label="gohome" />
          </do_if>
          <do_if value="this.ship.distanceto.{this.ship.commander} ge $range">
            <!-- if we stray too far from our homebase, return there -->
            <resume label="gohome" />
          </do_if>
          <do_if value="not this.ship.commander.mayattack.{$target} and $checkrelation and not this.ship.isplayerowned">
            <!-- abort if the target no longer is an enemy to kill-->
            <set_relation_boost object="this.ship" faction="$target.owner" value="this.ship.commander.relationto.{$target}" silent="true" />
            <break />
          </do_if>
        </do_if>

        <do_if value="@$target.dockslot or $target.zone.isclass.highway">
          <!-- abort if the target is docked, or in a highway -->
          <do_if value="$additionaltargets">
            <remove_from_group group="$additionaltargets" object="$target" />
          </do_if>
          <set_value name="$target" exact="null" />
          <break />
        </do_if>

        <set_value name="this.$subordinatetarget" exact="$target" />
        <shoot_at object="this.ship" target="$target" additional_targets="@$additionaltargets.list" slot="tag.primary_slot" tolerance="15.0deg" locktarget="true" />
        <shoot_at object="this.ship" target="$target" locktarget="true" slot="tag.secondary_slot" tolerance="10.0deg" />

        <do_if value="not $doevade">
          <select_flight_behaviour entity="this" evasive="false" result="$Behaviour" comment="selected based on drone behaviour definitions" />
          <debug_text text="'%1: attacking! with %2 behavior'.[this.ship.knownname, $Behaviour]" chance="$debugoutputchance" />
          <move_to object="this.ship" destination="$target" flightbehaviour="$Behaviour" forcesteering="true" >
            <interrupt_after_time time="40s" comment="some flight behaviors do not finish" />
            <interrupt>
              <conditions>
                <check_any>
                  <event_object_destroyed object="$target" />
                  <event_object_changed_zone object="$target" />
                  <event_object_launched_missile object="this.ship" />
                </check_any>
              </conditions>
            </interrupt>
          </move_to>

          <!-- try to gain distance for a new attack run -->
          <debug_text text="'gain distance'" chance="$debugoutputchance" />

          <!-- If operational, not in a HW and not docked -->
          <do_if value="$target.isoperational and not $target.zone.isclass.highway and not @$target.dockslot">
            <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.gaindistance" forcesteering="true" >
              <interrupt_after_time time="30s" />
              <interrupt>
                <conditions>
                  <event_object_attacked object="this.ship" />
                </conditions>
                <actions>
                  <set_value name="$doevade" exact="true" />
                </actions>
              </interrupt>
            </move_to>
          </do_if>

        </do_if>
        <do_else>
          <set_value name="$lastevadetime" exact="player.age" />

          <is_in_quadrant object="this.ship" target="$target" result="$behind" back="true" />
          <do_if value="$behind" >
            <set_value name="$switchchance" min="50" max="90"/>
          </do_if>
          <do_else>
            <set_value name="$switchchance" exact="20" />
          </do_else>

          <do_any>
            <do_all weight="60">
              <set_value name="$maxevadedelay" exact="player.age + 10s" />
              <wait chance="0" comment="script compatibility" />
              <!-- try different moves -->
              <do_while value="$doevade and player.age le $maxevadedelay">
                <set_value name="$doevade" exact="false" />
                <set_value name="$minevadedelay" exact="player.age + 3s" />

                <select_flight_behaviour entity="this" evasive="true" result="$fb" />
                <debug_text text="this.knownname + ': EVADE using '+ $fb + ' behaviour!.' + 'time: ' + player.age" chance="$debugoutputchance" />

                <move_to object="this.ship" destination="this.ship.zone" flightbehaviour="$fb" forcesteering="true">
                  <position object="this.ship" min="500m" max="1km"/>
                  <interrupt_after_time time="10s"/>
                  <interrupt>
                    <conditions>
                      <check_all>
                        <event_object_attacked object="this.ship" />
                        <check_age min="$minevadedelay"/>
                      </check_all>
                    </conditions>
                    <actions>
                      <set_value name="$doevade" exact="true" />
                    </actions>
                  </interrupt>
                </move_to>

              </do_while>
              <remove_value name="$maxevadedelay" />
            </do_all>
            <do_all weight="$switchchance">
              <set_value name="$doevade" exact="false" />
              <debug_text text="this.knownname + ': TRY LOOP->CHASE combo'" chance="$debugoutputchance" />
              <move_to object="this.ship" destination="this.ship.zone" flightbehaviour="flightbehaviour.halfloop" forcesteering="true" >
                <interrupt_after_time time="12s" />
              </move_to>
              <set_value name="$lastview" exact="player.age" />
              <set_value name="$diff" min="8s" max="18s" />
              <do_while value="$lastview" min="player.age - $diff">
                <do_if value="$doevade" exact="true">
                  <break />
                </do_if>
                <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.chase" forcesteering="true" >
                  <interrupt>
                    <conditions>
                      <event_object_attacked object="this.ship" />
                    </conditions>
                    <actions>
                      <set_value name="$doevade" exact="true" />
                    </actions>
                  </interrupt>
                  <interrupt_after_time time="8s" />
                </move_to>
                <do_if value="not $target.isoperational">
                  <break />
                </do_if>
                <is_in_quadrant object="this.ship" target="$target" result="$infront" front="true" />
                <do_if value="$infront" exact="1">
                  <debug_text text="this.knownname + ': last saw ' + $target.knownname + ' at ' + player.age" chance="$debugoutputchance" />
                  <set_value name="$lastview" exact="player.age" />
                </do_if>
              </do_while>
            </do_all>
          </do_any>
        </do_else>

      </do_while>

      <!--
      a) select new target from $additionaltargets group
      b) post target-request to blackboard of commander (if it still exists)
      c) just go home (if it still exists)
      -->

      <!-- Select new target -->
      <do_if value="@$additionaltargets.count" min="1">
        <set_value name="$target" exact="$additionaltargets.random" />
        <remove_from_group group="$additionaltargets" object="$target" />
        <resume label="fireandmaneuver" />
      </do_if>

      <!-- go home -->
      <label name="gohome" />
      <do_if value="$target">
        <debug_text text="'Target \''+ $target.knownname +'\' is no longer operational! ' + $target.isoperational" chance="$debugoutputchance" />
      </do_if>
      <do_else>
        <debug_text text="'There is no target'" chance="$debugoutputchance" />
      </do_else>
      <cease_fire object="this.ship" />
      <remove_value name="this.$subordinatetarget" />

      <run_script name="'move.dockat.drone.vanilla40'">
        <param name="destination" value="this.ship.commander" />
      </run_script>
      <assert value="false" text="'\'move.dockat.drone\' returned to visible-block of \'fight.attack.object.drone.leader\' for drone %1 [%2] [ Michael ]'.[this.ship.knownname, this.ship]" />

      <!-- we are only down here if docking didn't work, most likely because the homebase is dead, we just wait until the low-attention case cleans up -->

      <stop_moving object="this.ship" />
      <wait sinceversion="1" max="5s" />

      <resume label="gohome"/>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <label name="fireandmaneuver" />
      <label name="gohome" />

      <!-- cleanup -->
      <do_if value="this.ship.commander.isoperational">
        <run_script name="'move.dockat.drone.vanilla40'" sinceversion="1">
          <param name="destination" value="this.ship.commander" />
        </run_script>
        <assert value="false" text="'\'move.dockat.drone\' returned to unknown-block of \'fight.attack.object.drone.leader\' for drone %1 [%2] [ Michael ]'.[this.ship.knownname, this.ship]" />
      </do_if>
      <do_else>
        <destroy_object object="this.ship" explosion="false" />
      </do_else>

      <!-- drone no longer exists if the drone docked successfully -->
      <debug_text text="player.age+' drone docked.'" chance="$debugoutputchance"/>

    </actions>
  </attention>
</aiscript><aiscript name="fight.attack.object.fighter.bigtarget.vanilla40" version="2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

  Fighter vs Capital/Station 
  
  Attack of a small ship (xs, s, m) against big object (l, xl, station).  
  The target can be a component or big object.
    
  Attack run:	
	1 - Select component (shields, turrets, ...)
	1 - Weapons in large shoot controller (shoot the entire object)
	2 - Fly with the big fight behaviour
	3 - Gain distance (after time)
		3.1 - Evade under attack (NPC skill)
	4 - Go to 1

	Will break the attack when:
	- target destroyed/docked/not enemy
	- far away from escort (if escort)
	- far away from this (if not pursuetargets)	

  -->
  <params>
    <param name="target" comment="Big target to attack. Must be station (or component) or capital ship (ship_l, ship_xl or component)" />
    <param name="escort" default="null" comment="Objects to escort - stay at 'pursuedistance' and shoot enemies attacking this" />
    <param name="pursuedistance" default="this.ship.maxradarrange" comment="Distance to pursue/escort (if pursuetargets true or 'escort' provided). Default: max radar range" />
    <param name="pursuetargets" default="false" comment="Pursue the target no matter what. Default: false" />
    <param name="allowothertargets" default="true" comment="Whether the script shall keep running when all primary targets have been destroyed. Default: true" />
    <param name="checkrelation" default="true"/>
    <param name="debugoutputchance" default="0"/>
  </params>
  <patch sinceversion="2">
    <set_value name="$checkrelation" exact="true" />
  </patch>
  <attention min="visible">
    <actions>

      <label name="start" />

      <!-- ATTENTION. no target selecting in this script, must be done previously (fight.attack.object.fighter) -->
      <do_if value="not $target.isoperational">
        <debug_text text="'target not operational'" chance="$debugoutputchance" />
        <resume label="finish" />
      </do_if>

      <!-- Checking for big targets -->
      <set_value name="$bigtarget" exact="null" />
      <set_value name="$component" exact="null" />
      <set_value name="$iscapship" exact="null" />

      <!-- check for components in station/capital ship  -->
      <do_if value="$target.container.exists">
        <set_value name="$component" exact="$target" />
        <set_value name="$bigtarget" exact="$target.container" />
        <set_value name="$iscapship" exact="$bigtarget.isclass.ship_l or $bigtarget.isclass.ship_xl" />

        <!-- Is not a component of station/capital ship-->
        <do_if value="not $bigtarget.isclass.station and not $iscapship">
          <debug_text text="'target is a component, but not from station or capital ship.-> Adrian'"/>
          <resume label="finish" />
        </do_if>
      </do_if>
      <do_else>
        <!-- For stations, l,xl ships and Stations -->
        <set_value name="$iscapship" exact="$target.isclass.ship_l or $target.isclass.ship_xl" />
        <set_value name="$bigtarget" exact="$target" />

        <!-- Is not a station nor capital ship-->
        <do_if value="not $target.isclass.station and not $iscapship">
          <debug_text text="'target is not a component, station or capital ship.-> Adrian'"/>
          <resume label="finish" />
        </do_if>
      </do_else>

      <label name="fighttarget" />
      <set_value name="$continuefight" exact="true" />
      <!-- Find/Attack component or surface of a big target -->
      <do_while value="$bigtarget.isoperational and $continuefight">
        <set_value name="$continuefight" exact="$allowothertargets" />
        <!-- Is a component (clear once is destroyed) -->
        <do_if value="not @$component.isoperational">
          <find_object_component name="$component" object="$bigtarget" class="[class.shieldgenerator, class.jumpdrive, class.weapon, class.engine]" functional="true" surfaceelement="true" />
          <do_if value="not $component">
            <!-- No components. find anything and move to it -->
            <debug_text text="'no component found. Find anything else'" chance="$debugoutputchance" />
            <find_object_component name="$component" object="$bigtarget" class="class.destructible" functional="true" indestructible="false" />
            <!-- Safety check -->
            <do_if value="not $component">
              <debug_text text="'no component found.'" chance="$debugoutputchance" />
              <set_value name="$component" exact="$bigtarget" />
            </do_if>
          </do_if>
        </do_if>

        <!-- Set the shoot target, depending on a component of a station or a entire capship -->
        <do_if value="$iscapship">
          <!-- Tolerances deppending on: l,xl ships, stations, stations components-->
          <set_value name="$ToleranceWeapon1" exact="8.0deg" />
          <set_value name="$ToleranceWeapon2" exact="4.0deg" />
          <set_value name="$MinGainDistance" exact="this.ship.maxcombatrange.all * 0.75" />
        </do_if>
        <do_else>
          <!-- Tolerances deppending on: l,xl ships, stations, stations components-->
          <set_value name="$ToleranceWeapon1" exact="18.0deg" />
          <set_value name="$ToleranceWeapon2" exact="8.0deg" />
          <set_value name="$MinGainDistance" exact="this.ship.maxcombatrange.all" />
        </do_else>

        <!-- Fire -->
        <shoot_at object="this.ship" target="$bigtarget" largetarget="true" slot="tag.primary_slot" tolerance="$ToleranceWeapon1" locktarget="true" weapontype="combat" />
        <!-- if it has turrets, use them -->
        <set_turret_targets object="this.ship" target="[$bigtarget]" preferredtarget="$component" weapontype="combat" />

        <!-- BEGIN FIGHT MOVEMENT -->
        <!-- 
            1. fly towards the target
            2. this script is meant for fighters, so don't do any drastic speed changes
            3. if we get too close, veer off, preferably in the direction we're going to minimize turns
            4. repeat
        -->

        <debug_text text="'start fighttarget (select shooting): ' + $component.knownname" chance="$debugoutputchance" />

        <set_value name="$doevade" exact="false" />

        <do_while value="$component.isoperational">

          <do_if value="not this.mayattack.{$bigtarget} and $checkrelation">
            <debug_text text="this.ship.name + ' is not killable enemy to ' + $bigtarget.knownname" chance="$debugoutputchance"/>
            <resume label="finish" />
          </do_if>

          <!-- not pursue target -->
          <do_if value="not @$pursuetargets and @$pursuedistance">
            <!-- escort distance check -->
            <do_if value="@$escort.isoperational">
              <do_if value="$escort.distanceto.{$target} gt ($pursuedistance + $target.size/2.0f)">
                <debug_text text="'target (%1) is further than %2 to escort object (%3), finish attack move'.[$target.knownname, $pursuedistance, $escort.knownname]" chance="$debugoutputchance" />
                <return value="false" comment="continue the fight"/>
              </do_if>
            </do_if>
            <!-- pursue distance check-->
            <do_if value="this.ship.distanceto.{$target} gt ($pursuedistance + $target.size/2.0f)">
              <debug_text text="'this ship (%1) is further than %2 to target (%3), finish attack move'.[this.ship.knownname, $pursuedistance, $target.knownname]" chance="$debugoutputchance" />
              <return value="false" comment="continue the fight"/>
            </do_if>
          </do_if>

          <!-- If the target is a specific component -->
          <do_if value="$target.container.exists">
            <set_value name="$missiletarget" exact="$target" />
            <debug_text text="'Missile target is a specific component %1'.[$missiletarget.knownname]" chance="$debugoutputchance" />
          </do_if>
          <do_else>
            <!-- check if the component in in view -->
            <check_line_of_sight object="this.ship" target="$component" name="$isinview" />
            <do_if value="$isinview" chance="this.combinedskill">
              <set_value name="$missiletarget" exact="$component" />
              <debug_text text="'Missile target is %1 and is in view!'.[$missiletarget.knownname]" chance="$debugoutputchance"  />
            </do_if>
            <do_elseif value="$component.parent.hascontext.{$bigtarget} and $component.parent.isclass.{class.destructible}">
              <set_value name="$missiletarget" exact="$component.parent" />
              <debug_text text="'Missile target component %1 is NOT selected, attack parent %2'.[$component.knownname, $missiletarget.knownname]" chance="$debugoutputchance" />
            </do_elseif>
            <do_else>
              <set_value name="$missiletarget" exact="$bigtarget" />
              <debug_text text="'Missile target component %1 is NOT selected, attack main object %2'.[$component.knownname, $missiletarget.knownname]" chance="$debugoutputchance" />
            </do_else>
          </do_else>

          <!-- shoot at missile target -->
          <shoot_at object="this.ship" target="$missiletarget" largetarget="true" slot="tag.secondary_slot" tolerance="$ToleranceWeapon2" locktarget="true" weapontype="combat" />

          <!-- do a Big Target attack run -->
          <debug_text text="'Time %1: start Big Target attack run to: %2 component: %3 - Distance=%4 .Behaviour bigfight'.[player.age, $bigtarget.knownname, $component.knownname, this.ship.distanceto.{$bigtarget}]" chance="$debugoutputchance" />
          <move_to object="this.ship" destination="$bigtarget" flightbehaviour="flightbehaviour.bigfight" forcesteering="true" >
            <position object="$component"/>
            <interrupt_after_time time="40s" />
            <interrupt>
              <conditions>
                <check_any>
                  <event_object_destroyed object="$component" />
                  <event_object_launched_missile object="this.ship" />
                </check_any>
              </conditions>
            </interrupt>
          </move_to>

          <!-- Stop shooting missiles to avoid self-hits -->
          <stop_shooting object="this.ship" slot="tag.secondary_slot" />
          <!-- try to gain distance for a new attack run -->
          <do_if value="$component.isoperational">
            <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.gaindistance" forcesteering="true" >
              <interrupt_after_time time="30s" />
              <interrupt>
                <conditions>
                  <event_object_attacked object="this.ship" />
                  <check_value value="event.param" exact="this.ship" negate="true" />
                </conditions>
                <actions>
                  <set_value name="$doevade" exact="true" />
                </actions>
              </interrupt>
            </move_to>
          </do_if>

          <do_if value="$doevade">
            <!-- evasive maneuver -->
            <debug_text text="'evasive maneuver!'" chance="$debugoutputchance" />

            <!-- try different moves -->
            <do_while value="$doevade">
              <set_value name="$doevade" exact="false" />
              <set_value name="$minevadedelay" exact="player.age + 3s" />
              <set_value name="$maxevadedelay" exact="20s" />

              <select_flight_behaviour entity="this" evasive="true" result="$fb" />
              <debug_text text="this.name + ': EVADE using '+ $fb + ' behaviour!.' + 'time: ' + player.age" chance="$debugoutputchance" />

              <move_to object="this.ship" destination="this.ship.zone" flightbehaviour="$fb" forcesteering="true">
                <position object="this.ship" min="500m" max="1km"/>
                <interrupt_after_time time="$maxevadedelay"/>
                <interrupt>
                  <conditions>
                    <check_all>
                      <event_object_attacked object="this.ship" />
                      <check_age min="$minevadedelay"/>
                    </check_all>
                  </conditions>
                  <actions>
                    <set_value name="$doevade" exact="true" />
                  </actions>
                </interrupt>
              </move_to>

            </do_while>
          </do_if>

          <wait min="1ms" max="200ms" />

        </do_while>

        <!-- Remove destroyed component, and then find new one-->
        <remove_value name="$component" />
        <wait exact="1s" sinceversion="1" />
        <!-- END FIGHT MOVEMENT -->

      </do_while>

      <label name="finish" />
      <debug_text text="'No target found'" chance="$debugoutputchance" />
      <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.default" />
      <stop_shooting object="this.ship" slot="tag.primary_slot" />
      <stop_shooting object="this.ship" slot="tag.secondary_slot" />

      <!-- Return true to continue on label 'selecttarget' -->
      <return value="true" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <!-- Nothing to do here, everything is done in unknown level of 'fight.attack.object.fighter' -->
      <label name="start" />
      <label name="fighttarget" />
      <label name="finish" />
      <return value="true" />
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="utf-8" ?>
<aiscript name="fight.attack.object.station.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="7">
  <!--

  Station defence manager script
  by Matthias

  Actively detect and attack enemies if:
	- is under attack
	- someone attack a nearby ship (max radar range)
	- blackboard: $enemies, $criminals $hackerfound, $scannerfound
	- L class or XL class is detected (if $config_attackenemies)
  
  -->
  <params>
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler>
      <conditions>
        <event_object_changed_owner object="this.station" />
      </conditions>
      <actions>
        <do_all exact="@this.$watchdogs.count" counter="$i">
          <set_owner object="this.$watchdogs.{$i}" faction="event.param" />
        </do_all>
      </actions>
    </handler>
    <handler comment="Watchdogs hacked">
      <conditions>
        <event_object_signalled object="this.station" param="'watchdogs_hacked'" />
      </conditions>
      <actions>
        <debug_text text="'watchdogs_hacked'" chance="$debugoutputchance" />
        <set_value name="this.$hacked" exact="player.age + event.param2" comment="hard coded 10 min hacked"/>
      </actions>
    </handler>
    <handler comment="Hack detected">
      <conditions>
        <check_any>
          <event_object_signalled object="this.station" param="'failed_hack_detected'" comment="param2 = hacker drone, param3 = drone's position at the time the signal was created" />
          <event_object_signalled object="this.station" param="'successful_hack_detected'" comment="param2 = hacker drone, param3 = drone's position at the time the signal was created" />
        </check_any>
      </conditions>
      <actions>
        <debug_text text="'event %1, param %2, param2 %3'.[event.name, event.param, event.param2]" chance="$debugoutputchance" />

        <set_value name="$sendpolice1" exact="0" />
        <set_value name="$sendpolice2" exact="0" />

        <!-- Different values on failed and succesful -->
        <do_if value="event.param" exact="'failed_hack_detected'">
          <set_value name="$sendpolice1" exact="[2, @this.$watchdogs.count].min" />
        </do_if>
        <do_elseif value="event.param" exact="'successful_hack_detected'">
          <set_value name="$sendpolice1" exact="[4, @this.$watchdogs.count].min" />
          <!-- Add the hacker's dronecommander has a hacker {[hackerfound, hackerfoundtime], criminals} -->
          <do_if value="@event.param2.dronecommander.exists">
            <set_value name="this.$hackerfound" exact="[event.param2.dronecommander, player.age]" />
            <add_to_group groupname="this.$criminals" object="event.param2.dronecommander"/>
            <set_value name="$sendpolice2" exact="[2, this.$watchdogs.count].min" />
          </do_if>
          <!-- Feedback -->
          <do_if value="@event.param2.isplayerowned">
            <speak actor="player.computer" line="509" comment="Communications detected." />
          </do_if>
        </do_elseif>

        <!-- Hacker drone position at that time -->
        <set_value name="$pos" exact="event.param3" />
        <!-- Get the closest watchdogs-->
        <create_list name="$watchdogsdist1" />
        <create_list name="$watchdogsdist2" />
        <do_all exact="@this.$watchdogs.count" counter="$i">
          <do_if value="$sendpolice1">
            <append_to_list name="$watchdogsdist1" exact="this.$watchdogs.{$i}.distanceto.[this.zone, $pos]" />
          </do_if>
          <do_if value="$sendpolice2">
            <append_to_list name="$watchdogsdist2" exact="this.$watchdogs.{$i}.distanceto.[this.zone, this.$hackerfound.{1}.position]" />
          </do_if>
        </do_all>

        <!-- Tell to watchdogs police to patrol and search for the hacker -->
        <do_all exact="$sendpolice1">
          <set_value name="$closestindex" exact="$watchdogsdist1.indexof.{$watchdogsdist1.min}" />
          <set_value name="$closest" exact="this.$watchdogs.{$closestindex}" />
          <set_value name="$watchdogsdist1.{$closestindex}" exact="5000m" />
          <!-- police to patrol -->
          <signal_objects object="$closest" param="'patrol'" param2="$pos" />
          <add_to_group groupname="this.$policepatrol" object="$closest" comment="counter with current patrolling ships"/>
        </do_all>
        <!-- Tell to watchdogs police to patrol and search for the hacker's commander -->
        <do_all exact="$sendpolice2">
          <set_value name="$closestindex" exact="$watchdogsdist2.indexof.{$watchdogsdist2.min}" />
          <set_value name="$closest" exact="this.$watchdogs.{$closestindex}" />
          <set_value name="$watchdogsdist2.{$closestindex}" exact="5000m" />
          <!-- signal police to patrol -->
          <signal_objects object="$closest" param="'patrol'" param2="this.$hackerfound.{1}.position" delay="40s" />
          <add_to_group groupname="this.$policepatrol" object="$closest" comment="counter with current patrolling ships"/>
        </do_all>

        <!-- remove variables -->
        <remove_value name="$pos" />
        <remove_value name="$watchdogsdist1" />
        <remove_value name="$watchdogsdist2" />
        <remove_value name="$sendpolice1" />
        <remove_value name="$sendpolice2" />
        <remove_value name="$closestindex" />

      </actions>
    </handler>
    <handler comment="Illegal cargo collection by player tagging">
      <conditions>
        <event_object_tagged tagger="player.primaryship"/>
        <check_value value="@$droppedcontainers.indexof.{event.param}" />
        <check_value value="not this.station.mayattack.{player.primaryship}" />
      </conditions>
      <actions>
        <debug_text text="'time %1: Illegal cargo collection detected. Collected object: %2  by (%3)'.[player.age, event.param.knownname, event.object.knownname]" chance="$debugoutputchance" />
        <set_relation_boost object="this.station" otherobject="event.object" value="this.station.owner.relation.kill.min" decay="1" delay="30min" />
        <add_to_group groupname="$enemies" object="event.object" />
      </actions>
    </handler>
    <handler comment="Illegal cargo collection by collector drone">
      <conditions>
        <event_object_destroyed group="$droppedcontainers" method="killmethod.collected"/>
        <check_value value="event.param and event.param.owner != this.owner"/>
      </conditions>
      <actions>
        <debug_text text="'time %1: Illegal cargo collection detected. Collected object: %2  by (%3)'.[player.age, event.object.knownname, event.param.knownname]" chance="$debugoutputchance" />

        <do_if value="not event.param.isclass.object">
          <set_value name="$collector" exact="event.param.object"/>
        </do_if>
        <do_else>
          <set_value name="$collector" exact="event.param"/>
        </do_else>
        <do_if value="$collector">
          <do_if value="not this.station.mayattack.{event.param}">
            <set_relation_boost object="this.station" otherobject="event.param" value="this.station.owner.relation.kill.min" decay="1" delay="30min" />
          </do_if>
          <add_to_group groupname="$enemies" object="event.param" />
        </do_if>
      </actions>
    </handler>
    <handler comment="Dropped cargo">
      <conditions>
        <event_object_dropped_objects object="this.station" />
      </conditions>
      <actions>
        <debug_text text="'event_object_dropped_objects: %1'.[event.param.count]" chance="$debugoutputchance"/>
        <add_to_group groupname="$droppedcontainers" list="event.param" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <!-- Command on defense officer-->
    <set_command command="command.attackenemies" />
    <!-- Init values -->
    <create_group groupname="$enemies" />
    <create_group groupname="$attackers" />
    <create_group groupname="$nearbyships" />
    <create_group groupname="$droppedcontainers"/>
  </init>
  <patch sinceversion="3">
    <set_value name="$stationfirerange" exact="this.station.maxcombatrange.all + this.station.size/2.0" />
    <!--Convert several Lists of objects into Groups-->
    <do_if value="this.$watchdogs?">
      <do_if value="typeof this.$watchdogs == datatype.list">
        <debug_text text="'watchdogs'"/>
        <set_value name="$watchdoglist" exact="[]"/>
        <do_all exact="$watchdogs.count" counter="$i">
          <do_if value="$watchdogs.{$i}.isoperational">
            <append_to_list name="$watchdoglist" exact="$watchdogs.{$i}"/>
          </do_if>
        </do_all>
        <add_to_group groupname="this.$watchdogs" list="$watchdoglist"/>
        <debug_text text="'converting watchdogs from list to group. count: ' + this.$watchdogs.count"/>
        <remove_value name="$watchdoglist"/>
      </do_if>
    </do_if>

    <do_if value="this.$enemies?">
      <do_if value="typeof this.$enemies == datatype.list">
        <set_value name="$enemieslist" exact="[]"/>
        <do_all exact="$enemies.count" counter="$i">
          <do_if value="$enemies.{$i}.isoperational">
            <append_to_list name="$enemieslist" exact="$enemies.{$i}"/>
          </do_if>
        </do_all>
        <add_to_group groupname="this.$enemies" list="$enemieslist"/>
        <debug_text text="'converting enemies from list to group. count: ' + this.$enemies.count"/>
        <remove_value name="$enemieslist"/>
      </do_if>
    </do_if>

    <do_if value="this.$criminals?">
      <do_if value="typeof this.$criminals == datatype.list">
        <set_value name="$criminalslist" exact="[]"/>
        <do_all exact="$criminals.count" counter="$i">
          <do_if value="$criminals.{$i}.isoperational">
            <append_to_list name="$criminalslist" exact="$criminals.{$i}"/>
          </do_if>
        </do_all>
        <add_to_group groupname="this.$criminals" list="$criminalslist"/>
        <debug_text text="'converting criminals from list to group. count: ' + this.$criminals.count"/>
        <remove_value name="$criminalslist"/>
      </do_if>
    </do_if>
  </patch>
  <patch sinceversion="4" early="true">
    <set_value name="$MaxEnemies" exact="0"/>
    <set_value name="$waittime" min="1s" max="4s" profile="increasing" />
  </patch>
  <patch sinceversion="5" early="true">
    <create_group groupname="$droppedcontainers"/>
  </patch>
  <patch sinceversion="6">
    <remove_value name="$nextammocheck"/>
  </patch>
  <attention min="visible">
    <actions>
      <label name="start" />

      <!-- Simulate the stand by -->
      <set_command_action commandaction="commandaction.standingby" />

      <wait sinceversion="7" chance="0" comment="dummy wait to work around script patching bug with matching blocking actions between attention levels" />

      <!-- Forget hacker after 30 min (1800s) -->
      <do_if value="this.$hackerfound?">
        <do_if value="player.age gt (this.$hackerfound.{2} + 1800s)">
          <remove_from_group group="this.$criminals" object="this.$hackerfound.{1}" />
          <remove_value name="this.$hackerfound" />
        </do_if>
      </do_if>
      <!-- Forget Scanner after 20 min (1200) -->
      <do_if value="this.$scannerfound?">
        <do_if value="player.age gt (this.$scannerfound.{2} + 1200s)">
          <remove_from_group group="this.$criminals" object="this.$scannerfound.{1}" />
          <remove_value name="this.$scannerfound" />
        </do_if>
      </do_if>

      <!-- removed as of version 6 -->
      <run_script name="''" sinceversion="1" chance="0" />

      <wait min="60s" max="120s">
        <interrupt>
          <conditions>
            <check_any>
              <check_all>
                <event_gravidar_has_scanned object="this.station" />
                <check_value value="(this.station.trueowner != faction.player) or @this.$config_attackenemies" />
              </check_all>
              <check_all>
                <check_any>
                  <check_all>
                    <event_object_attacked group="$nearbyships" />
                    <check_value value="(this.station.trueowner != faction.player) or @this.$config_attackenemies or event.object.isplayerowned" />
                  </check_all>
                  <event_object_attacked object="this.station" />
                </check_any>
                <check_value value="event.param != this.station" />
                <check_value value="event.param.isoperational" />
                <check_value value="this.station.mayattack.{event.param}" />
                <check_value value="not $enemies.indexof.{event.param}" />
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <do_if value="event.name == 'event_object_attacked'">
              <!-- Add the attackers -->
              <add_to_group groupname="$attackers" object="event.param" />
              <debug_text text="'enemy ' + event.param.knownname + '('+ event.param.owner.knownname +'), relation us to them: '+ this.station.relationto.{event.param} + ', relation them to us: '+ event.param.relationto.{this.station}" chance="$debugoutputchance" />
            </do_if>
          </actions>
        </interrupt>
      </wait>

      <!-- If no enemies, update nearbyships -->
      <do_if value="not $enemies.count">
        <clear_group group="$nearbyships"/>
        <find_gravidar_contact groupname="$nearbyships" object="this.station" functional="true" multiple="true">
          <match_distance object="this.station" max="this.station.maxradarrange + this.station.size/2.0" />
        </find_gravidar_contact>
      </do_if>

      <!-- add attackers to enemies -->
      <do_if value="$attackers.count" >
        <debug_text text="'Station defence manager adds ' + $attackers.count + ' enemies from attackers ' + $enemies.count + ' enemies'" chance="$debugoutputchance" />
        <add_to_group groupname="$enemies" group="$attackers"/>
        <clear_group group="$attackers"/>
      </do_if>

      <!-- Internal list of enemies -->
      <do_if value="@this.$enemies.count" >
        <debug_text text="'Station defence manager adds ' + this.$enemies.count + ' enemies from watchdogs to group'" chance="$debugoutputchance" />
        <do_all exact="this.$enemies.count" counter="$i" reverse="true">
          <do_if value="this.$enemies.{$i}.mayattack.{this.station}">
            <add_to_group groupname="$enemies" object="this.$enemies.{$i}" />
          </do_if>
          <do_else>
            <debug_text text="'this %1, is no enemy: %2'.[this.$enemies.{$i}, this.$enemies.{$i}.knownname]" chance="$debugoutputchance" />
            <remove_from_group group="this.$enemies" object="this.$enemies.{$i}"/>
          </do_else>
        </do_all>
      </do_if>

      <!-- new gravidar enemeis-->
      <do_if value="(this.station.trueowner != faction.player) or @this.$config_attackenemies">
        <find_gravidar_contact groupname="$enemies" object="this.station" functional="true" multiple="true">
          <match_any>
            <match maybeattackedby="this.station" class="[class.ship_l,class.ship_xl]" comment="only select l/xl objects" />
            <match>
              <match_relation relation="kill" faction="this.station.owner" comment="if they factions are enemies, select that object too" />
              <match class="class.ship_xs" negate="true" />
            </match>
          </match_any>
        </find_gravidar_contact>
      </do_if>

      <label name="fight" />

      <set_value name="$stationfirerange"  exact="this.station.maxcombatrange.all + this.station.size / 2.0f"/>
      <set_value name="$droneengagementrange"  exact="$stationfirerange * (0.7f + ((this.combinedskill)f / 200.0f))"/>

      <do_if value="$enemies.count" min="1">
        <!-- Iterate in reverse and remove if neccesary -->
        <do_all exact="$enemies.count" counter="$i" reverse="true">
          <!-- Check objects distance and attack relation -->
          <check_object result="$result" object="$enemies.{$i}" maybeattackedby="this.station" functional="true">
            <match_distance object="this.station" max="$stationfirerange + $enemies.{$i}.size / 2.0f" />
          </check_object>
          <!-- Check if the object can be attacked and is in radar range -->
          <do_if value="$result">
            <debug_text text="'shoot at ' + $enemies.{$i}.knownname + ' ('+ $enemies.{$i}.owner.knownname +', '+ $enemies.{$i} +')'" chance="$debugoutputchance"/>
            <!-- drone targets -->
            <do_if value="$enemies.{$i}.isclass.[class.ship_xs, class.ship_s, class.ship_m]">
              <!-- On station range -->
              <do_if value="this.station.distanceto.{$enemies.{$i}} le ($droneengagementrange)">
                <add_to_group groupname="$dronetargets" object="$enemies.{$i}" />
              </do_if>
            </do_if>
          </do_if>
          <do_else>
            <remove_from_group group="$enemies" object="$enemies.{$i}" />
          </do_else>
        </do_all>

        <!-- Set the attack -->
        <set_command_action commandaction="commandaction.attacking" />

        <set_turret_targets object="this.station" target="$enemies.list" />

        <!-- Launch drones -->
        <!-- check to make sure that the station has something to shoot at and something to shoot it with. 
              wait until there are multiple targets within range so that drones don't dock after killing the first target. -->
        <do_if value="this.station.availableunits.{unitcategory.defence}.count and ((@$dronetargets.count ge 3) or @$dronetargets.indexof.{player.primaryship})">
          <!-- The better the defence officer, less time delay -->
          <do_if value="player.age" min="@$lastdronelaunch + 1min + (1.0f - this.combinedskill/100.0f) * 10min">
            <!-- look for the closest target. -->
            <do_all exact="$dronetargets.count" counter="$i">
              <do_if value="@$activedronetarget">
                <do_if value="$dronetargets.{$i}.distanceto.{this.station} lt $activedronetarget.distanceto.{this.station}">
                  <set_value name="$activedronetarget" exact="$dronetargets.{$i}"/>
                </do_if>
              </do_if>
              <do_else>
                <set_value name="$activedronetarget" exact="$dronetargets.{$i}"/>
              </do_else>
            </do_all>
            <!-- use the closest dock. -->
            <find_object_component groupname="$stdronepads" object="this.station" class="class.dronelaunchpad" multiple="true" checkoperational="true"/>
            <do_if value="$stdronepads.count ge 1">
              <do_all exact="$stdronepads.count" counter="$j">
                <do_if value="@$activedronepad">
                  <do_if value="$activedronetarget.distanceto.{$stdronepads.{$j}} lt $activedronetarget.distanceto.{$activedronepad}">
                    <set_value name="$activedronepad" exact="$stdronepads.{$j}"/>
                  </do_if>
                </do_if>
                <do_else>
                  <set_value name="$activedronepad" exact="$stdronepads.{$j}"/>
                </do_else>
              </do_all>
              <set_value name="$lastdronelaunch" exact="player.age"/>
              <!-- number of drones launched depends on DO combat skill. small variability. -->
              <launch_drone name="$drone" object="$activedronepad" min="3" max="[this.skill.combat, 3].max" group="unitcategory.defence"/>
              <do_if value="$drone">
                <start_script object="$drone.pilot" name="'fight.attack.object.drone.leader'">
                  <param name="target" value="$activedronetarget"/>
                  <param name="additionaltargets" value="$dronetargets"/>
                  <param name="range" value="$droneengagementrange"/>
                </start_script>
              </do_if>
              <remove_value name="$activedronepad"/>
            </do_if>
            <do_else>
              <debug_text text="'%1 \n in %2, %3, %4 \n tried to launch drones but does not have drone launch pads. \n %5 combat drones equipped.'.[this.station.knownname, this.station.zone.knownname, this.station.sector.knownname, this.station.cluster.knownname, this.station.availableunits.{unitcategory.defence}.count]" chance="$debugoutputchance"/>
            </do_else>
            <remove_value name="$activedronetarget"/>
          </do_if>
          <!-- clear drone targets -->
          <remove_value name="$dronetargets"/>
        </do_if>
      </do_if>
      <do_else>
        <cease_fire object="this.station"/>
      </do_else>

      <wait min="300ms" max="1s" sinceversion="2" chance="0" comment="if this wait is enabled, the station does not get the attack events"/>

      <resume label="start" />
    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <label name="start" />

      <!-- Simulate the attack -->
      <set_command_action commandaction="commandaction.attacking" />

      <!-- removed as of version 6 -->
      <run_script name="''" sinceversion="1" chance="0" />

      <!-- add attackers to enemies -->
      <do_if value="$attackers.count" >
        <add_to_group groupname="$enemies" group="$attackers"/>
        <debug_text text="'Station defence manager adds ' + $attackers.count + ' enemies from attackers. ' + $enemies.count + ' enemies'" chance="$debugoutputchance" />
        <clear_group group="$attackers"/>
      </do_if>

      <!-- Internal list of enemies -->
      <do_if value="@this.$enemies.count" >
        <debug_text text="'Station defence manager adds ' + this.$enemies.count + ' enemies from watchdogs to group'" chance="$debugoutputchance" />
        <do_all exact="this.$enemies.count" counter="$i" reverse="true">
          <do_if value="this.$enemies.{$i}.mayattack.{this.station}">
            <add_to_group groupname="$enemies" object="this.$enemies.{$i}" />
          </do_if>
          <do_else>
            <debug_text text="'this %1, is no enemy: %2'.[this.$enemies.{$i}, this.$enemies.{$i}.knownname]" chance="$debugoutputchance" />
            <remove_from_group group="this.$enemies" object="this.$enemies.{$i}"/>
          </do_else>
        </do_all>
      </do_if>

      <!-- new gravidar enemeis-->
      <do_if value="(this.station.trueowner != faction.player) or @this.$config_attackenemies">
        <find_gravidar_contact groupname="$enemies" object="this.station" functional="true" multiple="true">
          <match_any>
            <match maybeattackedby="this.station" class="[class.ship_l,class.ship_xl]" comment="only select l/xl objects" />
            <match>
              <match_relation relation="kill" faction="this.station.owner" comment="if they factions are enemies, select that object too" />
              <match class="class.ship_xs" negate="true" />
            </match>
          </match_any>
        </find_gravidar_contact>
      </do_if>

      <label name="fight" />

      <set_value name="$attacktime" exact="player.age + 1min" />
      <set_value name="$stationfirerange"  exact="this.station.maxcombatrange.all + this.station.size/2.0" />

      <set_value name="$waittime" exact="1s" />
      <!-- Attack while there are enemies.  -->
      <do_while value="$enemies.count" >
        <set_value name="$target" exact="$enemies.random"/>
        <do_if value="$target.isoperational">
          <!-- Check object -->
          <check_object result="$result" object="$target" maybeattackedby="this.station" functional="true">
            <match_distance object="this.station" max="$stationfirerange + $target.size/2.0" />
          </check_object>
          <do_if value="not @$MaxEnemies">
            <set_value name="$waittime" min="1s" max="5s"/>
            <!--The maximum amount of enemies to be hit in this volley, based on the number of operational turrets-->
            <set_value name="$MaxEnemies" exact="[this.station.summary.numturrets.operational / 5, 3, $enemies.count].min"/>
            <do_if value="true" chance="10">
              <set_value name="$MaxEnemies" min="1" max="$MaxEnemies"/>
            </do_if>
          </do_if>

          <!-- If is enemy and is in range -->
          <do_if value="$result">
            <!-- exclude the player ship in OOS case, this scenario wouldn't make any sense anyway -->
            <do_if value="$target != player.primaryship">
              <!-- Get and apply strengths-->
              <get_attackstrength object="this.station" target="$target" usedrones="false" result="$result" />
              <apply_attackstrength object="$target" attacker="this.station" strength="$result * $waittime" result="$isdead" />
              <!-- simulate OOS ammo usage for NPCs, TODO: improve -->
              <do_if value="not this.station.isplayerowned">
                <remove_ammo object="this.station" macro="macro.missile_turret_dumbfire_macro" amount="2" chance="2" />
                <remove_ammo object="this.station" macro="macro.missile_turret_swarm_macro" amount="2" chance="2" />
              </do_if>
              <debug_text text="'%1 OOS. Apply strength of %2 against %3 %4 is: %5(%6|%7). Is killed: %8'.[player.age,this.station.knownname,$target.knownname,$target,$result * $waittime,$target.hull,$target.shield,$isdead]" chance="$debugoutputchance" />
              <!--Wait so that attack/killed events are processed-->
              <wait exact="1ms" sinceversion="4"/>
            </do_if>
          </do_if>
          <do_else>
            <!-- Remove from enemy list -->
            <remove_from_group group="$enemies" object="$target" />
          </do_else>
        </do_if>

        <do_if value="@$MaxEnemies gt 0">
          <set_value name="$MaxEnemies" operation="subtract"/>
        </do_if>
        <do_if value="not @$MaxEnemies">
          <!-- Search/Attacking waiting time -->
          <wait exact="$waittime" profile="decreasing">
            <interrupt>
              <conditions>
                <check_any>
                  <check_all>
                    <event_object_attacked group="$nearbyships" />
                    <check_value value="(this.station.trueowner != faction.player) or @this.$config_attackenemies or event.object.isplayerowned" />
                  </check_all>
                  <event_object_attacked object="this.station" />
                </check_any>
                <check_value value="event.param != this.station" />
                <check_value value="event.param.isoperational" />
                <check_value value="this.station.mayattack.{event.param}" />
                <check_value value="not $enemies.indexof.{event.param}" />
                <check_value value="not $attackers.indexof.{event.param}" />
              </conditions>
              <actions>
                <add_to_group groupname="$attackers" object="event.param"/>
              </actions>
            </interrupt>
          </wait>
        </do_if>
        <!-- Avoid an infite loop-->
        <do_if value="player.age" min="$attacktime">
          <debug_text text="' unknown. break attack loop because attacktime is more than ' + $attacktime" chance="$debugoutputchance" />
          <break/>
        </do_if>
        <do_if value="$attackers.count">
          <add_to_group groupname="$enemies" group="$attackers"/>
          <debug_text text="'Station defence manager adds ' + $attackers.count + ' enemies from attackers ' + $enemies.count + ' enemies'" chance="$debugoutputchance" />
          <clear_group group="$attackers"/>
        </do_if>
      </do_while>

      <do_if value="$enemies.count" exact="0">
        <!-- Simulate the stand by -->
        <set_command_action commandaction="commandaction.standingby" />
      </do_if>

      <!-- Wait for enemies-->
      <wait min="10s" max="20s">
        <interrupt>
          <conditions>
            <check_any>
              <check_all>
                <event_gravidar_has_scanned object="this.station" chance="50" comment="reducing the chance of waking-up by gravidar (performance)" />
                <check_value value="(this.station.trueowner != faction.player) or @this.$config_attackenemies" />
              </check_all>
              <check_all>
                <check_any>
                  <check_all>
                    <event_object_attacked group="$nearbyships" />
                    <check_value value="(this.station.trueowner != faction.player) or @this.$config_attackenemies or event.object.isplayerowned" />
                  </check_all>
                  <event_object_attacked object="this.station" />
                </check_any>
                <check_value value="event.param != this.station" />
                <check_value value="event.param.isoperational" />
                <check_value value="this.station.mayattack.{event.param}" />
                <check_value value="not $enemies.indexof.{event.param}" />
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <do_if value="event.name == 'event_object_attacked'">
              <add_to_group groupname="$attackers" object="event.param" />
              <debug_text text="'enemy ' + event.param.knownname + '('+ event.param.owner.knownname +'), relation us to them: '+ this.station.relationto.{event.param} + ', relation them to us: '+ event.param.relationto.{this.station}" chance="$debugoutputchance" />
            </do_if>
          </actions>
        </interrupt>
      </wait>

      <!-- If no enemies, update nearbyships -->
      <do_if value="not $enemies.count">
        <clear_group group="$nearbyships"/>
        <find_gravidar_contact groupname="$nearbyships" object="this.station" functional="true" multiple="true">
          <match_distance object="this.station" max="this.station.maxradarrange + this.station.size/2.0" />
        </find_gravidar_contact>
      </do_if>

      <!-- Forget hacker after 30 min (1800s) -->
      <do_if value="this.$hackerfound?">
        <do_if value="player.age gt (this.$hackerfound.{2} + 1800s)">
          <remove_from_group group="this.$criminals" object="this.$hackerfound.{1}" />
          <remove_value name="this.$hackerfound" />
        </do_if>
      </do_if>
      <!-- Forget Scanner after 20 min (1200) -->
      <do_if value="this.$scannerfound?">
        <do_if value="player.age gt (this.$scannerfound.{2} + 1200s)">
          <remove_from_group group="this.$criminals" object="this.$scannerfound.{1}" />
          <remove_value name="this.$scannerfound" />
        </do_if>
      </do_if>

      <resume label="start" />

    </actions>
  </attention>
  <on_abort killed="true">
    <!--Cleanup any ammo trades-->
    <find_buy_offer result="$ammotrades" buyer="this.container" unbundle="true" multiple="true"/>
    <do_all exact="$ammotrades.count" counter="$i">
      <debug_text text="'Removing ammo trade ' + $ammotrades.{$i}"/>
      <remove_trade_offer object="this.container" tradeoffer="$ammotrades.{$i}"/>
    </do_all>
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="fight.attack.object.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <!--

  Script to decide which fight.attack.object.foo script is suitable to be called

  Depending on the class:
  - Drone:
    - fight.attack.object.drone.leader
  - xs, s, m: 
	  -fight.attack.object.fighter
  - l, xl:
		- signal 'attack target' (defense officer)
		- move.attack.object.capital (pilot)
  - station: 
		- fight.attack.object.station
  
  -->
  <params>
    <param name="target" comment="The object to fight with" />
    <param name="escort" default="null" comment="Objects to escort - stay at 'pursuedistance' and shoot enemies attacking this" />
    <param name="pursuedistance" default="this.ship.maxradarrange" comment="Distance to pursue/escort (if pursuetargets true or 'escort' provided). Default: max radar range" />
    <param name="pursuetargets" default="false" comment="Pursue the target no matter what. Default: false" />
    <param name="allowothertargets" default="true" comment="Whether the script shall keep running when all primary targets have been destroyed. Default: true" />
    <param name="checkrelation" default="true" comment="Check may attack (faction enemy relation). Default: true" />
    <param name="idle" default="false" comment="Not to be used if rejoinformation is true. Default: false
           When finished attacking enemy - Ships: Idle around looking for enemies. Stations: Start fight.attack.object.station"/>
    <param name="debugoutputchance" default="0"/>
  </params>

  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler ref="AttackHandler.vanilla40"/>
    <handler ref="ScannedHandler.vanilla40" />
    <handler>
      <conditions>
        <event_object_changed_owner object="$target" check="false" />
      </conditions>
      <actions>
        <!-- Remove the target to stop shooting at it, when owner changes -->
        <set_value name="$target" exact="null" />
        <abort_called_scripts />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.attackobject" param="$target"/>
  </init>
  <patch sinceversion="1">
    <set_value name="$checkrelation" exact="true" />
  </patch>
  <attention min="unknown">
    <actions>
      <do_if value="not $target.isoperational">
        <debug_text text="'target not operational'" chance="$debugoutputchance" />
        <return/>
      </do_if>
      <do_if value="this.defensible.exists">
        
        <!-- HACK: force relation boost from this to player, if check relation is false -->
        <do_if value="not $checkrelation and @$target.isplayerowned and not @this.mayattack.{$target}" comment="target can be null">
          <add_relation_boost object="this" otherobject="$target" value="this.owner.relation.kill.max" decay="1" delay="10min" silent="true" />
        </do_if>
        
        <set_value name="$Defensible" exact="this.defensible"/>

        <do_if value="$Defensible.isclass.ship">
          <do_if value="this == $Defensible.pilot">
            <!--If you're in a formation, leave-->
            <!--TODO: Alert your formation leader and commander that you're going solo-->
            <set_value name="$WasInFormation" exact="false"/>
            <do_if value="$Defensible.formationleader">
              <do_if value="$Defensible.formationleader" exact="$Defensible" negate="true">
                <leave_formation object="$Defensible"/>
                <set_value name="$WasInFormation" exact="true"/>
              </do_if>
            </do_if>
            <!-- Drones -->
            <do_if value="$Defensible.isclass.drone">
              <run_script name="'fight.attack.object.drone.leader.vanilla40'">
                <param name="target" value="$target"/>
                <param name="checkrelation" value="$checkrelation" />
                <param name="debugoutputchance" value="$debugoutputchance" />
              </run_script>
            </do_if>

            <!-- Small ships -->
            <do_elseif value="$Defensible.isclass.ship_xs or $Defensible.isclass.ship_s or $Defensible.isclass.ship_m">
              <add_to_group groupname="$primarytargets" object="$target" check="false" />
              <run_script name="'fight.attack.object.fighter.vanilla40'">
                <param name="primarytargets" value="$primarytargets"/>
                <param name="pursuetargets" value="$pursuetargets" />
                <param name="allowothertargets" value="$allowothertargets" />
                <param name="escort" value="$escort"/>
                <param name="pursuedistance" value="$pursuedistance" />
                <param name="checkrelation" value="$checkrelation"/>
                <param name="debugoutputchance" value="$debugoutputchance" />
              </run_script>
            </do_elseif>

            <!-- Capital ships -->
            <do_elseif value="$Defensible.isclass.ship_l or $Defensible.isclass.ship_xl">
              <!-- Send the target to the Defence NPC -->
              <do_if value="$Defensible.defencenpc.exists">
                <signal_objects object="$Defensible.defencenpc" param="'attack'" param2="$target" param3="[$allowothertargets, $checkrelation]" />
              </do_if>
              <!-- Movement in pilot -->
              <run_script name="'move.attack.object.capital.vanilla40'">
                <param name="target" value="$target"/>
                <param name="pursuetargets" value="$pursuetargets" />
                <param name="escort" value="$escort"/>
                <param name="pursuedistance" value="$pursuedistance" />
                <param name="checkrelation" value="$checkrelation"/>
                <param name="debugoutputchance" value="$debugoutputchance" />
              </run_script>
            </do_elseif>
            <!-- Send the target to the Defence NPC -->
            <do_if value="$Defensible.defencenpc.exists">
              <signal_objects object="$Defensible.defencenpc" param="'stop attack'" />
            </do_if>

            <do_if value="$WasInFormation">
              <do_if value="this.ship.commander.exists">
                <do_if value="not this.ship.commander.isclass.station">
                  <join_formation object="this.ship" leader="this.ship.commander"/>
                </do_if>
              </do_if>
            </do_if>
            <do_elseif value="$idle">
              <run_script name="'move.patrol.vanilla40'">
                <param name="range" value="'zone'"/>
              </run_script>
            </do_elseif>
          </do_if>
          <do_else>
            <debug_text text="'Error: Attempting to call fight.attack.object on an entity which is not the pilot of the ship'"/>
          </do_else>
        </do_if>

        <!-- Stations -->
        <do_elseif value="$Defensible.isclass.station">
          <do_if value="this == $Defensible.defencenpc">
            <run_script name="'fight.attack.object.station.vanilla40'">
              <param name="target" value="$target"/>
              <param name="debugoutputchance" value="$debugoutputchance" />
            </run_script>
          </do_if>
          <do_else>
            <debug_text text="'Error: Attempting to call fight.attack.object on an entity which is not the Defence NPC of the station'"/>
          </do_else>

          <do_if value="$idle">
            <run_script name="'fight.attack.object.station.vanilla40'">
              <param name="debugoutputchance" value="$debugoutputchance" />
            </run_script>
          </do_if>
        </do_elseif>

        <do_else>
          <debug_text text="'Error: Defensible is not of a class which has a suitable script'"/>
        </do_else>
      </do_if>
      <do_else>
        <debug_text text="'Error: fight.attack.object was called on an entity without a \'defensible\' class parent'"/>
      </do_else>
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="fight.defend.capital.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="2">
  <!--

  Fight attack object capital
  by Adrian
  
  Defense mode of a capital ship (made by defense noc), to enemys in weapon range.
  This ship reacts to attacks and attempt to defend itself.
  Attack configuration: this.$config_attackenemies
  
    - Defense Mode: 0
    - Attack Mode : 1
    - Withdraw from Battle

  -->
  <interrupts>
    <handler>
      <conditions>
        <event_object_signalled object="this" param="'attack'" comment="param2 is target, param3 is [$allowothertargets, $checkrelation]"/>
        <check_value value="not @$permanent" comment="don't accept orders if Hold Fire Mode" />
      </conditions>
      <actions>
        <debug_text text="'event %1, param %2, param2 %3'.[@event.name, @event.param, @event.param2]" chance="$debugoutputchance" />
        <set_value name="$attacker" exact="event.param2" />
        <set_value name="$allowothertargets" exact="event.param3.{1}" />
        <set_value name="$checkrelation" exact="event.param3.{2}" />
        <!-- Tell to subordinates to attack -->
        <set_value name="$subordinates" exact="this.ship.subordinates" />
        <do_all exact="$subordinates.count" counter="$i" >
          <do_if value="$subordinates.{$i}.defencenpc.exists">
            <debug_text text="'attack to %1. allowothertargets %2'.[$subordinates.{$i}.defencenpc, $allowothertargets]" chance="$debugoutputchance" />
            <signal_objects object="$subordinates.{$i}.defencenpc" param="'attack'" param2="event.param2" param3="event.param3" />
          </do_if>
        </do_all>
        <remove_value name="$subordinates" />
        <abort_called_scripts />
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_object_signalled object="this" param="'stop attack'"/>
        <check_value value="not @$permanent or event.param2 == 'stop permanent'" comment="don't accept orders if Hold Fire Mode" />
      </conditions>
      <actions>
        <debug_text text="'event %1, param %2, param2 %3'.[@event.name, @event.param, @event.param2]" chance="0" />
        <remove_value name="$allowothertargets" />
        <remove_value name="$attacker" />
        <set_value name="$checkrelation" exact="true" comment="check relation by default" />

        <!-- Withdraw from Battle -->
        <do_if value="event.param2" exact="'permanent'">
          <set_value name="$permanent" exact="true" />
        </do_if>
        <do_elseif value="event.param2" exact="'stop permanent'">
          <remove_value name="$permanent" />
        </do_elseif>

        <!-- Tell to subordinates to stop attack -->
        <set_value name="$subordinates" exact="this.ship.subordinates" />
        <do_all exact="$subordinates.count" counter="$i" >
          <do_if value="$subordinates.{$i}.defencenpc.exists">
            <debug_text text="'stop to %1'.[$subordinates.{$i}.defencenpc]" chance="$debugoutputchance"/>
            <signal_objects object="$subordinates.{$i}.defencenpc" param="event.param" param2="event.param2" />
          </do_if>
        </do_all>
        <remove_value name="$subordinates" />
        <abort_called_scripts />
      </actions>
    </handler>
    <handler comment="update the configuration attack">
      <conditions>
        <event_object_signalled object="this" param="'update config'" />
      </conditions>
      <actions>
        <remove_value name="$allowothertargets" />
        <remove_value name="$attacker" />
        <set_value name="$checkrelation" exact="true" comment="check relation by default" />
        <abort_called_scripts />
      </actions>
    </handler>
    <handler comment="commander destroyed cleanup">
      <conditions>
        <event_object_commander_set object="this.ship" />
        <check_value value="@$permanent" comment="if Hold Fire Mode" />
      </conditions>
      <actions>
        <remove_value name="$allowothertargets" />
        <remove_value name="$attacker" />
        <remove_value name="$permanent" />
        <set_value name="$checkrelation" exact="true" comment="check relation by default" />
        <!-- Tell to subordinates to stop attack -->
        <set_value name="$subordinates" exact="this.ship.subordinates" />
        <do_all exact="$subordinates.count" counter="$i" >
          <do_if value="$subordinates.{$i}.defencenpc.exists">
            <debug_text text="'stop to %1'.[$subordinates.{$i}.defencenpc]" chance="$debugoutputchance"/>
            <signal_objects object="$subordinates.{$i}.defencenpc" param="'stop attack'" param2="'stop permanent'" comment="Set Hold Fire Mode" />
          </do_if>
        </do_all>
        <remove_value name="$subordinates" />
        <abort_called_scripts />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command_action commandaction="commandaction.standingby" />
    <set_value name="$debugoutputchance" exact="0"/>
  </init>
  <patch sinceversion="2">
    <set_value name="$debugoutputchance" exact="0"/>
  </patch>
  <attention min="unknown">
    <actions>
      <label name="start"/>
      
      <!-- Stop shooting targets-->
      <cease_fire object="this.ship" weapontype="combat" />

      <!-- Infinite loop. Change to attack if this.$config_attackenemies or is under attack-->
      <do_while value="true">
        <!-- DEFENSIVE MODE 0: wait if no enemy or no config attack-->
        <do_if value="not @$attacker.isoperational and not @this.$config_attackenemies and not @$permanent" >
          <wait>
            <interrupt>
              <conditions>
                <event_object_attacked object="this.ship" />
                <check_value value="this.ship.mayattack.{event.param}" comment="check relation of ship (not defense NPC)" />
              </conditions>
              <actions>
                <set_value name="$attacker" exact="event.param" />
                <set_value name="$checkrelation" exact="true" comment="check relation by default" />
              </actions>
            </interrupt>
          </wait>
        </do_if>
        <!-- ATTACK MODE 1: If there is an enemy, attack only him -->
        <do_elseif value="not @$permanent">
          <run_script name="'fight.attack.object.capital.vanilla40'" >
            <param name="target" value="@$attacker" />
            <param name="allowothertargets" value="@this.$config_attackenemies or @$allowothertargets" />
            <param name="checkrelation" value="$checkrelation" />
            <param name="debugoutputchance" value="$debugoutputchance"/>
          </run_script>
          <!-- delete the enemy -->
          <remove_value name="$attacker" />
        </do_elseif>
        <!-- Withdraw from Battle: Permanent Hold Fire -->
        <do_else >
          <wait />
        </do_else>

      </do_while>

    </actions>
  </attention>
  <on_abort>
    <!-- Stop shooting targets if interrupted (change the npc)-->
    <cease_fire object="this.ship" weapontype="combat" />
  </on_abort>
</aiscript><?xml version="1.0" encoding="utf-8" ?>
<aiscript name="fight.station.player.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <!--

  Player station defence manager script
  by Michael

  -->
  <params>
    <param name="debugchance" default="0"/>
  </params>
  <attention min="unknown">
    <actions>
      <!-- first time init -->
      <label name="init" />
      <set_value name="$tradeships" exact="this.station.subordinates.{entitytype.manager}"/>
      <do_all exact="this.station.subordinates.{entitytype.defencecontrol}.count" counter="$s" chance="0">
        <!-- when we get include actions in the future we could move this code there instead of duplicating it in the event handler -->
        <set_value name="$subordinate" exact="this.station.subordinates.{entitytype.defencecontrol}.{$s}" />
        <set_value name="$capship" exact="$subordinate.isclass.ship_l or $subordinate.isclass.ship_xl" />

        <do_if value="$capship">
          <!-- protect this station -->
          <do_if value="$subordinate.dps.turrets.all gt 5000.f">
            <!-- protect this station, ship will patrol within the radar range -->
            <debug_text text="'ship %1(%2) will patrol the station in range %3.'.[$subordinate.knownname, $subordinate, $Object.size/2 + $subordinate.maxradarrange]" chance="$debugchance" />
            <start_script name="'move.patrol.vanilla40'" object="$subordinate.pilot">
              <param name="range" value="'station'" comment="this Object" />
              <param name="range_max" value="$Object.size/2 + $subordinate.maxradarrange" />
            </start_script>
          </do_if>
          <do_else>
            <!-- ship isn't all that useful -->
            <!-- protect this station, ship will patrol within half of the radar range -->
            <debug_text text="'ship %1(%2) will patrol the station in range %3.'.[$subordinate.knownname, $subordinate, $Object.size/2 + $subordinate.maxradarrange/2]" chance="$debugchance" />
            <start_script name="'move.patrol.vanilla40'" object="$subordinate.pilot">
              <param name="range" value="'station'" comment="this Object" />
              <param name="range_max" value="$Object.size/2 + $subordinate.maxradarrange/2" />
            </start_script>
          </do_else>
        </do_if>
        <do_else>
          <do_if value="$subordinate.dps.all gt 100.f">
            <set_value name="$tradeships" exact="this.station.subordinates.{entitytype.manager}"/>
            <!-- For each trade ship of the station -->
            <do_if value="$tradeships.count">
              <create_list name="$smalltraders" />
              <do_all exact="$tradeships.count" counter="$t">
                <do_if value="$tradeships.{$t}.isclass.ship_l or $tradeships.{$t}.isclass.ship_xl" negate="true">
                  <append_to_list name="$smalltraders" exact="$tradeships.{$t}" />
                </do_if>
              </do_all>
              <!-- First escort small trade ship, if not a capital trade ship -->
              <do_if value="$smalltraders.count">
                <debug_text text="'ship %1(%2) will escort a small trade ship.'.[$subordinate.knownname, $subordinate]" chance="$debugchance" />
                <start_script name="'move.escort.vanilla40'" object="$subordinate.pilot">
                  <param name="target" value="$smalltraders.random" />
                </start_script>
              </do_if>
              <do_else>
                <debug_text text="'ship %1(%2) will escort a big trade ship.'.[$subordinate.knownname, $subordinate]" chance="$debugchance" />
                <start_script name="'move.escort.vanilla40'" object="$subordinate.pilot">
                  <param name="target" value="$tradeships.random" />
                </start_script>
              </do_else>
            </do_if>
            <do_else>
              <debug_text text="'ship %1(%2) has nothing useful to do, default to patrol.'.[$subordinate.knownname, $subordinate]" chance="$debugchance" />
              <start_script name="'move.patrol.vanilla40'" object="$subordinate.pilot">
                <param name="range" value="'station'" comment="this Object" />
                <param name="range_max" value="$Object.size/2 + $subordinate.maxradarrange" />
              </start_script>
            </do_else>
          </do_if>
          <do_else>
            <debug_text text="'ship %1(%2) is not useful for combat purposes.'.[$subordinate.knownname, $subordinate]" chance="$debugchance" />
            <start_script name="'move.generic.vanilla40'" object="$subordinate.pilot" >
              <param name="destination" value="this.station" />
            </start_script>
          </do_else>
        </do_else>
      </do_all>

      <label name="loop" />
      <!-- run the standard fight script, while waiting to assign ships when needed -->
      <do_while value="true">
        <run_script name="'fight.attack.object.station.vanilla40'" />
        <wait min="1s" max="10s" />
      </do_while>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1"?>
<aiscript xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="interrupt.attacked.vanilla40" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="10" version="1"><params><param name="attacker"/><param name="attackrespond"/><param name="fleerespond"/><param name="debugoutputchance" default="0"/></params><interrupts><library><handler name="AttackHandler.vanilla40"><conditions><event_object_attacked object="this.defensible"/><!-- basic check [class.ship_l, class.ship_xl] --><check_value value="not this.defensible.isclass.{class.station}"/><check_value value="event.param.isoperational and this.mayattack.{event.param}"/><!-- Safety checks --><check_value value="(not @this.$shiptrader_docking) and (not @this.$ship_parking) and (not this.ship.dockslot) and (not this.ship.docklink) and (not this.zone.isclass.highway)"/><!-- If it is already attacking the attacker, do not run the script --><check_value value="not (this.command.value == command.attackobject and this.command.param == event.param)"/><!-- Respond condition --><check_any><!-- Attack respond --><check_all><check_value value="not this.defensible.isplayerowned" comment="not engage player owned ships"/><check_value value="not this.defensible.isclass.[class.ship_l, class.ship_xl]" comment="if this is a capship, let the Deffence Officer handle it"/><check_value value="(not event.param.isclass.{class.station}) and ((this.ship.primarypurpose == objectpurpose.fight) or (this.ship.dps.all gt event.param.dps.all))"/><set_value name="$attackrespond" exact="true"/></check_all><!-- Flee respond --><!-- Flee Response is deactivated in XFF --><!--check_all>
              <check_value value="this.combinedskill ge 20" comment="at least 1 start on average" /--><!-- The better the skills, earlier flee respond --><!--check_value value="((this.combinedskill - this.ship.shieldpercentage) ge 25) or ((this.combinedskill - this.ship.hullpercentage) ge 20)" />
              <set_value name="$fleerespond" exact="true" />
            </check_all--></check_any></conditions><actions><!-- Only enter on the interrupt_script if it's really going to perform any action,
          otherwise the current action could be interrupted for a frame and restarted again --><do_if value="(@$attackrespond or @$fleerespond) and this.ship.hull"><!-- Run interrupt script to use blocking action: run_script attack object. --><run_interrupt_script name="'interrupt.attacked.vanilla40'"><param name="attacker" value="event.param"/><param name="attackrespond" value="@$attackrespond"/><param name="fleerespond" value="@$fleerespond"/></run_interrupt_script></do_if></actions></handler></library></interrupts><attention min="unknown"><actions><!-- Attack respond if there are weapons --><do_if value="@$attackrespond"><run_script name="'fight.attack.object.vanilla40'"><param name="target" value="$attacker"/><param name="escort" value="this.ship.commander" comment="no error if there is no commander"/><param name="pursuetargets" value="false"/><param name="allowothertargets" value="false"/></run_script></do_if><do_elseif value="@$fleerespond"><debug_text text="'$fleerespond, this class %1, attacker %2'.[this.ship.class, $attacker.class]" chance="$debugoutputchance"/><!-- Flee --><do_if value="this.defensible.isclass.[class.ship_m, class.ship_s]"><do_any><set_value name="$flee" exact="'boost'" weight="20"/><set_value name="$flee" exact="'maneuver'" weight="20"/><set_value name="$flee" exact="'highway'" weight="30"/><set_value name="$flee" exact="'dock'" weight="30"/></do_any></do_if><do_elseif value="this.defensible.isclass.[class.ship_l, class.ship_xl]"><do_any><set_value name="$flee" exact="'jump'" weight="20"/><set_value name="$flee" exact="'boost'" weight="80"/></do_any></do_elseif><!-- If there is a flee option --><do_if value="$flee?"><debug_text text="'%4: flee with %1. Hull %2/Shield %3'.[$flee, this.ship.hullpercentage, this.ship.shieldpercentage, player.age]" chance="$debugoutputchance"/><run_script name="'move.flee.vanilla40'" sinceversion="1" result="$success"><param name="method" value="$flee"/><param name="attacker" value="$attacker"/><param name="debugchance" value="$debugoutputchance"/></run_script><debug_text text="'%1: flee %2 succesful %3. Hull %4/Shield %5'.[player.age, $flee, $success, this.ship.hullpercentage, this.ship.shieldpercentage]" chance="$debugoutputchance"/></do_if></do_elseif></actions></attention></aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="interrupt.scanned.vanilla40" priority="9" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="scanner" default="null" />
  </params>
  <interrupts>
    <library>
      <handler name="ScannedHandler.vanilla40">
        <conditions>
          <event_scan_finished scanned="this.defensible" />
        </conditions>
        <actions>
          <!--<debug_text text="'%1(%2) has been scanned by %3(%4)'.[this.ship.knownname, this.ship, event.param.knownname, event.param]" />-->
          <do_if value="not global.$last_npc_notification?">
            <set_value name="global.$last_npc_notification" exact="0s"/>
          </do_if>
          <do_if value="event.param" exact="player.primaryship">

            <set_value name="$Speak" exact="false"/>
            <set_value name="$Speak_Line" exact="0"/>

            <!--Only say something if no one has said anything for a few seconds-->
            <do_if value="global.$last_npc_notification" max="player.age - 20s">
              <set_value name="$Speak" exact="this.page != 0"/>
            </do_if>

            <!--
            <t id="21">(ship scanned - complicit)Scan away.</t>
            <t id="22">(ship scanned - neutral)What are you scanning me for?</t>
            <t id="23">(ship scanned - illegal)Oi! You can't scan me!</t>
            <t id="24">(ship scanned - enemy)You think you can scan me and get away with it?!</t>
            <t id="25">(ship scanned - confident)I don't think you'll find anything in there.</t>
            <t id="26">(ship scanned - possessing)Err, I have a permit for that, somewhere.</t>            
            -->

            <do_if value="this.hasrelation.enemy.{event.param}">
              <set_value name="$Speak_Line" list="[24] "/>
            </do_if>
            <do_elseif value="event.param.maxlegalscanlevel.{this.ship}" min="this.ship.scannedlevel">
              <do_if value="@this.inventory.illegalto.{this.zone.owner} or @this.ship.cargo.illegalto.{this.zone.owner}">
                <set_value name="$Speak_Line" list="[26] "/>
              </do_if>
              <do_else>
                <set_value name="$Speak_Line" list="[21, 22, 25] "/>
              </do_else>
            </do_elseif>
            <do_else>
              <set_value name="$Speak_Line" list="[23] "/>
            </do_else>

            <do_if value="$Speak">
              <do_if value="$Speak_Line">
                <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="$Speak_Line" />
                <set_value name="global.$last_npc_notification" exact="player.age"/>
              </do_if>
            </do_if>

            <!--cleanup -->
            <remove_value name="$Speak"/>
            <remove_value name="$Speak_Line"/>

          </do_if>
        </actions>

      </handler>
    </library>
  </interrupts>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="interrupt.stoporder.vanilla40" priority="90" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="2">
  <!--  Interrupt handler to Stop a current order, of a player ship
        Author: Adrian
  -->
  <params>
    <param name="prevcommand" default="null" />
    <param name="debugoutputchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <!-- Clean all the actions -->
      <set_value name="this.$ship_parking" exact="true" />

      <abort_jump object="this.ship" />
      <remove_actor_account actor="this" transfer="true" />
      <stop_moving object="this.ship" immediate="false" />
      
      <cease_fire object="this.ship" />
      <!-- If defence NPC (capital ship), send a stop attack signal -->
      <do_if value="this.ship.defencenpc">
        <signal_objects object="this.ship.defencenpc" param="'stop attack'" />
      </do_if>

      <!-- If player clear the shopping list -->
      <debug_text text="'clearing shopping list'" chance="$debugoutputchance" />
      <get_trade_from_shoppinglist object="this.ship" multiple="true" result="$shoppinglist" />

      <do_all exact="$shoppinglist.count" counter="$i" reverse="true">
        <do_if value="@$shoppinglist.{$i}.buyer.isoperational and @$shoppinglist.{$i}.seller.isoperational">
          <debug_text text="'skipping trade: ' + $shoppinglist.{$i} + ' as both buyer and seller are valid and the trade is in progress.'" />
        </do_if>
        <do_else>
          <!-- we need to clean up our ware reservations -->
          <do_if value="@$shoppinglist.{$i}.buyer.isoperational">
            <remove_ware_reservation object="$shoppinglist.{$i}.buyer" type="sell" entity="this" amount="$shoppinglist.{$i}.amount" virtual="$shoppinglist.{$i}.unbundle" mission="$shoppinglist.{$i}.ismission"/>
          </do_if>
          <do_elseif value="@$shoppinglist.{$i}.seller.isoperational">
            <remove_ware_reservation object="$shoppinglist.{$i}.seller" type="buy" entity="this" amount="$shoppinglist.{$i}.amount" virtual="$shoppinglist.{$i}.rebundle" mission="$shoppinglist.{$i}.ismission"/>
          </do_elseif>
          <remove_trade_order object="this.ship" trade="$shoppinglist.{$i}" />
        </do_else>
      </do_all>

      <!-- Return drones -->
      <run_script name="'lib.recall.drones.vanilla40'" sinceversion="1">
        <param name="timeout" value="-1s" comment="skip the waiting time (does not force them to return)" />
      </run_script>

      <!-- Move to a safe position if neccesary -->
      <get_safe_pos object="this.ship" zone="this.ship.zone" radius="this.ship.size/2" result="$thissafepos" ignored="this.ship" />

      <do_if value="this.ship.distanceto.{$thissafepos} gt this.ship.size/2">
        <!-- Better safe position (in front) -->
        <get_safe_pos object="this.ship" zone="this.ship.zone" radius="this.ship.size/2" result="$safepos" directionobject="this.ship" direction="quadrant.front" ignored="this.ship" />

        <move_to object="this.ship" destination="this.zone" finishonapproach="true" usehighways="false" forceposition="false">
          <position value="$safepos" />
          <interrupt_after_time time="0s" />
        </move_to>

      </do_if>
      <do_else>
        <move_to object="this.ship" destination="this.zone" usehighways="false" forceposition="false" forcerotation="true" sinceversion="2">
          <position object="this.ship" />
          <rotation pitch="0deg" yaw="this.ship.rotation.yaw" />
          <interrupt_after_time time="0s" />
        </move_to>
      </do_else>

      <!-- Remove blackboard variable to check if is in the middle of parking -->
      <remove_value name="this.$ship_parking" />

    </actions>
  </attention>
  <on_abort>
    <!-- Remove blackboard variable to check if is in the middle of parking -->
    <remove_value name="this.$ship_parking" />
  </on_abort>
  </aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="interrupt.targetinvalid.vanilla40" priority="10" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--  Interrupt handler for target in moveto action (or similar) that disappears for different reasons: jump, go into highway, after savegame, ...
        Author: Adrian
  -->
  <interrupts>
    <library>
      <handler name="TargetInvalidHandler.vanilla40">
        <conditions>
          <event_object_target_invalid object="this.ship" />
        </conditions>
        <actions>
          <!-- Debug messages (deactivated) -->
          <set_value name="$dbg_target" exact="event.param" chance="0"/>
          <debug_text text="'event TARGET INVALID. param: %1'.[@$dbg_target.knownname]" chance="0" />
          <debug_text text="' this ship %1(%2) in %3(%4). The target: %5(%6)'.[this.ship.knownname, this.ship, this.ship.zone.knownname, this.ship.zone, @$dbg_target.knownname, @$dbg_target]" chance="0"  />

          <abort_called_scripts />
        </actions>
      </handler>
    </library>
  </interrupts>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="interrupt.unbundletrade.vanilla40" priority="7" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <interrupts>
    
    <!-- HANDLER IS DEPRECATED - RELEVANT SCRIPTS USE <schedule_supply_update/> instead -->
    
    <library>
      <handler name="UnbundleTradeHandler.vanilla40">
        <conditions>
          <event_trade_order_completed buyer="this.station" />
        </conditions>
        <actions>
          <!-- actions are delayed by one frame, if frame takes too long this can fail -->
          <do_if value="@event.param.unbundle">
            <run_interrupt_script name="'lib.ammo.station.vanilla40'">
              <param name="incomingware" value="event.param.ware"/>
              <param name="incomingamount" value="event.param.transferredamount"/>
            </run_interrupt_script>
          </do_if>
        </actions>
      </handler>
    </library>
  </interrupts>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="lib.ammo.bombs.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="object" default="null" />
    <param name="configentity" default="null" />
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>
      
      <!-- NOT IMPLEMENTED -->

      <do_if value="not $object.exists">
        <set_value name="$object" exact="this.defensible" />
      </do_if>

      <create_list name="$order_macrolist" />
      <create_list name="$order_warelist" />
      <create_list name="$order_pricelist" />
      <create_list name="$order_amountlist" />

      <do_if value="$object.ammostorage.bomb.count lt $object.ammostorage.bomb.capacity">
        <evaluate_ammo_storage object="$object" type="bomb" capacity="$launchercapacity" macros="$macrolist" amounts="$amountlist" wares="$warelist" />

        <do_if value="($launchercapacity gt 0) and ($macrolist.count gt 0)">

          <!-- now figure out how to distribute the amounts -->
          <do_all exact="$warelist.count" counter="$i">
            <set_value name="$ware" exact="$warelist.{$i}" />
            <set_value name="$macro" exact="$macrolist.{$i}" />

            <set_value name="$capacityfactor" exact="($amountlist.{$i})f / $launchercapacity" />
            <do_if value="$configentity.isoperational">
              <do_if value="$configentity.$config_bombstorage_macros? and $configentity.$config_bombstorage_amounts?">
                <set_value name="$macroindex" exact="@$configentity.$config_bombstorage_macros.indexof.{$macro}" />
                <do_if value="$macroindex gt 0">
                  <set_value name="$capacityfactor" exact="@$configentity.$config_bombstorage_amounts.{$macroindex}" />
                </do_if>
                <do_else>
                  <!-- fallback -->
                  <set_value name="$capacityfactor" exact="1.0f / $macrolist.count" />
                </do_else>
              </do_if>
            </do_if>
            <set_value name="$wantamount" exact="$capacityfactor * ($object.ammostorage.bomb.basecapacity + $launchercapacity)" />
            <do_if value="$wantamount gt 0">
              <get_ware_reservation result="$reservedamount" type="sell" virtual="true" ware="$ware" mission="false" object="$object" />
              <set_value name="$haveamount" exact="$object.ammostorage.{$macro}.count" />
              <set_value name="$needamount" exact="$wantamount - $haveamount - $reservedamount" />
              <set_value name="$fillpercent" exact="($haveamount)f / $wantamount" />
              <do_if value="$fillpercent gt 1.0f">
                <set_value name="$fillpercent" exact="1.0f" />
              </do_if>
              <do_if value="$fillpercent lt 0.7f">
                <!-- use the average price as the lower end to make sure the offers are attractive -->
                <set_value name="$price" exact="$ware.averageprice + (($ware.maxprice - $ware.averageprice)f * (1.0f - $fillpercent))" />
                <debug_text text="'need %1 %2 for %3Cr each, fillpercent: %4'.[$needamount, $ware.name, $price/1Cr, $fillpercent]" chance="$debugchance" />

                <append_to_list name="$order_macrolist" exact="$macro" />
                <append_to_list name="$order_warelist" exact="$ware" />
                <append_to_list name="$order_pricelist" exact="$price" />
                <append_to_list name="$order_amountlist" exact="$needamount" />
              </do_if>
            </do_if>
          </do_all>
        </do_if>

      </do_if>

      <return value="$order_macrolist.count gt 0">
        <retval name="macros" value="$order_macrolist" />
        <retval name="wares" value="$order_warelist" />
        <retval name="prices" value="$order_pricelist" />
        <retval name="amounts" value="$order_amountlist" />
      </return>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="lib.ammo.configupdate.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="1" version="1">
  <params>

    <param name="configentity" default="null" />
    <param name="incomingware" default="null" />
    <param name="incomingamount" default="0" />
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <do_if value="not $configentity">
        <set_value name="$configentity" exact="this"/>
      </do_if>

      <!-- parse config to reduce wanted amounts for one-time orders (player only) -->
      <do_if value="$incomingware and $incomingamount != 0">
        <set_value name="$macro" exact="$incomingware.objectmacro"/>
        <do_if value="$macro">
          <!-- check if automatic re-supply of this type is OFF -->
          <do_if value="$macro.isclass.missile and (not @$configentity.$config_supply_automatic_missiles)">
            <set_value name="$update_config_amounts" exact="true"/>
          </do_if>
          <do_elseif value="$macro.unitcategory == unitcategory.transport and (not @$configentity.$config_supply_automatic_units_trade)">
            <set_value name="$update_config_amounts" exact="true"/>
          </do_elseif>
          <do_elseif value="$macro.unitcategory == unitcategory.defence and (not @$configentity.$config_supply_automatic_units_defence)">
            <set_value name="$update_config_amounts" exact="true"/>
          </do_elseif>
          <do_if value="@$update_config_amounts">
            <!-- only update amounts if automatic handling for this type is OFF -->
            <remove_value name="$update_config_amounts"/>
            <set_value name="$macroindex" exact="@$configentity.$config_supply_macros.indexof.{$macro}"/>
            <do_if value="$macroindex gt 0">
              <set_value name="$configentity.$config_supply_amounts.{$macroindex}" exact="$incomingamount" operation="subtract"/>
              <debug_text text="'updating one-time order for %1(%2). %3 items still wanted.'.[$incomingware, $macro, $configentity.$config_supply_amounts.{$macroindex}]" chance="$debugchance"/>
              <do_if value="$configentity.$config_supply_amounts.{$macroindex} le 0">
                <debug_text text="'one-time order for %1(%2) has been fulfilled, removing order'.[$incomingware, $macro]" chance="$debugchance"/>
                <remove_value name="$configentity.$config_supply_macros.{$macroindex}"/>
                <remove_value name="$configentity.$config_supply_amounts.{$macroindex}"/>
              </do_if>
            </do_if>
          </do_if>
        </do_if>
      </do_if>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="lib.ammo.drones.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="1">
  <params>
    <param name="object" default="null" />
    <param name="configentity" default="null" />
    <param name="order_macrolist" default="null" />
    <param name="order_warelist" default="null" />
    <param name="order_pricelist" default="null" />
    <param name="order_amountlist" default="null" />
    <param name="raw_warelist" default="null" />
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <do_if value="not $object.exists">
        <set_value name="$object" exact="this.defensible" />
      </do_if>

      <do_if value="$object.isclass.station and not $object.tradenpc.exists">
        <!-- since the manager is required for the trade logic of stations, nothing happens without one -->
        <return value="false"/>
      </do_if>

      <!-- in case the lists have not been passed in, set them up now -->
      <do_if value="not $order_macrolist">
        <create_list name="$order_macrolist" />
      </do_if>
      <do_if value="not $order_warelist">
        <create_list name="$order_warelist" />
      </do_if>
      <do_if value="not $order_pricelist">
        <create_list name="$order_pricelist" />
      </do_if>
      <do_if value="not $order_amountlist">
        <create_list name="$order_amountlist" />
      </do_if>
      <do_if value="not $raw_warelist">
        <create_list name="$raw_warelist" />
      </do_if>

      <set_value name="$isplayerowned" exact="$object.isplayerowned"/>
      <set_value name="$unitcapacity" exact="$object.units.maxcount" />
      <set_value name="$actualcapacity" exact="$unitcapacity"/>
      <set_value name="$usedunits" exact="$object.units.count"/>
      <set_value name="$categorylist" exact="[unitcategory.transport, unitcategory.welder, unitcategory.defence]" />

      <!-- build raw warelist, raw_macrolist and default data set based on distribution rules -->
      <create_list name="$raw_macrolist"/>
      <do_all exact="$categorylist.count" counter="$c">
        <set_value name="$category" exact="$categorylist.{$c}" />
        <set_value name="$maxmk" exact="$category.maxmk" />
        <do_all exact="$maxmk" counter="$mk">
          <!-- we stick to the first possible macro for the chosen unitcategory and mk for now -->
          <set_value name="$macro" exact="@$category.mk.{$mk}.list.{1}"/>
          <do_if value="$macro">
            <do_if value="$raw_macrolist.indexof.{$macro} == 0">
              <append_to_list name="$raw_macrolist" exact="$macro" />
            </do_if>
            <!-- make sure the respective ware is in the raw list -->
            <set_value name="$ware" exact="$macro.ware"/>
            <do_if value="$ware and $raw_warelist.indexof.{$ware} == 0">
              <append_to_list name="$raw_warelist" exact="$ware" />
            </do_if>
          </do_if>
        </do_all>
      </do_all>

      <do_if value="$unitcapacity gt 0">

        <!-- build default data set based on distribution rules -->
        <create_list name="$default_macros"/>
        <create_list name="$default_amounts"/>
        <set_value name="$defaultcapacity" exact="0"/>
        <evaluate_unit_storage object="$object" categories="$defaultcategories" mks="$defaultmks" amounts="$defaultamounts" macros="$defaultmacros" />

        <do_all exact="$defaultmacros.count" counter="$m">
          <set_value name="$category" exact="$defaultcategories.{$m}" />
          <do_if value="$categorylist.indexof.{$category} == 0">
            <!-- if the defaults reserve some space for a unit type that we are not interested in (e.g. unitcategory.police), subtract that from the available amounts -->
            <set_value name="$actualcapacity" exact="$defaultamounts.{$m}" operation="subtract"/>
            <set_value name="$usedunits" exact="$object.units.count - $object.units.{$category}.count"/>
            <continue />
          </do_if>
          <set_value name="$macro" exact="$defaultmacros.{$m}" />
          <set_value name="$amount" exact="$defaultamounts.{$m}" />
          <!-- only use the defaults if it's an NPC station OR automatic supply is on for this type -->
          <do_if value="(not $isplayerowned) or ($category == unitcategory.transport and @$configentity.$config_supply_automatic_units_trade) or ($category == unitcategory.defence and @$configentity.$config_supply_automatic_units_defence)">
            <!-- if we have a default distribution defined for this unitcategory and mk then add it to the default dataset (we will deal with rounding issues later) -->
            <do_if value="$macro">
              <append_to_list name="$default_macros" exact="$macro"/>
              <append_to_list name="$default_amounts" exact="$amount"/>
              <set_value name="$defaultcapacity" exact="$amount" operation="add"/>
            </do_if>
          </do_if>
        </do_all>

        <!--
        <do_if value="$debugchance gt 0">
          <do_all exact="$default_macros.count" counter="$m">
            <debug_text text="'default: %1 of macro %2'.[$default_amounts.{$m}, $default_macros.{$m}]" />
          </do_all>
        </do_if>
        -->

        <create_list name="$want_macrolist"/>
        <create_list name="$want_amountlist"/>

        <!-- process manually configured amounts -->
        <set_value name="$usablecapacity" exact="$actualcapacity"/>
        <do_if value="$isplayerowned and @$configentity.$config_supply_macros.count">
          <set_value name="$config_macros" exact="$configentity.$config_supply_macros"/>
          <set_value name="$config_amounts" exact="$configentity.$config_supply_amounts"/>
          <do_all exact="$raw_macrolist.count" counter="$c">
            <set_value name="$macro" exact="$raw_macrolist.{$c}"/>
            <do_if value="$macro">
              <set_value name="$configindex" exact="$config_macros.indexof.{$macro}"/>
              <do_if value="$configindex gt 0">
                <set_value name="$amount" exact="$config_amounts.{$configindex}"/>
                <!-- add configured supply items to order-list -->
                <append_to_list name="$want_macrolist" exact="$macro"/>
                <append_to_list name="$want_amountlist" exact="$amount"/>
                <!-- reduce usable capacity by the defined amount -->
                <set_value name="$usablecapacity" exact="$amount" operation="subtract"/>
                <!-- take manually configured supply out of default list -->
                <set_value name="$defaultindex" exact="$default_macros.indexof.{$macro}"/>
                <do_if value="$defaultindex gt 0">
                  <remove_value name="$default_macros.{$defaultindex}"/>
                  <remove_value name="$default_amounts.{$defaultindex}"/>
                </do_if>
              </do_if>
            </do_if>
          </do_all>
        </do_if>

        <do_if value="($usablecapacity gt 0) and ($defaultcapacity gt 0)">
          <!-- now add what is left in the defaults to our want lists-->
          <set_value name="$fraction" exact="[($usablecapacity)f / $defaultcapacity, 1.0f].min"/>
          <do_all exact="$default_macros.count" counter="$d">
            <set_value name="$amount" exact="($default_amounts.{$d} * $fraction)i"/>
            <do_if value="$amount gt 0">
              <append_to_list name="$want_macrolist" exact="$default_macros.{$d}"/>
              <append_to_list name="$want_amountlist" exact="$amount"/>
              <set_value name="$usablecapacity" exact="$amount" operation="subtract"/>
            </do_if>
          </do_all>
        </do_if>

        <do_if value="(not $isplayerowned) and ($usablecapacity gt 0) and ($want_macrolist.count gt 0)">
          <!-- for NPC stations we distribute the remaining amount over the want-list -->
          <set_value name="$permacroamount" exact="$usablecapacity / $want_macrolist.count"/>
          <set_value name="$extra" exact="$usablecapacity % $want_macrolist.count"/>
          <do_all exact="$want_macrolist.count" counter="$w">
            <do_if value="$usablecapacity gt 0">
              <set_value name="$want_amountlist.{$w}" exact="$permacroamount" operation="add"/>
              <set_value name="$usablecapacity" exact="$permacroamount" operation="subtract"/>
              <do_if value="$extra gt 0">
                <set_value name="$want_amountlist.{$w}" operation="add"/>
                <set_value name="$usablecapacity" operation="subtract"/>
                <set_value name="$extra" operation="subtract"/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>

        <do_if value="$isplayerowned and $object.isclass.station and $configentity.exists">
          <!-- for player stations we store the want-list back to the blackboard of the manager so the menus can display the data -->
          <do_if value="$configentity.$config_supply_default_macros?">
            <!-- can't directly set the value as that might overwrite data from lib.ammo.missiles -->
            <do_all exact="$want_macrolist.count" counter="$m">
              <set_value name="$macroindex" exact="@$configentity.$config_supply_default_macros.indexof.{$want_macrolist.{$m}}"/>
              <do_if value="$macroindex gt 0">
                <!-- update existing entry -->
                <set_value name="$configentity.$config_supply_default_amounts.{$macroindex}" exact="$want_amountlist.{$m}"/>
              </do_if>
              <do_else>
                <!-- add new entry -->
                <append_to_list name="$configentity.$config_supply_default_macros" exact="$want_macrolist.{$m}"/>
                <append_to_list name="$configentity.$config_supply_default_amounts" exact="$want_amountlist.{$m}"/>
              </do_else>
            </do_all>
          </do_if>
          <do_else>
            <!-- fresh new list -->
            <set_value name="$configentity.$config_supply_default_macros" exact="$want_macrolist"/>
            <set_value name="$configentity.$config_supply_default_amounts" exact="$want_amountlist"/>
          </do_else>
        </do_if>

        <do_if value="$debugchance gt 0">
          <do_all exact="$want_macrolist.count" counter="$m">
            <set_value name="$macro" exact="$want_macrolist.{$m}"/>
            <do_if value="$isplayerowned and (($macro.unitcategory == unitcategory.transport and not @$configentity.$config_supply_automatic_units_trade) or ($macro.unitcategory == unitcategory.defence and not @$configentity.$config_supply_automatic_units_defence))">
              <debug_text text="'want %1(RELATIVE) of macro %2'.[$want_amountlist.{$m}, $macro]" />
            </do_if>
            <do_else>
              <debug_text text="'want %1(ABSOLUTE) of macro %2'.[$want_amountlist.{$m}, $macro]" />
            </do_else>
          </do_all>
        </do_if>

        <debug_text text="'used units: %1, usable capacity: %2, wanted macros: %3'.[$usedunits, $actualcapacity, $want_macrolist]" chance="$debugchance" />

        <!-- now figure out how to distribute the amounts -->
        <do_all exact="$want_macrolist.count" counter="$w">
          <set_value name="$macro" exact="$want_macrolist.{$w}"/>
          <set_value name="$wantamount" exact="$want_amountlist.{$w}"/>
          <set_value name="$haveamount" exact="$object.units.{$macro}.count" />
          <do_if value="$isplayerowned and (($macro.unitcategory == unitcategory.transport and not @$configentity.$config_supply_automatic_units_trade) or ($macro.unitcategory == unitcategory.defence and not @$configentity.$config_supply_automatic_units_defence))">
            <!-- player owned and automatic handling is OFF, that means wanted amounts are RELATIVE -->
            <do_if value="$wantamount gt 0">
              <!-- buy wantamount -->
              <set_value name="$needamount" exact="[$wantamount, $actualcapacity - $usedunits].min" />
            </do_if>
            <do_else>
              <!-- sell wantamount -->
              <set_value name="$needamount" exact="[$wantamount, -$object.units.{$macro}.count].max" />
            </do_else>
          </do_if>
          <do_else>
            <!-- wanted amounts are ABSOLUTE -->
            <do_if value="$wantamount gt $haveamount">
              <!-- buy difference -->
              <set_value name="$needamount" exact="[$wantamount - $haveamount, $actualcapacity - $usedunits].min" />
            </do_if>
            <do_else>
              <!-- sell difference -->
              <set_value name="$needamount" exact="[$wantamount - $haveamount, -$object.units.{$macro}.count].max" />
            </do_else>
          </do_else>
          <set_value name="$ware" exact="$macro.ware"/>
          <do_if value="$ware">
            <do_if value="$wantamount != 0">
              <set_value name="$fillpercent" exact="[0.0f, [($haveamount)f / $wantamount, 2.0f].min].max" comment="clamp fillpercent between 0 and 2 or the price calculations will be off!" />
            </do_if>
            <do_else>
              <set_value name="$fillpercent" exact="0.0f" />
            </do_else>
            <do_if value="$needamount lt 0">
              <!-- if automatic handling is OFF, then try to sell excess units-->
              <do_if value="not $isplayerowned or (($macro.unitcategory == unitcategory.transport and not @$configentity.$config_supply_automatic_units_trade) or ($macro.unitcategory == unitcategory.defence and not @$configentity.$config_supply_automatic_units_defence))">
                <!-- use the average price for selling units -->
                <set_value name="$price" exact="$ware.averageprice - (($ware.averageprice - $ware.minprice)f * ($fillpercent - 1.0f))" />
                <debug_text text="'sell %1 %2 for %3Cr each, fillpercent: %4'.[-$needamount, $ware.name, $price/1Cr, $fillpercent]" chance="$debugchance" />

                <append_to_list name="$order_macrolist" exact="$macro" />
                <append_to_list name="$order_warelist" exact="$ware" />
                <append_to_list name="$order_pricelist" exact="$price" />
                <append_to_list name="$order_amountlist" exact="$needamount" />
              </do_if>
            </do_if>
            <do_elseif value="$needamount gt 0">
              <do_if value="($fillpercent lt 0.7f) or $isplayerowned">
                <!-- use the average price as the lower end to make sure the offers are attractive -->
                <set_value name="$price" exact="$ware.averageprice + (($ware.maxprice - $ware.averageprice)f * (1.0f - $fillpercent))" />
                <append_to_list name="$order_macrolist" exact="$macro" />
                <append_to_list name="$order_warelist" exact="$ware" />
                <append_to_list name="$order_pricelist" exact="$price" />
                <append_to_list name="$order_amountlist" exact="$needamount" />
                <set_value name="$usedunits" exact="$needamount" operation="add"/>
              </do_if>
            </do_elseif>
          </do_if>
        </do_all>
      </do_if>

      <return value="$order_macrolist.count gt 0">
        <retval name="macros" value="$order_macrolist" />
        <retval name="wares" value="$order_warelist" />
        <retval name="prices" value="$order_pricelist" />
        <retval name="amounts" value="$order_amountlist" />
        <retval name="raw_wares" value="$raw_warelist" />
      </return>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="lib.ammo.missiles.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="1">
  <params>
    <param name="object" default="null" />
    <param name="configentity" default="null" />
    <param name="order_macrolist" default="null" />
    <param name="order_warelist" default="null" />
    <param name="order_pricelist" default="null" />
    <param name="order_amountlist" default="null" />
    <param name="raw_warelist" default="null" />
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <do_if value="not $object.exists">
        <set_value name="$object" exact="this.defensible" />
      </do_if>

      <do_if value="$object.isclass.station and not $object.tradenpc.exists">
        <!-- since the manager is required for the trade logic of stations, nothing happens without one -->
        <return value="false"/>
      </do_if>

      <do_if value="not $order_macrolist">
        <create_list name="$order_macrolist" />
      </do_if>
      <do_if value="not $order_warelist">
        <create_list name="$order_warelist" />
      </do_if>
      <do_if value="not $order_pricelist">
        <create_list name="$order_pricelist" />
      </do_if>
      <do_if value="not $order_amountlist">
        <create_list name="$order_amountlist" />
      </do_if>
      <do_if value="not $raw_warelist">
        <create_list name="$raw_warelist" />
      </do_if>

      <evaluate_ammo_storage object="$object" type="missile" capacity="$launchercapacity" macros="$macrolist" amounts="$amountlist" wares="$warelist" />
      <set_value name="$isplayerowned" exact="$object.isplayerowned"/>
      <set_value name="$missilecapacity" exact="$object.ammostorage.missile.capacity"/>

      <!-- build default data set based on distribution rules -->
      <create_list name="$default_macros"/>
      <create_list name="$default_amounts"/>
      <set_value name="$defaultcapacity" exact="0"/>
      <do_if value="$missilecapacity gt 0">
        <do_all exact="$macrolist.count" counter="$m">
          <set_value name="$macro" exact="$macrolist.{$m}"/>
          <!-- only use the defaults if it's an NPC station OR automatic supply is on for missiles -->
          <do_if value="(not $isplayerowned) or @$configentity.$config_supply_automatic_missiles">
            <do_if value="$launchercapacity gt 0">
              <set_value name="$capacityfactor" exact="($amountlist.{$m})f / $launchercapacity" />
              <set_value name="$amount" exact="$missilecapacity * $capacityfactor"/>
            </do_if>
            <do_else>
              <set_value name="$amount" exact="$missilecapacity / $macrolist.count"/>
            </do_else>
            <do_if value="$amount gt 0">
              <append_to_list name="$default_macros" exact="$macro"/>
              <append_to_list name="$default_amounts" exact="$amount"/>
              <set_value name="$defaultcapacity" exact="$amount" operation="add"/>
            </do_if>
          </do_if>
        </do_all>
      </do_if>

      <create_list name="$want_macrolist"/>
      <create_list name="$want_amountlist"/>

      <!-- process manually configured amounts -->
      <set_value name="$usablecapacity" exact="$missilecapacity"/>
      <do_if value="$isplayerowned and @$configentity.$config_supply_macros.count">
        <set_value name="$config_macros" exact="$configentity.$config_supply_macros"/>
        <set_value name="$config_amounts" exact="$configentity.$config_supply_amounts"/>
        <do_all exact="$macrolist.count" counter="$m">
          <set_value name="$macro" exact="$macrolist.{$m}"/>
          <set_value name="$configindex" exact="$config_macros.indexof.{$macro}"/>
          <do_if value="$configindex gt 0">
            <set_value name="$amount" exact="$config_amounts.{$configindex}"/>
            <!-- add configured supply items to order-list -->
            <append_to_list name="$want_macrolist" exact="$macro"/>
            <append_to_list name="$want_amountlist" exact="$amount"/>
            <!-- reduce usable capacity by the defined amount -->
            <set_value name="$usablecapacity" exact="$amount" operation="subtract"/>
            <!-- take manually configured supply out of default list -->
            <set_value name="$defaultindex" exact="$default_macros.indexof.{$macro}"/>
            <do_if value="$defaultindex gt 0">
              <remove_value name="$default_macros.{$defaultindex}"/>
              <remove_value name="$default_amounts.{$defaultindex}"/>
            </do_if>
          </do_if>
        </do_all>
      </do_if>

      <do_if value="($usablecapacity gt 0) and ($defaultcapacity gt 0)">
        <!-- now add what is left in the defaults to our want lists-->
        <set_value name="$fraction" exact="[($usablecapacity)f / $defaultcapacity, 1.0f].min"/>
        <do_all exact="$default_macros.count" counter="$d">
          <set_value name="$amount" exact="($default_amounts.{$d} * $fraction)i"/>
          <do_if value="$amount gt 0">
            <append_to_list name="$want_macrolist" exact="$default_macros.{$d}"/>
            <append_to_list name="$want_amountlist" exact="$amount"/>
            <set_value name="$usablecapacity" exact="$amount" operation="subtract"/>
          </do_if>
        </do_all>
      </do_if>

      <do_if value="(not $isplayerowned) and ($usablecapacity gt 0) and ($want_macrolist.count gt 0)">
        <!-- for NPC stations we distribute the remaining amount over the want-list -->
        <set_value name="$permacroamount" exact="$usablecapacity / $want_macrolist.count"/>
        <set_value name="$extra" exact="$usablecapacity % $want_macrolist.count"/>
        <do_all exact="$want_macrolist.count" counter="$w">
          <do_if value="$usablecapacity gt 0">
            <set_value name="$want_amountlist.{$w}" exact="$permacroamount" operation="add"/>
            <set_value name="$usablecapacity" exact="$permacroamount" operation="subtract"/>
            <do_if value="$extra gt 0">
              <set_value name="$want_amountlist.{$w}" operation="add"/>
              <set_value name="$usablecapacity" operation="subtract"/>
              <set_value name="$extra" operation="subtract"/>
            </do_if>
          </do_if>
        </do_all>
      </do_if>

      <do_if value="$isplayerowned and $object.isclass.station and $configentity.exists">
        <!-- for player stations we store the want-list back to the blackboard of the manager so the menus can display the data -->
        <do_if value="$configentity.$config_supply_default_macros?">
          <!-- can't directly set the value as that might overwrite data from lib.ammo.drones -->
          <do_all exact="$want_macrolist.count" counter="$m">
            <set_value name="$macroindex" exact="@$configentity.$config_supply_default_macros.indexof.{$want_macrolist.{$m}}"/>
            <do_if value="$macroindex gt 0">
              <!-- update existing entry -->
              <set_value name="$configentity.$config_supply_default_amounts.{$macroindex}" exact="$want_amountlist.{$m}"/>
            </do_if>
            <do_else>
              <!-- add new entry -->
              <append_to_list name="$configentity.$config_supply_default_macros" exact="$want_macrolist.{$m}"/>
              <append_to_list name="$configentity.$config_supply_default_amounts" exact="$want_amountlist.{$m}"/>
            </do_else>
          </do_all>
        </do_if>
        <do_else>
          <!-- fresh new list -->
          <set_value name="$configentity.$config_supply_default_macros" exact="$want_macrolist"/>
          <set_value name="$configentity.$config_supply_default_amounts" exact="$want_amountlist"/>
        </do_else>
      </do_if>

      <do_if value="$missilecapacity gt 0">

        <do_if value="$object.ammostorage.missile.free gt 0">

          <debug_text text="'used missile capacity: %1, free capacity: %2, wanted macros: %3'.[$object.ammostorage.missile.count, $object.ammostorage.missile.free, $want_macrolist]" chance="$debugchance" />

          <!-- now figure out how to distribute the amounts -->
          <do_all exact="$want_macrolist.count" counter="$w">
            <set_value name="$macro" exact="$want_macrolist.{$w}"/>
            <set_value name="$wantamount" exact="$want_amountlist.{$w}"/>
            <set_value name="$haveamount" exact="$object.units.{$macro}.count" />
            <do_if value="$isplayerowned and not @$configentity.$config_supply_automatic_missiles">
              <!-- player owned and automatic handling is OFF, that means wanted amounts are RELATIVE -->
              <do_if value="$wantamount gt 0">
                <set_value name="$needamount" exact="[$wantamount, $object.ammostorage.missile.free].min" />
              </do_if>
              <do_else>
                <set_value name="$needamount" exact="[$wantamount, -$object.ammostorage.{$macro}.count].max" />
              </do_else>
            </do_if>
            <do_else>
              <!-- wanted amounts are ABSOLUTE -->
              <do_if value="$wantamount gt $haveamount">
                <set_value name="$needamount" exact="[$wantamount - $haveamount, $object.ammostorage.missile.free].min" />
              </do_if>
              <do_else>
                <set_value name="$needamount" exact="[$wantamount - $haveamount, $object.ammostorage.{$macro}.count].max" />
              </do_else>
            </do_else>
            <set_value name="$ware" exact="$macro.ware"/>
            <do_if value="$ware">
              <do_if value="$wantamount != 0">
                <set_value name="$fillpercent" exact="[0.0f, [($haveamount)f / $wantamount, 2.0f].min].max" comment="clamp fillpercent between 0 and 2 or the price calculations will be off!" />
              </do_if>
              <do_else>
                <set_value name="$fillpercent" exact="0.0f" />
              </do_else>
              <do_if value="$needamount lt 0">
                <do_if value="not $isplayerowned or ($isplayerowned and not @$configentity.$config_supply_automatic_missiles)">
                  <!-- if automatic handling is OFF, then try to sell excess units-->
                  <set_value name="$price" exact="$ware.averageprice - (($ware.averageprice - $ware.minprice)f * ($fillpercent - 1.0f))" />
                  <debug_text text="'sell %1 %2 for %3Cr each, fillpercent: %4'.[-$needamount, $ware.name, $price/1Cr, $fillpercent]" chance="$debugchance" />

                  <append_to_list name="$order_macrolist" exact="$macro" />
                  <append_to_list name="$order_warelist" exact="$ware" />
                  <append_to_list name="$order_pricelist" exact="$price" />
                  <append_to_list name="$order_amountlist" exact="$needamount" />
                </do_if>
              </do_if>
              <do_else>
                <do_if value="$fillpercent lt 0.7f or ($isplayerowned and not @$configentity.$config_supply_automatic_missiles)">
                  <!-- use the average price as the lower end to make sure the offers are attractive -->
                  <set_value name="$price" exact="$ware.averageprice + (($ware.maxprice - $ware.averageprice)f * (1.0f - $fillpercent))" />
                  <debug_text text="'order %1 %2 for %3Cr each, fillpercent: %4'.[$needamount, $ware.name, $price/1Cr, $fillpercent]" chance="$debugchance" />

                  <append_to_list name="$order_macrolist" exact="$macro" />
                  <append_to_list name="$order_warelist" exact="$ware" />
                  <append_to_list name="$order_pricelist" exact="$price" />
                  <append_to_list name="$order_amountlist" exact="$needamount" />
                </do_if>
              </do_else>
            </do_if>
          </do_all>
        </do_if>
      </do_if>

      <do_all exact="$warelist.count" counter="$w">
        <do_if value="$raw_warelist.indexof.{$warelist.{$w}} == 0">
          <append_to_list name="$raw_warelist" exact="$warelist.{$w}"/>
        </do_if>
      </do_all>

      <return value="$order_macrolist.count gt 0">
        <retval name="macros" value="$order_macrolist" />
        <retval name="wares" value="$order_warelist" />
        <retval name="prices" value="$order_pricelist" />
        <retval name="amounts" value="$order_amountlist" />
        <retval name="raw_wares" value="$raw_warelist" />
      </return>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="lib.ammo.station.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="1" version="2">
  <params>
    <param name="incomingware" default="null" />
    <param name="incomingamount" default="0" />
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <!--
      <do_if value="this.station.isplayerowned">
        <set_value name="$debugchance" exact="100"/>
      </do_if>
      -->

      <debug_text text="'running station ammo check on %1(%4) in %2(%3)'.[this.station.knownname, this.zone.knownname, this.sector.knownname, this.station]" chance="$debugchance" />

      <set_value name="$nextsupplycheck" min="1min" max="5min" />
      <schedule_supply_update object="this.station" delay="$nextsupplycheck" />
      <remove_value name="$nextsupplycheck"/>

      <find_tradeoffer_parking_slot object="this.station" includeoccupied="true" name="$parkingpossible" check="true"/>
      <do_if value="not $parkingpossible and this.station.isplayerowned">
        <debug_text text="'aborting ammo offer checks on %1(%2) in %3(%4), because this station has no tradeoffer parking slots!'.[this.station.knownname, this.station, this.zone.knownname, this.sector.knownname]" chance="$debugchance" />
        <return />
      </do_if>

      <set_value name="$configentity" exact="this.station.tradenpc" />
      <do_if value="not $configentity">
        <debug_text text="'aborting ammo offer checks on %1(%2) in %3(%4), because there is no trade NPC!'.[this.station.knownname, this.station, this.zone.knownname, this.sector.knownname]" />
        <return />
      </do_if>

      <do_if value="$incomingware and this.station.isplayerowned">
        <!-- parse config to reduce wanted amounts for one-time orders -->
        <run_script name="'lib.ammo.configupdate.vanilla40'" sinceversion="1">
          <param name="configentity" value="$configentity"/>
          <param name="incomingware" value="$incomingware"/>
          <param name="incomingamount" value="$incomingamount"/>
          <param name="debugchance" value="$debugchance"/>
        </run_script>
      </do_if>

      <do_if value="this.station.isplayerowned">
        <set_value name="$configentity.$config_supply_default_macros" exact="[]"/>
        <set_value name="$configentity.$config_supply_default_amounts" exact="[]"/>
      </do_if>

      <create_list name="$order_macrolist" />
      <create_list name="$order_warelist" />
      <create_list name="$order_pricelist" />
      <create_list name="$order_amountlist" />
      <create_list name="$raw_warelist" />

      <run_script name="'lib.ammo.missiles.vanilla40'" result="$needmissiles">
        <param name="configentity" value="$configentity" />
        <param name="order_macrolist" value="$order_macrolist" />
        <param name="order_warelist" value="$order_warelist" />
        <param name="order_pricelist" value="$order_pricelist" />
        <param name="order_amountlist" value="$order_amountlist" />
        <param name="raw_warelist" value="$raw_warelist" />
        <param name="debugchance" value="$debugchance" />
        <save_retval name="macros" variable="$order_macrolist" />
        <save_retval name="wares" variable="$order_warelist" />
        <save_retval name="prices" variable="$order_pricelist" />
        <save_retval name="amounts" variable="$order_amountlist" />
        <save_retval name="raw_wares" variable="$raw_warelist" />
      </run_script>

      <run_script name="'lib.ammo.drones.vanilla40'" result="$needdrones" sinceversion="1">
        <param name="configentity" value="$configentity" />
        <param name="order_macrolist" value="$order_macrolist" />
        <param name="order_warelist" value="$order_warelist" />
        <param name="order_pricelist" value="$order_pricelist" />
        <param name="order_amountlist" value="$order_amountlist" />
        <param name="raw_warelist" value="$raw_warelist" />
        <param name="debugchance" value="$debugchance" />
        <save_retval name="macros" variable="$order_macrolist" />
        <save_retval name="wares" variable="$order_warelist" />
        <save_retval name="prices" variable="$order_pricelist" />
        <save_retval name="amounts" variable="$order_amountlist" />
        <save_retval name="raw_wares" variable="$raw_warelist" />
      </run_script>

      <!-- combine the results of the two subscripts -->
      <set_value name="$needammo" exact="$needmissiles or $needdrones"/>

      <do_if value="$raw_warelist.count == 0">
        <return />
      </do_if>


      <!-- check if we are selling anything, if yes, move the data over to a different list -->
      <create_list name="$sell_macrolist" />
      <create_list name="$sell_warelist" />
      <create_list name="$sell_pricelist" />
      <create_list name="$sell_amountlist" />
      <do_all exact="$order_amountlist.count" counter="$a" reverse="true">
        <set_value name="$amount" exact="$order_amountlist.{$a}" />
        <set_value name="$ware" exact="$order_warelist.{$a}" />
        <set_value name="$macro" exact="$order_macrolist.{$a}" />
        <do_if value="$amount lt 0">
          <set_value name="$sellammo" exact="true" />
          <append_to_list name="$sell_macrolist" exact="$order_macrolist.{$a}"/>
          <append_to_list name="$sell_warelist"  exact="$order_warelist.{$a}"/>
          <append_to_list name="$sell_pricelist"  exact="$order_pricelist.{$a}"/>
          <append_to_list name="$sell_amountlist"  exact="-$order_amountlist.{$a}" comment="NOTE: We ware inverting the sign here!"/>
          <remove_value name="$order_macrolist.{$a}" />
          <remove_value name="$order_warelist.{$a}" />
          <remove_value name="$order_pricelist.{$a}" />
          <remove_value name="$order_amountlist.{$a}" />
        </do_if>
      </do_all>

      <!-- special case for stations that can produce the ammo they need -->
      <find_sell_offer seller="this.station" wares="$raw_warelist" result="$ammooffers" multiple="true" />
      <do_all exact="$ammooffers.count" counter="$i" reverse="true">
        <set_value name="$k" exact="$order_warelist.indexof.{$ammooffers.{$i}.ware}" />
        <do_if value="$k gt 0">
          <set_value name="$amount" exact="$order_amountlist.{$k}" />
          <do_if value="$amount gt 0">
            <do_if value="$amount gt $ammooffers.{$i}.amount">
              <set_value name="$amount" exact="$ammooffers.{$i}.amount" />
            </do_if>
            <do_if value="$order_macrolist.{$k}.isclass.missile">
              <set_value name="$amount" exact="[$amount, this.station.ammostorage.missile.free].min" />
            </do_if>
            <do_elseif value="$order_macrolist.{$k}.isclass.ship_xs">
              <set_value name="$amount" exact="[$amount, this.station.units.free].min" />
            </do_elseif>
            <remove_cargo object="this.station" ware="$order_warelist.{$k}" exact="$amount" result="$amount" />
            <add_ammo object="this.station" macro="$order_macrolist.{$k}" amount="$amount" />
            <do_if value="this.station.isplayerowned">
              <!-- parse config to reduce wanted amounts for one-time orders -->
              <run_script name="'lib.ammo.configupdate.vanilla40'" sinceversion="1">
                <param name="configentity" value="$configentity"/>
                <param name="incomingware" value="$order_warelist.{$k}"/>
                <param name="incomingamount" value="$amount"/>
                <param name="debugchance" value="$debugchance"/>
              </run_script>
            </do_if>
            <set_value name="$order_amountlist.{$k}" exact="$order_amountlist.{$k} - $amount" />
            <do_if value="$order_amountlist.{$k} le 0">
              <remove_value name="$order_amountlist.{$k}" />
              <remove_value name="$order_macrolist.{$k}" />
              <remove_value name="$order_warelist.{$k}" />
              <remove_value name="$order_pricelist.{$k}" />
              <set_value name="$needammo" exact="$order_macrolist.count gt 0" />
            </do_if>
          </do_if>
        </do_if>
      </do_all>
      <remove_value name="$ammooffers" />

      <!-- special case for stations that trade with the ammo they want to sell -->
      <do_if value="@$sellammo">
        <set_value name="$products" exact="this.station.products.list" />
        <set_value name="$tradewares" exact="this.station.tradewares.list" />
        <do_all exact="$tradewares.count" counter="$t">
          <do_if value="$products.indexof.{$tradewares.{$t}} == 0">
            <append_to_list name="$products" exact="$tradewares.{$t}" />
          </do_if>
        </do_all>
        <remove_value name="$tradewares" />
        <do_all exact="$sell_amountlist.count" counter="$a">
          <set_value name="$amount" exact="$sell_amountlist.{$a}" />
          <set_value name="$ware" exact="$sell_warelist.{$a}" />
          <set_value name="$macro" exact="$sell_macrolist.{$a}" />
          <set_value name="$k" exact="$products.indexof.{$ware}" />
          <do_if value="$k gt 0">
            <set_value name="$amount" exact="[$amount, this.station.cargo.{$ware}.count].min" />
            <do_if value="$amount gt 0">
              <add_cargo object="this.station" ware="$ware" exact="$amount" result="$amount" />
              <remove_ammo object="this.station" macro="$macro" amount="$amount" />
              <do_if value="this.station.isplayerowned">
                <!-- parse config to reduce wanted amounts for one-time orders -->
                <run_script name="'lib.ammo.configupdate.vanilla40'" sinceversion="2">
                  <param name="configentity" value="$configentity"/>
                  <param name="incomingware" value="$sell_warelist.{$a}"/>
                  <param name="incomingamount" value="-$amount"/>
                  <param name="debugchance" value="$debugchance"/>
                </run_script>
              </do_if>
              <set_value name="$sell_amountlist.{$a}" exact="$amount" operation="subtract" />
              <do_if value="$sell_amountlist.{$a} le 0">
                <remove_value name="$sell_amountlist.{$a}" />
                <remove_value name="$sell_macrolist.{$a}" />
                <remove_value name="$sell_warelist.{$a}" />
                <remove_value name="$sell_pricelist.{$a}" />
                <set_value name="$sellammo" exact="$sell_macrolist.count gt 0" />
              </do_if>
            </do_if>
          </do_if>
        </do_all>
        <remove_value name="$products" />
      </do_if>

      <!-- we have updated our config and any defaults have been written to the blackboard, tell the UI that the data is ready-->
      <do_if value="this.station.isplayerowned">
        <raise_lua_event name="'supplyUpdate'" param="this.station" />
      </do_if>

      <do_if value="not $parkingpossible and (@$needammo or @$sellammo)">
        <!-- if supply via normal trade operations is not possible, allow cheating for NPC stations (we already aborted for player stations at the top) -->
        <do_if value="player.sector != this.sector" chance="20">
          <debug_text text="'cheating ammo on %1(%2) in %3(%4), because this station has no tradeoffer parking slots.'.[this.station.knownname, this.station, this.zone.knownname, this.sector.knownname]" chance="$debugchance" />
          <do_all exact="$sell_macrolist.count" counter="$m">
            <remove_ammo object="this.station" macro="$sell_macrolist.{$m}" amount="$sell_amountlist.{$m}" />
          </do_all>
          <do_all exact="$order_macrolist.count" counter="$m">
            <add_ammo object="this.station" macro="$order_macrolist.{$m}" amount="$order_amountlist.{$m}" />
          </do_all>
        </do_if>
        <return />
      </do_if>

      <find_buy_offer buyer="this.station" wares="$raw_warelist" result="$ammotrades" excludeempty="false" multiple="true" unbundle="true" />
      <find_sell_offer seller="this.station" wares="$raw_warelist" result="$ammosales" excludeempty="false" multiple="true" rebundle="true" />

      <do_if value="$needammo">
        <!-- check what funds are available first, at the moment it is the manager who has to pay for ammo! -->
        <set_value name="$money" exact="@this.station.tradenpc.money - this.station.productionmoney" />
        <do_if value="$money gt 0">
          <do_if value="$order_warelist.count gt 0">
            <!-- simplification: assume equal share of the available funds for all types of ammo -->
            <set_value name="$money" exact="$money / $order_warelist.count" />
          </do_if>
        </do_if>

        <do_if value="$needammo">
          <!-- if we still need ammo, create offers here -->
          <do_all exact="$order_warelist.count" counter="$i">
            <set_value name="$skipware" exact="false" />
            <set_value name="$orderware" exact="$order_warelist.{$i}" />

            <!-- adjust desiredamount for available space -->
            <do_if value="$order_macrolist.{$i}.isclass.missile">
              <set_value name="$desiredamount" exact="[$order_amountlist.{$i}, this.station.ammostorage.missile.free].min" />
            </do_if>
            <do_elseif value="$order_macrolist.{$i}.isclass.ship_xs">
              <set_value name="$desiredamount" exact="[$order_amountlist.{$i}, this.station.units.free].min" />
            </do_elseif>

            <!-- adjust amount for available funds -->
            <set_value name="$amount" exact="[$desiredamount, $money / $order_pricelist.{$i}].min" />

            <!-- check ware reservations and adjust amounts -->
            <get_ware_reservation result="$reservedamount" type="sell" virtual="true" ware="$orderware" mission="false" object="this.station" />
            <set_value name="$desiredamount" exact="[$desiredamount - $reservedamount, 0].max" />
            <set_value name="$amount" exact="[$amount - $reservedamount, 0].max" />

            <do_if value="$desiredamount gt 0 or $reservedamount gt 0">
              <!-- check existing buyoffers and update -->
              <do_all exact="$ammotrades.count" counter="$j" reverse="true">
                <set_value name="$ammotrade" exact="$ammotrades.{$j}" />
                <do_if value="$ammotrade.ware == $orderware">
                  <do_if value="($amount != $ammotrade.amount) or ($desiredamount != $ammotrade.desiredamount)">
                    <update_trade trade="$ammotrade" amount="$amount" desiredamount="$desiredamount" price="$order_pricelist.{$i}" />
                    <debug_text text="'updating offer %1 on %2(%3), buy %4(desired: %8) %5 at %6Cr each, %7Cr total'.[$ammotrade, this.station.knownname, this.station, $ammotrade.amount, $ammotrade.ware.name, $ammotrade.unitprice/1Cr, $ammotrade.price/1Cr, $desiredamount]" chance="$debugchance" />
                  </do_if>
                  <set_value name="$skipware" exact="true" />
                  <remove_value name="$ammotrades.{$j}" />
                  <break />
                </do_if>
              </do_all>
              <remove_value name="$ammotrade" />
              <do_if value="@$skipware">
                <continue />
              </do_if>

              <create_trade_offer amount="$amount" desiredamount="$desiredamount" buyer="this.station" object="this.station" name="$offer" ware="$orderware" price="$order_pricelist.{$i}" unbundle="true" playeronly="false" />
              <do_if value="$offer">
                <debug_text text="'%1 wants to buy %2(desired: %6) %3 for %4Cr each, %5Cr total'.[$offer.buyer.knownname, $offer.amount, $offer.ware.name, $offer.unitprice/1Cr, $offer.price/1Cr, $desiredamount]" chance="$debugchance" />
              </do_if>
              <remove_value name="$offer" />
            </do_if>
          </do_all>
        </do_if>
      </do_if>

      <do_if value="@$sellammo">
        <do_all exact="$sell_warelist.count" counter="$i">
          <set_value name="$skipware" exact="false" />
          <set_value name="$sellware" exact="$sell_warelist.{$i}" />
          <set_value name="$sellmacro" exact="$sell_macrolist.{$i}" />

          <!-- adjust amount for actually available ammo -->
          <set_value name="$amount" exact="[$sell_amountlist.{$i}, this.station.ammostorage.{$sellmacro}.count].min" />

          <!-- check existing selloffers and update -->
          <do_all exact="$ammosales.count" counter="$j" reverse="true">
            <set_value name="$ammosale" exact="$ammosales.{$j}" />
            <do_if value="$ammosale.ware == $sellware">
              <do_if value="($amount != $ammosale.amount)">
                <update_trade trade="$ammosale" amount="$amount" price="$sell_pricelist.{$i}" />
                <debug_text text="'updating offer %1 on %2(%3), sell %4 %5 at %6Cr each, %7Cr total'.[$ammosale, this.station.knownname, this.station, $ammosale.amount, $ammosale.ware.name, $ammosale.unitprice/1Cr, $ammosale.price/1Cr]" chance="$debugchance" />
              </do_if>
              <set_value name="$skipware" exact="true" />
              <remove_value name="$ammosales.{$j}" />
              <break />
            </do_if>
          </do_all>
          <remove_value name="$ammosale" />
          <do_if value="@$skipware">
            <continue />
          </do_if>

          <create_trade_offer amount="$amount" seller="this.station" object="this.station" name="$offer" ware="$sellware" price="$sell_pricelist.{$i}" rebundle="true" playeronly="false" />
          <do_if value="$offer">
            <debug_text text="'%1 wants to sell %2 %3 for %4Cr each, %5Cr total'.[$offer.seller.knownname, $offer.amount, $offer.ware.name, $offer.unitprice/1Cr, $offer.price/1Cr]" chance="$debugchance" />
          </do_if>
          <remove_value name="$offer" />
        </do_all>
      </do_if>

      <do_all exact="$raw_warelist.count" counter="$i">
        <!-- remove buy offers that are no longer needed -->
        <do_all exact="$ammotrades.count" counter="$j" reverse="true">
          <do_if value="$ammotrades.{$j}.ware == $raw_warelist.{$i}">
            <debug_text text="'removing offer for %1 %2 from %3(%4)'.[$ammotrades.{$j}.amount, $ammotrades.{$j}.ware.name, this.station.knownname, this.station]" chance="$debugchance" />
            <remove_trade_offer object="this.station" tradeoffer="$ammotrades.{$j}" />
            <remove_value name="$ammotrades.{$j}" />
            <break />
          </do_if>
        </do_all>
        <!-- remove sell offers that are no longer needed -->
        <do_all exact="$ammosales.count" counter="$j" reverse="true">
          <do_if value="$ammosales.{$j}.ware == $raw_warelist.{$i}">
            <debug_text text="'removing offer for %1 %2 from %3(%4)'.[$ammosales.{$j}.amount, $ammosales.{$j}.ware.name, this.station.knownname, this.station]" chance="$debugchance" />
            <remove_trade_offer object="this.station" tradeoffer="$ammosales.{$j}" />
            <remove_value name="$ammosales.{$j}" />
            <break />
          </do_if>
        </do_all>
      </do_all>
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="lib.recall.drones.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="5">
  <params>
    <param name="timeout" default="5min" comment="If less than 0, does not force them to return" />
  </params>

  <attention min="unknown">
    <actions>

      <set_command_action commandaction="commandaction.waitingdrones" />
      <add_to_group groupname="$drones" list="this.ship.subordinates" comment="use a group to handle the destruction/dock of drones" />

      <!-- Filter subordinates to get only drones -->
      <do_all exact="$drones.count" counter="$i" reverse="true">
        <do_if value="not $drones.{$i}.isclass.drone">
          <remove_from_group group="$drones" object="$drones.{$i}" />
        </do_if>
      </do_all>

      <do_if value="$drones.count gt 0">
        <do_if value="(this.ship.commander == player.primaryship) and ($drones.{1}.primarypurpose == objectpurpose.mine)">
          <!-- Text line only for mining drones (missing line for fighter drones) -->
          <speak actor="this" line="1203" comment="Recalling collectors" />
        </do_if>
        <!-- Script dock for them -->
        <do_all exact="$drones.count" counter="$i">
          <!-- If is not in command dock or action docking -->
          <do_if value="($drones.{$i}.pilot.command.value != command.dockat) and ($drones.{$i}.pilot.commandaction.value != commandaction.docking)">
            <start_script name="'move.dockat.drone.vanilla40'" object="$drones.{$i}.pilot">
              <param name="destination" value="this.ship" />
            </start_script>
          </do_if>
        </do_all>

        <!-- Only Force drones to dock if there is timeout -->
        <do_if value="$timeout gt 1s">
          <set_value name="$dronedocktimeout" exact="player.age + $timeout" />
          <do_while value="$drones.count and (player.age lt $dronedocktimeout)" comment="use $drones, group is updated">
            <wait min="1s" max="5s" />
          </do_while>

          <find_object_component name="$dronelaunchpad" object="this.ship" class="class.dronelaunchpad" functional="true" />
          <!-- If there is a drone launchpad operational -->
          <do_if value="$dronelaunchpad.isoperational">
            <!-- Add subordinated of drones -->
            <do_all exact="$drones.count" counter="$i">
              <add_to_group groupname="$drones" list="$drones.{$i}.subordinates" />
            </do_all>
            <!-- All drones commander/subordinates -->
            <do_all exact="$drones.count" counter="$i" reverse="true">
              <!-- force-dock drones -->
              <wait min="1s" max="2s" chance="0" comment="unnecessary wait disabled" />
              <!-- this drone could have been destroyed/dock, skip that case -->
              <do_if value="@$drones.{$i}.isoperational">
                <dock_drone homebase="this.ship" object="$drones.{$i}" />
                <wait min="1s" max="2s" />
              </do_if>
            </do_all>
          </do_if>
        </do_if>

      </do_if>

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="lib.units.combat.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <debug_text text="'running combat unit check on %1 in %2(%3)'.[this.container.knownname, this.zone.knownname, this.sector.knownname]" />

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="lib.units.trade.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <debug_text text="'running trade unit check on %1 in %2(%3)'.[this.container.knownname, this.zone.knownname, this.sector.knownname]" />

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="masstraffic.fight.vanilla40" version="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

  Fight Mass Traffic Agent Script
  by Matthias
  
  -->
  <params>
    <param name="target" />
  </params>
  <attention min="visible">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />
      <label name="start" />
      <!--We wait for a short time so that the cache has a chance to populate the children first (otherwise the code can't find any wepaons)-->
      <!--Also, we wait a randomized time so that the shoot times of all units are somewhat distributed-->
      <wait min="1" max="5" />
      <shoot_at object="this.ship" target="$target" slot="tag.primary_slot" tolerance="360.0deg" locktarget="true" largetarget="true" />
      <shoot_at object="this.ship" target="$target" slot="tag.secondary_slot" tolerance="360.0deg" locktarget="true" largetarget="true" />
      <wait>
        <interrupt>
          <conditions>
            <event_object_destroyed object="$target" />
          </conditions>
        </interrupt>
      </wait>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />
      <label name="start" />
      <wait min="5s" max="10s" sinceversion="1" />
      <do_if value="this.ship.exists">
        <debug_text text="'Fight mass traffic ship self-destructs (OOS)'" chance="$debugoutputchance" />
        <destroy_object object="this.ship" explosion="false" />
      </do_if>
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="masstraffic.flee.vanilla40" version="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="9">
  <!--

  Mass Traffic Agent Script for Fleeing
  by Michael
  
  -->
  <interrupts>
    <handler ref="MassTrafficAttackHandler.vanilla40" />
  </interrupts>
  <attention min="visible">
    <actions>

      <set_value name="$debugoutputchance" exact="0" />

      <move_to object="this.ship" destination="this.ship" forcesteering="true">
        <position x="0m" y="0m" z="1km" />
        <interrupt_after_time time="1s" />
      </move_to>
      <find_closest_navmesh_object refobject="this.ship" name="$target">
        <match_distance object="this.ship" max="8km" />
        <match_relation object="this.ship" relation="neutral" comparison="ge"/>
      </find_closest_navmesh_object>
      <set_value name="$lastattacktime" exact="player.age" />
      <do_if value="$target.exists">
        <!-- <debug_text text="'mass traffic agent ' + this.ship.knownname + ' tries to flee to ' + $target.knownname" /> -->
        <do_while value="$target.exists">
          <!-- abort if the player is docked at a platform, no longer chasing us -->
          <do_if value="player.platform.exists">
            <break />
          </do_if>
          <!-- abort after 1min without hostile action -->
          <do_if value="player.age - $lastattacktime" min="20s">
            <break />
          </do_if>
          <!-- abort after being more than 3km away -->
          <do_if value="this.ship.distanceto.{player.primaryship}" min="3km">
            <break />
          </do_if>
          <move_navmesh object="this.ship" destination="$target" flightbehaviour="flightbehaviour.closetoobject" usemasstrafficlane="true" finishonapproach="true" forcesteering="true">
            <interrupt_after_time time="40s" />
            <interrupt>
              <conditions>
                <event_object_attacked object="this.ship" />
              </conditions>
              <actions>
                <set_value name="$lastattacktime" exact="player.age" />
              </actions>
            </interrupt>
          </move_navmesh>
          <wait exact="2s" />
        </do_while>
      </do_if>
      <do_else>
        <debug_text text="'mass traffic agent ' + this.ship.knownname + ' has not found a neutral or friendly station!'" chance="$debugoutputchance" />
        <do_while value="1">
          <!-- abort if the player is docked at a platform, no longer chasing us -->
          <do_if value="player.platform.exists">
            <break />
          </do_if>
          <!-- abort after 1min without hostile action -->
          <do_if value="player.age - $lastattacktime" min="20s">
            <break />
          </do_if>
          <!-- abort after being more than 3km away -->
          <do_if value="this.ship.distanceto.{player.primaryship}" min="3km">
            <break />
          </do_if>
          <move_to object="this.ship" destination="this.zone" flightbehaviour="flightbehaviour.runaway" abortpath="true" finishonapproach="true" forcesteering="true">
            <position object="this.ship" min="5km" max="10km" />
            <interrupt_after_time time="40s" />
            <interrupt>
              <conditions>
                <event_object_attacked object="this.ship" chance="50" />
              </conditions>
            </interrupt>
          </move_to>
          <wait exact="2s" />
        </do_while>
      </do_else>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />
      <wait min="5s" max="10s" sinceversion="1" />
      <do_if value="this.ship.exists">
        <debug_text text="'Generic mass traffic ship self-destructing (OOS)'" chance="$debugoutputchance" />
        <destroy_object object="this.ship" explosion="false" />
      </do_if>
    </actions>
  </attention>
</aiscript>

<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="masstraffic.generic.vanilla40" version="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

  Generic Mass Traffic Agent Script
  by Michael
  
  -->
  <interrupts>
    <handler ref="MassTrafficAttackHandler.vanilla40" />
    <handler ref="MassTrafficScannedHandler.vanilla40" />
	<handler ref="TargetInvalidHandler.vanilla40" />
  </interrupts>
  <attention min="nearby">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />

      <set_value name="this.$lastsignal" exact="0" />

      <label name="start" />

      <!-- Initial stand by command action -->
      <set_command_action commandaction="commandaction.flying" />
      
      <set_value name="$target" exact="null" />
      <wait>
        <interrupt>
          <conditions>
            <check_any>
              <check_all>
                <event_object_signalled object="this.ship" param="'attack'" />
              </check_all>
              <check_all>
                <event_gravidar_has_scanned object="this.ship" />
                <check_value value="player.primaryship" />
                <check_value value="this.ship.distanceto.{player.primaryship}" max="250m" />
                <check_any>
                  <check_value value="this.hasrelation.kill.{player.entity.owner}" />
                  <check_all>
                    <check_value value="this.zone.owner" />
                    <check_value value="this.zone.owner.hasrelation.kill.{player.entity.owner}" />
                    <check_value value="this.hasrelation.friend.{this.zone.owner}" />
                  </check_all>
                </check_any>
              </check_all>
            </check_any>
          </conditions>
          <actions>

            <do_if value="event.name == 'event_object_signalled'">
              <set_value name="$victim" exact="event.param3" />
              <set_value name="$target" exact="event.param2" />
              <do_if value="this.hasrelation.friend.{$victim} and not this.hasrelation.friend.{$target}">
                <do_if value="this.ship.dps.all gt 0f">
                  <resume label="attack" />
                </do_if>
              </do_if>
            </do_if>
            <do_if value="(this.ship.dps.all gt 0f) and (event.name == 'event_gravidar_has_scanned')" chance="50">
              <debug_text text="'attack'" chance="$debugoutputchance" />
              <set_value name="$target" exact="player.primaryship" />
              <resume label="attack" />
            </do_if>
            <do_elseif value="true" chance="70">
              <debug_text text="'evade'" chance="$debugoutputchance" />
              <resume label="evade" />
            </do_elseif>
            <do_else chance="30">
              <debug_text text="'flee'" chance="$debugoutputchance" />
              <resume label="flee" />
            </do_else>
          </actions>
        </interrupt>
      </wait>
      <resume label="start" />

      <label name="attack" />
      <start_attack object="this.ship" target="$target" />
      <add_to_group groupname="$targets" object="$target" />
      <run_script name="'fight.attack.object.fighter.vanilla40'">
        <param name="primarytargets" value="$targets" />
        <param name="allowothertargets" value="false" />
      </run_script>
      <stop_attack object="this.ship" target="$target" />
      <resume label="returntomasstraffic" />

      <label name="flee" />
      <run_script name="'masstraffic.flee.vanilla40'" />
      <resume label="returntomasstraffic" />

      <label name="evade" />
      <find_pos_in_mass_traffic_at_time name="$mtpos" object="this.ship" time="player.age + 20s" zone="this.ship.zone" />
      <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.parallelpath" />
      <move_to object="this.ship" destination="this.ship.zone" forcesteering="true">
        <position value="$mtpos" />
        <interrupt_after_time time="15s" />
      </move_to>

      <label name="returntomasstraffic"/>
      <do_if value="this.ship.ismasstraffic" >
        <debug_text text="'Return to masstraffic...'" chance="$debugoutputchance" />
        <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.closetoobject" />
        <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.steering" />
        <return_to_masstraffic object="this.ship" />
        <resume label="start" />
      </do_if>

      <debug_text text="'Fallback, self-destructing...'" />
      <destroy_object object="this.ship" explosion="true" />
    </actions>
  </attention>
  <attention min="visible">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />

      <set_value name="this.$lastsignal" exact="0" />

      <label name="start" />

      <set_value name="$evade" exact="0" />

      <!-- Initial stand by command action -->
      <set_command_action commandaction="commandaction.flying" />
      
      <wait>
        <interrupt>
          <conditions>
            <event_object_signalled object="this.ship" param="'attack'" />
          </conditions>
          <!-- <actions>
            <debug_text text="'%1(%2) has been signaled with \'%3\', \'%4\''.[this.ship.knownname, this.ship, event.param, event.param2]" />
          </actions> -->
        </interrupt>
      </wait>

      <wait min="500ms" max="3s" />

      <!-- TODO check some abort conditions, maybe we can return to masstraffic already, we should only be in here if the 5 minutes from above have passed without this going into low-attention again -->
      <resume label="start" />

      <!-- ##################################################### -->
      <!-- FLEE to the NavMesh -->
      <!-- ##################################################### -->
      <label name="attack" />
      <label name="flee" />
      <run_script name="'masstraffic.flee.vanilla40'" />

      <resume label="returntomasstraffic" />

      <!-- ##################################################### -->
      <!-- EVADE a potential attack -->
      <!-- ##################################################### -->
      <label name="evade" />
      <wait min="15s" max="45s" />


      <!-- ##################################################### -->
      <!-- RETURN TO MASS TRAFFIC -->
      <!-- ##################################################### -->
      <label name="returntomasstraffic"/>
      <do_if value="this.ship.ismasstraffic" >
        <debug_text text="'Return to masstraffic...'" chance="$debugoutputchance" />
        <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.closetoobject" />
        <return_to_masstraffic object="this.ship" />
        <resume label="start" />
      </do_if>

      <debug_text text="'Fallback, self-destructing...'" />
      <destroy_object object="this.ship" explosion="true" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />
      <label name="start" />
      <label name="attack" />
      <label name="flee" />
      <label name="evade" />
      <label name="returntomasstraffic"/>
      <wait min="5s" max="10s" sinceversion="1" />
      <do_if value="this.ship.exists">
        <debug_text text="'Generic mass traffic ship self-destructing (OOS)'" chance="$debugoutputchance" />
        <destroy_object object="this.ship" explosion="false" />
      </do_if>
    </actions>
  </attention>
</aiscript>

<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="masstraffic.handler.attacked.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="9">
  <params>
    <param name="attacker" default="null" />
    <param name="abortscript" default="false" />
  </params>
  <interrupts>
    <library>
      <handler name="MassTrafficAttackHandler.vanilla40">
        <conditions>
          <event_object_attacked object="this.defensible"/>
        </conditions>
        <actions>
          <set_value name="$abortscript" exact="false" />
          <!--<debug_text text="'%1(%2) has been attacked by %3(%4)'.[this.ship.knownname, this.ship, event.param.knownname, event.param]" />-->
          <do_if value="not global.$last_npc_notification?">
            <set_value name="global.$last_npc_notification" exact="0s"/>
          </do_if>
          <do_if value="event.param" exact="player.primaryship">

            <set_value name="$Speak" exact="false"/>
            <set_value name="$Speak_Line" exact="0"/>

            <!--Only say something if no one has said anything for a few seconds-->
            <do_if value="global.$last_npc_notification" max="player.age - 20s">
              <set_value name="$Speak" exact="this.page != 0"/>
            </do_if>

            <!-- TODO: select adequate responses based on type (police, smuggler, civillian...) -->
            <do_if value="$Speak">
              <do_if value="this.ship.hullpercentage" min="0" max="20">
                <set_value name="$Speak_Line" list="[2033, 2034]"/>
              </do_if>
              <do_elseif value="this.ship.hullpercentage" max="80">
                <set_value name="$Speak_Line" list="[2015, 2016]"/>
              </do_elseif>
              <do_elseif value="this.ship.shieldpercentage" min="5" max="50">
                <set_value name="$Speak_Line" list="[2031, 2032]"/>
              </do_elseif>
              <do_else>
                <set_value name="$Speak_Line" list="[2013, 2014]"/>
              </do_else>
            </do_if>

            <do_if value="$Speak_Line">
              <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="$Speak_Line" />
              <set_value name="global.$last_npc_notification" exact="player.age"/>
            </do_if>

            <!--cleanup -->
            <remove_value name="$Speak"/>
            <remove_value name="$Speak_Line"/>

          </do_if>

          <!-- <set_value name="this.$attackcounter" operation="add" />
          <do_if value="this.$attackcounter gt 1"> -->
            <do_if value="event.param.isoperational">
              <set_value name="$attacker" exact="event.param" />
              <do_if value="(player.age - @this.$lastsignal) gt 3s">
                <!-- send a signal to surrounding ships that we've been attacked so they can initiate evasive maneuvers etc. -->
                <find_gravidar_contact class="class.ship" groupname="$surroundingships" object="this.ship" multiple="true">
                  <match_distance object="this.ship" max="300m" />
                </find_gravidar_contact>
                <signal_objects group="$surroundingships" param="'attack'" param2="event.param" param3="this.ship" />
                <remove_value name="$surroundingships" />
                <set_value name="this.$lastsignal" exact="player.age" />
              </do_if>
            </do_if>
          <!-- </do_if>
          <do_else>
            <set_value name="$abortscript" exact="true" />
          </do_else> -->

          <run_interrupt_script name="'masstraffic.handler.attacked.vanilla40'">
            <param name="attacker" value="@$attacker" />
            <param name="abortscript" value="@$abortscript" />
          </run_interrupt_script>

        </actions>
      </handler>
    </library>
  </interrupts>
  <attention min="visible">
    <actions>

      <do_if value="$abortscript">
        <return />
      </do_if>

      <set_value name="$debugoutputchance" exact="0" />
      <!-- <set_value name="this.$attackcounter" exact="0" /> -->

      <label name="start" />
      <!-- decide whether to flee or to fight -->
      <do_if value="this.defensible.dps.all gt 0">
        <do_if value="@$attacker.isoperational">
          <do_if value="$attacker.mayattack.{this.ship.commander} or $attacker.mayattack.{this.ship}">
            <!-- TODO: compare DPS/attackstrength values, also take additional values into account, like fight skill and morale -->
            <resume label="attack" />
          </do_if>
        </do_if>
        <return />
      </do_if>
      <!-- default to fleeing -->
      <resume label="flee" />

      <!-- ATTACK -->
      <label name="attack" />
      <start_attack object="this.ship" target="$attacker" />
      <run_script name="'fight.attack.object.vanilla40'">
        <param name="target" value="$attacker" />
        <param name="escort" value="@this.ship.commander" />
        <param name="pursuedistance" value="@this.ship.commander.size/2" />
        <param name="allowothertargets" value="false" />
      </run_script>
      <stop_attack object="this.ship" target="$attacker" />
      <resume label="returntomasstraffic" />

      <!-- FLEE -->
      <label name="flee" />
      <run_script name="'masstraffic.flee.vanilla40'" />
      <resume label="returntomasstraffic" />

      <!-- RETURN TO MASSTRAFFIC -->
      <label name="returntomasstraffic"/>
      <do_if value="this.ship.ismasstraffic" >
        <debug_text text="'Return to masstraffic...'" chance="$debugoutputchance" />
        <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.closetoobject" />
        <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.steering" />
        <return_to_masstraffic object="this.ship" />
      </do_if>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <label name="start" />
      <label name="attack" />
      <label name="flee" />
      <label name="returntomasstraffic"/>

      <set_value name="$debugoutputchance" exact="0" />
      <do_if value="this.ship.exists">
        <debug_text text="'Generic mass traffic ship self-destructing (OOS)'" chance="$debugoutputchance" />
        <destroy_object object="this.ship" explosion="false" />
      </do_if>
    </actions>
  </attention>

</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="masstraffic.handler.scanned.vanilla40" priority="9" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="scanner" default="null" />
  </params>
  <interrupts>
    <library>
      <handler name="MassTrafficScannedHandler.vanilla40">
        <conditions>
          <event_scan_finished scanned="this.defensible" />
        </conditions>
        <actions>
          <!--<debug_text text="'%1(%2) has been scanned by %3(%4)'.[this.ship.name, this.ship, event.param.name, event.param]" />-->
          <do_if value="not global.$last_npc_notification?">
            <set_value name="global.$last_npc_notification" exact="0s"/>
          </do_if>
          <do_if value="event.param" exact="player.primaryship">

            <set_value name="$Speak" exact="false"/>
            <set_value name="$Speak_Line" exact="0"/>

            <!--Only say something if no one has said anything for a few seconds-->
            <do_if value="global.$last_npc_notification" max="player.age - 20s">
              <set_value name="$Speak" exact="this.page != 0"/>
            </do_if>

            <!--
            <t id="21">(ship scanned - complicit)Scan away.</t>
            <t id="22">(ship scanned - neutral)What are you scanning me for?</t>
            <t id="23">(ship scanned - illegal)Oi! You can't scan me!</t>
            <t id="24">(ship scanned - enemy)You think you can scan me and get away with it?!</t>
            <t id="25">(ship scanned - confident)I don't think you'll find anything in there.</t>
            <t id="26">(ship scanned - possessing)Err, I have a permit for that, somewhere.</t>            
            -->

            <do_if value="this.hasrelation.enemy.{event.param}">
              <set_value name="$Speak_Line" list="[24] "/>
            </do_if>
            <do_elseif value="event.param.maxlegalscanlevel.{this.ship}" min="this.ship.scannedlevel">
              <do_if value="@this.inventory.illegalto.{this.zone.owner} or @this.ship.cargo.illegalto.{this.zone.owner}">
                <set_value name="$Speak_Line" list="[26] "/>
              </do_if>
              <do_else>
                <set_value name="$Speak_Line" list="[21, 22, 25] "/>
              </do_else>
            </do_elseif>
            <do_else>
              <set_value name="$Speak_Line" list="[23] "/>
            </do_else>

            <do_if value="$Speak">
              <do_if value="$Speak_Line">
                <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="$Speak_Line" />
                <set_value name="global.$last_npc_notification" exact="player.age"/>
              </do_if>
            </do_if>

            <!--cleanup -->
            <remove_value name="$Speak"/>
            <remove_value name="$Speak_Line"/>

          </do_if>
        </actions>

      </handler>
    </library>
  </interrupts>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="masstraffic.police.vanilla40" version="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

  Police Mass Traffic Agent Script
  by Michael
  
      visible:
        wait
        react to:
          - signalled (attack)
          - signalled (police)
          - attacked
        scan for illegal cargo
      unknown:
        self destruct
  
  special case for playership:
    - trigger warning light when getting ready to scan identity
    - trigger warning light when getting ready to scan cargo
  
  -->
  <params>
    <param name="debugoutputchance" default="0" />
  </params>
  <interrupts>
	<handler ref="TargetInvalidHandler.vanilla40" />
  </interrupts>
  <init>
    <do_if value="this.owner.ispolice">
      <set_command command="command.police" />
    </do_if>
  </init>
  <attention min="visible">
    <actions>

      <set_value name="this.$attackcounter" exact="0" />

      <label name="start" />

      <!-- Initial stand by command action -->
      <set_command_action commandaction="commandaction.flying" />

      <do_if value="this.command.value != command.police">
        <debug_text text="'masstraffic.police run on ship in zone where policing is not possible! zone: %1(%2), owner: %3'.[this.zone.knownname, this.zone.macro, this.zone.owner]" />
        <destroy_object object="this.ship" explosion="false" />
        <return />
      </do_if>

      <set_value name="$target" exact="null" />
      <set_value name="$attackreason" exact="'NONE'" />
      <cease_fire object="this.ship" />

      <wait>
        <interrupt>
          <conditions>
            <!-- set up events we are interested in -->
            <check_any>
              <event_object_signalled object="this.ship" param="'attack'" />
              <check_all>
                <event_object_signalled object="this.sector" param="'police'" />
                <check_value value="event.param2.isoperational" />
                <check_value value="event.param2.distanceto.{this.ship}" max="5km" />
              </check_all>
              <event_object_attacked object="this.ship" />
              <event_gravidar_has_scanned object="this.ship" chance="10" />
            </check_any>
          </conditions>
          <actions>
            <do_if value="event.name" exact="'event_object_signalled'">
              <do_if value="event.param" exact="'attack'">
                <!-- a ship near us has been attacked -->
                <set_value name="$target" exact="event.param2" />
                <set_value name="$victim" exact="event.param3" />
                <set_value name="$attackreason" exact="'ATTACKED_NEARBY'" />
              </do_if>
              <do_elseif value="event.param" exact="'police'">
                <!-- someone near us has called the police -->
                <set_value name="$target" exact="event.param2" />
                <set_value name="$victim" exact="event.param3" />
                <set_value name="$attackreason" exact="'CALL_FOR_HELP'" />
              </do_elseif>
            </do_if>
            <do_elseif value="event.name" exact="'event_object_attacked'">
              <!-- we have been attacked -->
              <set_value name="this.$attackcounter" operation="add" />
              <do_if value="this.$attackcounter gt 1">
                <set_value name="this.$attackcounter" exact="0" />
                <set_value name="$target" exact="event.param" />
                <set_value name="$victim" exact="this.ship" />
                <set_value name="$attackreason" exact="'ATTACKED'" />
              </do_if>
              <do_else>
                <resume label="start" />
              </do_else>
            </do_elseif>
          </actions>
        </interrupt>
      </wait>

      <do_if value="$target.isoperational">
        <do_if value="$target.pilot.command.value == command.police">
          <wait min="20ms" max="100ms" />
          <debug_text text="'ignoring other police unit'" chance="$debugoutputchance" />
          <resume label="start" />
        </do_if>
        <!-- <do_if value="$target" exact="player.ship" >
          <set_value name="$debugoutputchance" exact="100" />
        </do_if> -->
        <!-- shoot first, ask questions later... -->
        <detach_from_masstraffic object="this.ship" />
        <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.generic" finishonapproach="true" />
        <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.observe" >
          <interrupt_after_time time="1s" />
        </move_to>
        <shoot_at object="this.ship" target="$target" locktarget="true" slot="tag.primary_slot" tolerance="5deg" />
        <add_relation_boost object="this" otherobject="$target" value="-0.1" decay="1" delay="5min" />
        <do_if value="$target.coverowner">
          <!-- target is under cover, try to get an ID -->
          <resume label="preparescan" />
        </do_if>
        <resume label="attack" />
      </do_if>

      <label name="checkscantargets" />
      <set_value name="$cargoscan" exact="true" />
      <find_gravidar_contact name="$targets" object="this.ship" class="class.ship" functional="true" multiple="true">
        <match_is_in_view_of object="this.ship" vertical="90deg" horizontal="120deg" />
        <match_distance object="this.ship" max="500m"/>
      </find_gravidar_contact>
      <do_all exact="$targets.count" counter="$i">
        <do_if value="$targets.{$i}.isoperational">
          <do_if value="$targets.{$i}.pilot.exists">
            <do_if value="$targets.{$i}.pilot.command.value != command.police">
              <!-- don't scan other police ships -->
              <continue />
            </do_if>
          </do_if>
          <check_line_of_sight object="this.ship" target="$targets.{$i}" name="$hasview" />
          <do_if value="$hasview">
            <set_value name="$target" exact="$targets.{$i}" />
            <!-- <do_if value="$target" exact="player.ship" >
            <set_value name="$debugoutputchance" exact="100" />
          </do_if> -->
            <detach_from_masstraffic object="this.ship" />
            <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.generic" finishonapproach="true" />
            <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.observe" >
              <interrupt_after_time time="1s" />
            </move_to>
            <resume label="preparescan" />
            <break />
          </do_if>
        </do_if>
      </do_all>
      <resume label="start" />


      <label name="preparescan" />

      <!-- Scaning to target command action -->
      <set_command_action commandaction="commandaction.scanningto" param="$target" />
      
      <!-- DEBUG START -->
      <set_value name="$scantype" exact="'identityscan'" />
      <do_if value="$cargoscan">
        <set_value name="$scantype" exact="'cargoscan'" />
      </do_if>
      <debug_text text="player.age +' getting ready to perform %3 on %1(%2)'.[$target.knownname, $target, $scantype] " chance="$debugoutputchance" />
      <!-- DEBUG END -->
      <set_value name="$cockpitlamp" exact="false" />
      <do_while value="(not $lastseen?) or ($lastseen? and ((player.age - @$lastseen) lt 10s))">
        <!-- TODO: we need a timeout and distance check here -->
        <do_if value="not $target.isoperational">
          <break />
        </do_if>
        <check_line_of_sight object="this.ship" target="$target" name="$seen" />
        <do_if value="$seen">
          <do_if value="not $lastseen?">
            <set_value name="$lastseen" exact="player.age" />
            <do_if value="$target" exact="player.ship">
              <!-- TODO: turn on cockpit warning lamp -->
              <debug_text text="player.age +' COCKPIT SCAN WARNING ON'" chance="$debugoutputchance" />
              <set_value name="$cockpitlamp" exact="true" />
            </do_if>
          </do_if>
        </do_if>
        <do_else>
          <remove_value name="$lastseen" />
          <do_if value="$target" exact="player.ship">
            <!-- TODO: turn off cockpit warning lamp -->
            <do_if value="$cockpitlamp">
              <debug_text text="player.age +' COCKPIT SCAN WARNING OFF(1)'" chance="$debugoutputchance" />
              <set_value name="$cockpitlamp" exact="false" />
            </do_if>
          </do_if>
        </do_else>
        <wait min="2s" max="4s" />
      </do_while>

      <!-- target has been in sight for 10 consecutive seconds -->
      <label name="scan" />
      <check_line_of_sight object="this.ship" target="$target" name="$seen" />
      <do_if value="$seen">
        <set_object_active object="this.ship" activate="true" />
        <do_if value="$cargoscan">
          <do_if value="@$target.pilot.inventory.illegalto.{this.zone.owner} or @$target.cargo.illegalto.{this.zone.owner}">
            <set_value name="$illegalcargo" exact="true" />
            <set_value name="$attackreason" exact="'ILLEGAL_CARGO'" />
          </do_if>
        </do_if>

        <do_if value="$target.coverowner">
          <debug_text text="player.age +' revealing true faction \'%1\' of %2'.[$target.trueowner.id, $target.knownname]" chance="$debugoutputchance" />
          <!-- we reveal the true identity of the target -->
          <!-- TODO: relation boost transfer for other objects -->
          <set_cover_owner object="$target.pilot" />
          <!-- TEMP boost to test -->
          <do_if value="$illegalcargo?">
            <debug_text text="player.age +' illegal cargo has been found'" chance="$debugoutputchance" />
            <add_relation_boost object="this" otherobject="$target" value="-0.1" decay="1" delay="5min" />
          </do_if>
        </do_if>

        <wait exact="2s" />
        <set_object_active object="this.ship" activate="false" />
        <wait exact="1s" />
      </do_if>
      <do_if value="$target" exact="player.ship">
        <!-- TODO: turn off cockpit warning lamp -->
        <debug_text text="player.age +' COCKPIT SCAN WARNING OFF(2)'" chance="$debugoutputchance" />
      </do_if>
      <do_if value="not $illegalcargo?">
        <resume label="returntomasstraffic" />
      </do_if>
      <remove_value name="$illegalcargo" />


      <label name="attack" />
      <debug_text text="player.age +' attacking %1, reason: %2'.[$target.knownname, $attackreason] " chance="$debugoutputchance" />
      <add_relation_boost object="this" otherobject="$target" value="-0.1" decay="1" delay="5min" />
      <start_attack object="this.ship" target="$target" />
      <add_to_group groupname="$targets" object="$target" />
      <run_script name="'fight.attack.object.fighter.vanilla40'">
        <param name="primarytargets" value="$targets" />
        <param name="allowothertargets" value="false" />
      </run_script>
      <stop_attack object="this.ship" target="$target" />

      <label name="returntomasstraffic"/>
      <set_value name="this.$attackcounter" exact="0" />
      <do_if value="this.ship.ismasstraffic" >
        <debug_text text="player.age +' Return to masstraffic...'" chance="$debugoutputchance" />
        <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.closetoobject" />
        <return_to_masstraffic object="this.ship" />
        <resume label="start" />
      </do_if>

      <debug_text text="player.age +' Fallback, self-destructing...'" />
      <destroy_object object="this.ship" explosion="true" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <label name="start" />
      <label name="checkscantargets" />
      <label name="preparescan" />
      <label name="scan" />
      <label name="attack" />
      <label name="returntomasstraffic"/>
      <wait min="5s" max="10s" sinceversion="1" />
      <do_if value="this.ship.exists">
        <debug_text text="'Police mass traffic ship self-destructing (OOS)'" chance="$debugoutputchance" />
        <destroy_object object="this.ship" explosion="false" />
      </do_if>
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="masstraffic.return.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--
  Return a roaming mass traffic ship to its network
  -->
  
  <!--TODO: This is just a simple wrapper for now but will need sanity checks if the ship is too far or the network no longer exists.-->
  <attention min="unknown">
    <actions>
      <return_to_masstraffic object="this.ship"/>
      <return/>
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="utf-8" ?>
<aiscript name="masstraffic.watchdog.vanilla40" version="7" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

  "Watchdog" Mass Traffic Agent Script
  by Matthias

  -->
  <params>
    <param name="target" />
  </params>
  <interrupts>
    <handler ref="MassTrafficAttackHandler.vanilla40" />
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler comment="Failed Hack detected">
      <conditions>
        <event_object_signalled object="this.ship" param="'patrol'"  comment="param2 = position to patrol"/>
      </conditions>
      <actions>
        <set_value name="$pos" exact="event.param2" />
        <debug_text text="'station inform that a hack has been detected: go to patrol at position %1'.[event.param2]" chance="$debugoutputchance" />

        <set_value name="$patrolwaittime" min="30s" max="50s" />
        <abort_called_scripts resume="patrol" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.police" />

    <!-- Init values -->
    <set_value name="$homebase" exact="this.ship.commander" />

    <do_if value="@$homebase.defencenpc.exists">
      <add_to_group groupname="$homebase.defencenpc.$watchdogs" object="this.ship"/>
    </do_if>

    <set_value name="$seekrange" exact="300m" />
    <set_value name="$abortseekrange" exact="1800m" />
    <set_value name="$observerange" exact="160m" />
    <set_value name="$noviewaborttime" exact="15s" />
    <set_value name="$viewaborttime" exact="25s" />
    <set_value name="$patrolwaittime" min="10s" max="40s" />
  </init>
  <patch sinceversion="3" early="true">
    <do_if value="not $homebase?">
      <set_value name="$homebase" exact="this.ship.commander" />
    </do_if>
  </patch>
  <patch sinceversion="5">
    <set_value name="$viewaborttime" exact="25s" comment="set the max value if is not there before" />
  </patch>
  <patch sinceversion="7">
    <do_if value="$illegalcargo?">
      <set_value name="$tempillegalcargo" exact="$illegalcargo" />
      <add_to_group groupname="$illegalcargo" object="$tempillegalcargo" />
      <remove_value name="$tempillegalcargo" />
    </do_if>
  </patch>
  <attention min="nearby">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />
      <debug_text text="'Watchdog ' + this.ship + ' script started (nearby)'" chance="$debugoutputchance" />

      <label name="start" />

      <set_command command="command.wait" />
      <set_object_active object="this.ship" activate="false" />

      <wait exact="$patrolwaittime" >
        <interrupt>
          <conditions>
            <event_object_collided object="this.ship" comment="wake up on a collision" />
            <check_value value="event.param.owner != this.ship.owner" />
            <check_value value="event.param.size le 200m" />
          </conditions>
          <actions>
            <debug_text text="'Detected collision with ' + event.param.knownname" chance="$debugoutputchance" />
            <set_value name="$target" exact="event.param" />
            <resume label="scancargo" />
          </actions>
        </interrupt>
      </wait>
      <set_value name="$patrolwaittime" min="10s" max="40s" />

      <resume label="startpatrol" chance="5" />
      <resume label="startscan" chance="45" />
      <resume label="start" />

      <!-- Start patrol: set a position to fly -->
      <label name="startpatrol" />
      <debug_text text="'Watchdog ' + this.ship + ' starting patrol'" chance="$debugoutputchance" />

      <find_closest_station_part refobject="this.ship" station="$homebase" name="$stationpart" />
      <create_random_position_in_boundingbox component="$stationpart" name="$pos" />
      <create_position name="$pos" object="$stationpart" space="this.zone" value="$pos" comment="transform to zone coordinates" />
      <move_navmesh object="null" destination="null" chance="0" comment="compatibility" />

      <!-- Patrol: fly to a position and detect targets -->
      <label name="patrol" />

      <do_if value="not $startpatroltime?">
        <wait min="1s" max="4s"  />
        <set_value name="$startpatroltime" exact="player.age" />
      </do_if>

      <create_position name="$pos" value="$pos" max="500m" />

      <move_to object="this.ship" destination="this.zone" flightbehaviour="flightbehaviour.closetoobject" forcesteering="true" sinceversion="2" >
        <position value="$pos" />
        <interrupt>
          <conditions>
            <event_gravidar_has_scanned object="this.ship" />
          </conditions>
          <actions>

            <find_gravidar_contact name="$targets" object="this.ship" functional="true" multiple="true">
              <match_is_in_view_of object="this.ship" vertical="90deg" horizontal="120deg" />
              <match_distance object="this.ship" max="1000m"/>
            </find_gravidar_contact>

            <!-- For the found objects, check if is enemy, suspicious or illegal -->
            <do_all exact="$targets.count" counter="$i">
              <do_if value="$targets.{$i}.hasrelation.kill.{$homebase} or $targets.{$i}.hasrelation.kill.{this.ship} or $targets.{$i}.suspicious">
                <set_value name="$target" exact="$targets.{$i}" />
                <resume label="scancargo" />
              </do_if>
              <do_elseif value="@$homebase.defencenpc.$criminals.indexof.{$targets.{$i}}">
                <set_value name="$target" exact="$targets.{$i}" />
                <resume label="scancargo" />
              </do_elseif>
            </do_all>
          </actions>
        </interrupt>
      </move_to>
      <wait min="4s" max="8s" chance="0" comment="compatibility" />

      <!-- Break the loop after some time -->
      <do_if value="player.age gt @$startpatroltime + $patrolwaittime">
        <remove_value name="$startpatroltime" />
        <resume label="returntomasstraffic" />
      </do_if>

      <resume label="patrol" />

      <!-- Observe the target for a while (possible illegal activity). Give some time to hide -->
      <label name="startobserve" />
      <!-- Safety check -->
      <do_if value="not $target.isoperational">
        <resume label="returntomasstraffic" />
      </do_if>

      <set_value name="$lastscantime" exact="player.age"/>

      <start_observation object="this.ship" target="$target" range="$observerange" />
      <do_if value="$target == player.controlled and $target != player.primaryship">
        <speak actor="player.computer" line="501" comment="We are scanned." />
      </do_if>
      <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.observe" forcesteering="true">
        <interrupt_after_time time="1s" />
      </move_to>
      <set_value name="$lastviewtime" exact="player.age" />
      
      <!-- observe illegal stuff -->
      <set_value name="$initscanpos" exact="$target.position" />
      <do_while value="@$observeillegal">
        <!-- Target not operational -->
        <do_if value="not $target.isoperational">
          <stop_observation object="this.ship" target="$target" />
          <resume label="returntomasstraffic" />
        </do_if>
        <!-- Wait the drops -->
        <wait min="0.5s" max="0.75s" sinceversion="6" >
          <interrupt>
            <conditions>
              <event_object_dropped_objects object="$target" />
            </conditions>
            <actions>
              <!-- Illegal cargo dropped -->
              <do_if value="@event.param.count gt 0">
                <do_all exact="event.param.count" counter="$i">
                  <debug_text text="'item: ' + event.param.{$i}.knownname" />
                  <do_if value="@event.param.{$i}.wares.illegalto.{$homebase.zone.policefaction}">
                    <debug_text text="'destroy illegal items: ' + event.param.{$i}" chance="$debugoutputchance"  />
                    <add_to_group groupname="$illegalcargo" object="event.param.{$i}" />
                  </do_if>
                </do_all>
              </do_if>
            </actions>
          </interrupt>
        </wait>

        <!-- Special case to destroy illegal cargo -->
        <do_if value="$illegalcargo?">
          <wait min="1s" max="3s" sinceversion="6" />
          <!-- Destroy the illegal cargo -->
          <do_if value="$illegalcargo.count">
            <!-- Shoot the illegal cargo -->
            <shoot_at object="this.ship" additional_targets="$illegalcargo.list" slot="tag.primary_slot" target="$illegalcargo.{1}" tolerance="45deg" />
            <move_to object="this.ship" destination="$illegalcargo.{1}" flightbehaviour="flightbehaviour.observe" sinceversion="6">
              <interrupt>
                <conditions>
                  <check_any>
                    <event_object_destroyed group="$illegalcargo" />
                  </check_any>
                </conditions>
              </interrupt>
              <interrupt_after_time time="2min" />
            </move_to>
          </do_if>
          <do_else>
            <remove_value name="$illegalcargo" />
          </do_else>
          <set_value name="$lastviewtime" exact="player.age" />

          <!-- Continue observing -->
          <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.observe" forcesteering="true" sinceversion="6">
            <interrupt_after_time time="0s" />
          </move_to>
        </do_if>
        <do_else>
          <!-- Re scan illegal cargo -->
          <set_value name="$observeillegal" exact="@$target.pilot.inventory.illegalto.{$homebase.zone.policefaction} or @$target.cargo.illegalto.{$homebase.zone.policefaction}" />
        </do_else>

        <!-- Reaction -->
        <do_if value="$observeillegal">
          <!-- raise alarm -->
          <do_if value="($target.distanceto.{$initscanpos} gt 500m) or (player.age gt $lastviewtime + $viewaborttime)">
            <stop_observation object="this.ship" target="$target" />
            <remove_value name="$observeillegal" />
            <remove_value name="$initscanpos" />
            <resume label="raisealarm" />
          </do_if>
        </do_if>
        <do_else>
          <!-- everything is clear -->
          <do_if value="$target" exact="player.primaryship">
            <!-- id="5141" (dropped)I guess that'll do. Get moving before I change my mind. -->
            <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5140, 5141].random" />
          </do_if>
          <stop_observation object="this.ship" target="$target" />
          <remove_value name="$observeillegal" />
          <remove_value name="$initscanpos" />
          <resume label="returntomasstraffic" />
        </do_else>
      </do_while>

      <!-- Standar observe behaviour -->
      <label name="observe" />

      <do_while value="true">
        <set_object_active object="this.ship" activate="true" />

        <wait min="0.5s" max="0.75s" />

        <wait sinceversion="2" chance="0" comment="compatibility"/>
        <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.observe" forcesteering="true" sinceversion="2" chance="0" comment="compatibility"/>
        <move_to object="this.ship" destination="$illegalcargo" flightbehaviour="flightbehaviour.observe" sinceversion="2" chance="0" comment="compatibility"/>

        <!-- Target not operational -->
        <do_if value="not $target.isoperational">
          <stop_observation object="this.ship" target="$target" />
          <set_object_active object="this.ship" activate="false" />
          <resume label="returntomasstraffic" />
        </do_if>

        <do_if value="$target.distanceto.{this.ship}" min="$abortseekrange">
          <debug_text text="'Watchdog ' + this.ship + ' lost target it was observing (distance check), return to mass traffic'" chance="$debugoutputchance" />
          <stop_observation object="this.ship" target="$target" />
          <set_object_active object="this.ship" activate="false" />
          <!-- Call more police ships -->
          <signal_objects object="$homebase.defencenpc.$watchdogs.random" param="'patrol'" param2="$target.position" />
          <resume label="startpatrol" />
        </do_if>

        <set_value name="$hadview" exact="@$hasview" />
        <check_line_of_sight object="this.ship" target="$target" name="$hasview" />

        <!-- Target has been seen -->
        <do_if value="$hasview">
          <set_value name="$lastviewtime" exact="player.age" />
          <do_if value="player.age gt $lastscantime + $viewaborttime">
            <stop_observation object="this.ship" target="$target" />
            <set_object_active object="this.ship" activate="false" />
            <resume label="raisealarm" />
          </do_if>
          <do_elseif value="not $hadview">
            <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.observe" forcesteering="true">
              <interrupt_after_time time="0s" />
            </move_to>
          </do_elseif>
        </do_if>
        <!-- Target lost -->
        <do_else>
          <do_if value="player.age gt $lastviewtime + $noviewaborttime">
            <debug_text text="'Watchdog ' + this.ship + ' lost target it was observing (line of sight check), return to mass traffic'" chance="$debugoutputchance" />
            <stop_observation object="this.ship" target="$target" />
            <set_object_active object="this.ship" activate="false" />
            <!-- Call more police ships -->
            <signal_objects object="$homebase.defencenpc.$watchdogs.random" param="'patrol'" param2="$target.position" />
            <resume label="startpatrol" />
          </do_if>
          <do_elseif value="$hadview">
            <move_to object="this.ship" destination="$target.zone" flightbehaviour="flightbehaviour.observe" forcesteering="true">
              <position value="$target.position" />
              <interrupt_after_time time="0s" />
            </move_to>
          </do_elseif>
        </do_else>
      </do_while>

      <!-- Find ships and set a valid target -->
      <label name="startscan" />

      <set_command command="command.scan" />
      <debug_text text="'Watchdog ' + this.ship + ' starting to scan'" chance="$debugoutputchance" />

      <!-- Find ships nearby -->
      <find_object class="class.ship" name="$surroundingships" space="this.ship.zone" multiple="true" >
        <match_size max="200m" />
        <match_is_in_view_of object="this.ship" vertical="90deg" horizontal="120deg" />
        <match_distance object="this.ship" max="1000m" />
        <match owner="this.ship.owner" negate="true" />
      </find_object>

      <do_if value="$surroundingships.count" >
        <debug_text text="'Watchdog ' + this.ship + ' found '+ $surroundingships.count + ' surrounding ships.'" chance="$debugoutputchance" />
        <set_value name="$target" exact="null" />

        <do_all exact="$surroundingships.count" counter="$i">
          <do_if value="not @$scannedships.indexof.{$surroundingships.{$i}}">
            <set_value name="$target" exact="$surroundingships.{$i}" />
            <!-- Set selection if is enemy or suspicious. Otherwise is unknown, so scan it -->
            <do_if value="$target.suspicious or $target.hasrelation.kill.{$homebase} or $target.hasrelation.kill.{this.ship}">
              <break />
            </do_if>
            <!-- Set selection if target is player ship (with a small chance) -->
            <do_if value="$target == player.primaryship" chance="20">
              <break />
            </do_if>
          </do_if>
        </do_all>

        <!-- Move to the target -->
        <do_if value="$target.isoperational">
          <add_to_group groupname="$scannedships" object="$target" />
          <move_to object="this.ship" destination="$target" chance="0" comment="compatibility"/>
          <resume label="scancargo" />
        </do_if>
      </do_if>

      <debug_text text="'Watchdog ' + this.ship + ' found nothing to scan'" chance="$debugoutputchance" />
      <wait min="2s" max="5s" />

      <resume label="returntomasstraffic" />

      <!-- Scan Cargo: obverve some seconds and react to -->
      <label name="scancargo" />
      <!-- Safety check -->
      <do_if value="not $target.isoperational">
        <resume label="returntomasstraffic" />
      </do_if>

      <!-- Scann effect -->
      <set_object_active object="this.ship" activate="true" />

      <debug_text text="'Watchdog ' + this.ship + ' moving to scan '+ $target.knownname + ' ('+ $target +')'" chance="$debugoutputchance" />
      <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.generic" finishonapproach="true" forcesteering="true" sinceversion="3" />

      <!-- Safety check -->
      <do_if value="not $target.isoperational">
        <resume label="returntomasstraffic" />
      </do_if>

      <!-- notify that is going to scan -->
      <do_if value="$target" exact="player.primaryship">
        <do_if value="not $target.hasrelation.enemy.{$homebase}">
          <!-- <t id="5100">(Player scanned)Don't mind us, just doing our job.</t> -->
          <!-- <t id="5101">(Player scanned)We'd appreciate your cooperation.</t> -->
          <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5100,5101].random"  />
        </do_if>
        <do_elseif value="not $target.hasrelation.kill.{$homebase}">
          <!-- <t id="5102">(Player scanned - aggressive)Well now, what do we have here?</t> -->
          <!-- <t id="5103">(Player scanned - aggressive)What are you hiding from us?</t> -->
          <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5102,5103].random"  />
        </do_elseif>
        <do_elseif value="$target.hasrelation.kill.{$homebase} and player.copilot.exists">
          <!-- Yisha? <t id="11298">(Comment on being scanned)We're being scanned!</t>-->
          <start_conversation actor="player.copilot" conversation="Speak" type="unqueued" convparam="11298"  />
        </do_elseif>
      </do_if>

      <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.observe" forcesteering="true" >
        <interrupt_after_time time="4s" />
      </move_to>
      <set_object_active object="this.ship" activate="false" />
      <wait exact="1s" />

      <!-- Reactions. Also check the hacked time for the station (if it is hacked) -->
      <!-- Safety check -->
      <do_if value="not $target.isoperational">
        <resume label="returntomasstraffic" />
      </do_if>
      <!-- Fisrt check if is enemy -->
      <do_if value="$target.hasrelation.kill.{$homebase} or $target.hasrelation.kill.{this.ship}">
        <resume label="raisealarm" />
      </do_if>
      <!-- Second check for suspicious or in criminal list (hackers/scanners) -->
      <do_elseif value="$target.suspicious">
        <debug_text text="'Watchdog ' + this.ship + ' has detected suspicious and starts observing offender'" chance="$debugoutputchance" />
        <set_value name="$viewaborttime" exact="25s" comment="some more time for drones" />
        <resume label="startobserve" />
      </do_elseif>
      <do_elseif value="@$homebase.defencenpc.$criminals.indexof.{$target}">
        <debug_text text="'Watchdog ' + this.ship + ' has detected a criminal and starts observing offender'" chance="$debugoutputchance" />
        <set_value name="$viewaborttime" exact="5s" comment="less time for criminal" />
        <resume label="startobserve" />
      </do_elseif>
      <!-- Second check for illegal cargo -->
      <do_elseif value="@$target.pilot.inventory.illegalto.{$homebase.zone.policefaction} or @$target.cargo.illegalto.{$homebase.zone.policefaction}">
        <!-- notify that scan has revealed illegal cargo, observe to give some time -->
        <set_value name="$viewaborttime" exact="20min" comment="more time for drop the cargo" />
        <set_value name="$observeillegal" exact="true"  />
        <do_if value="$target" exact="player.primaryship">
          <do_if value="player.isinconversation">
            <set_value name="$viewaborttime" exact="3s" operation="subtract"  />
            <wait exact="3s" sinceversion="5" comment="wait for the voice to finish"/>
          </do_if>
          <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5122,5132].random" />
        </do_if>
        <debug_text text="'Watchdog ' + this.ship + ' has detected illegal cargo/inventory and starts observing offender'" chance="$debugoutputchance" />
        <resume label="startobserve" />
      </do_elseif>


      <!-- Last return, everything is ok -->
      <do_if value="$target" exact="player.primaryship">
        <do_if value="not $target.hasrelation.enemy.{$homebase}">
          <!-- <t id="5110">(nothing found)You're clean, continue with your journey.</t> -->
          <!-- <t id="5111">(nothing found)We've completed our scans. Thanks for your cooperation.</t> -->
          <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5110,5111].random"  />
        </do_if>
        <do_elseif value="not $target.hasrelation.kill.{$homebase}">
          <!-- <t id="5112">(nothing found - aggressive)Well, that was a waste of time. Get out of here.</t> -->
          <!-- <t id="5113">(nothing found - aggressive)You're clear, but we've got our eye on you.</t> -->
          <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5112,5113].random"  />
        </do_elseif>
      </do_if>
      <remove_value name="$lastscantime"/>
      <resume label="returntomasstraffic" />


      <label name="raisealarm" />

      <!-- Safety check -->
      <do_if value="not $target.isoperational">
        <resume label="returntomasstraffic" />
      </do_if>

      <!-- Speak lines and final checks -->
      <!-- Check that the station is not hacked -->
      <do_if value="player.age le @$homebase.defencenpc.$hacked">
        <resume label="returntomasstraffic" />
      </do_if>
      <!-- Suspicious -->
      <do_elseif value="$target.suspicious or @$homebase.defencenpc.$criminals.indexof.{$target}">
        <debug_text text="'target %1 is suspicious or a wanted criminal'.[$target.knownname]" chance="$debugoutputchance"  />

        <!-- Set enemy to homebase (station) -->
        <set_relation_boost object="$homebase" otherobject="$target" value="$target.owner.relation.kill.min" delay="10min" decay="1" />
        <add_to_group groupname="$homebase.defencenpc.$enemies" object="$target"/>

        <!-- Add the dronecommander (if has) to the wanted criminals list (because of the IP is traced) -->
        <do_if value="$target.isclass.drone" comment="if is a drone">
          <add_to_group groupname="$homebase.defencenpc.$criminals" object="$target.dronecommander" check="false" />
          <do_if value="$target.primarypurpose" exact="objectpurpose.hack">
            <set_value name="$homebase.defencenpc.$hackerfound" exact="[$target.dronecommander, player.age]" />
          </do_if>
          <do_elseif value="$target.primarypurpose" exact="objectpurpose.scan">
            <set_value name="$homebase.defencenpc.$scannerfound" exact="[$target.dronecommander, player.age]" />
          </do_elseif>
        </do_if>

        <!-- Hacker/Scanner drone -->
        <do_if value="$target" exact="player.controlled">
          <do_if value="$target == @$homebase.defencenpc.$hackerfound.{1}">
            <add_faction_relation faction="faction.player" otherfaction="this.owner" value="$homebase.relationchange.attackfaction.hack" />
            <set_value name="$relchange" exact="$homebase.relationchange.policefaction.hack" />
          </do_if>
          <do_elseif value="$target == @$homebase.defencenpc.$scannerfound.{1}">
            <add_faction_relation faction="faction.player" otherfaction="this.owner" value="$homebase.relationchange.attackfaction.scan" />
            <set_value name="$relchange" exact="$homebase.relationchange.policefaction.scan" />
          </do_elseif>
          <set_value name="$responderdata" exact="[
                            this.ship, null, null, null,
                            0s, 0s,
                            false, false, null, 0,
                            null, null, @$relchange, 0s ]" />
          <set_value name="$lawnpc" exact="@this.sector.representative.{this.zone.policefaction}.{entitytype.lawenforcement}" />
          <!-- Illegal activity feedback, assuming "cover" if player is not on the criminals list (which also prevents police report) -->
          <!-- convparam = [ responderdata, victimdata, is_3rd_party_victim, lawnpc, relchange ] -->
          <start_conversation actor="this" conversation="IllegalActivityRetaliate" type="unqueued"
                              convparam="[$responderdata, $responderdata, true, $lawnpc, @$relchange, not @$homebase.defencenpc.$criminals.indexof.{$target}]"
                              comment="responderdata, victimdata, is_3rd_party_victim, lawnpc, relchange, has_cover"/>
          <remove_value name="$relchange" />
          <remove_value name="$responderdata" />
          <remove_value name="$lawnpc" />
        </do_if>

        <!-- If the target was on the wanted criminal list, remove it because is already identified -->
        <do_if value="@$homebase.defencenpc.$criminals.indexof.{$target}">
          <remove_from_group group="$homebase.defencenpc.$criminals" object="$target" />
        </do_if>

      </do_elseif>
      <!-- Enemy -->
      <do_elseif value="$target.hasrelation.kill.{$homebase} or $target.hasrelation.kill.{this.ship}">
        <debug_text text="'target %1 is enemy'.[$target.knownname]" chance="100"  />
        <add_to_group groupname="$homebase.defencenpc.$enemies" object="$target"/>
      </do_elseif>
      <!-- Illegal -->
      <do_elseif value="@$target.pilot.inventory.illegalto.{$homebase.zone.policefaction} or @$target.cargo.illegalto.{$homebase.zone.policefaction}">
        <debug_text text="'target %1 has illegal cargo/inventory'.[$target.knownname]" chance="$debugoutputchance"  />
        <!-- id="5120" (contraband found - police)Our official scans show you are smuggling illegal items. Now pay close attention! -->
        <!-- id="5121" (contraband found - police)You've been detected as having illegal cargo. Let's deal with this sensibly.-->
        <do_if value="$target" exact="player.primaryship">
          <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5120, 5121].random" />
        </do_if>
        <!-- Set enemy to homebase (station) -->
        <set_relation_boost object="$homebase" otherobject="$target" value="$target.owner.relation.kill.min" delay="10min" decay="1" />
        <add_to_group groupname="$homebase.defencenpc.$enemies" object="$target"/>
      </do_elseif>
      <do_else>
        <!-- False alarm -->
        <debug_text text="'target %1 was almost detected'.[$target.knownname]" chance="$debugoutputchance"  />
        <!-- id="5110" (nothing found)That's fine, Sir. Please carry on with your journey. -->
        <!-- id="5111" (nothing found)All done. Your cooperation made that easy. -->
        <!-- id="5112" (nothing found - aggressive)You're squeaky-clean, this time. We'll be seeing you again! -->
        <!-- id="5113" (nothing found - aggressive)Yeah, lucky this time, eh? We'll catch you out one day! -->
        <do_if value="$target" exact="player.primaryship">
          <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5110, 5111, 5112, 5113].random" />
        </do_if>
        <resume label="returntomasstraffic" />
      </do_else>

      <debug_text text="'Watchdog ' + this.ship + ' raises alarm and starts attacking offender'" chance="$debugoutputchance" />
      <report_illegal_activity object="$target" target="$homebase" />


      <!-- Only Attack Target -->
      <label name="attack" />
      <!-- Safety check -->
      <do_if value="not $target.isoperational">
        <resume label="returntomasstraffic" />
      </do_if>
      <set_object_active object="this.ship" activate="false" />

      <do_if value="not $target.hasrelation.kill.{this.ship}">
        <set_relation_boost object="this.ship" otherobject="$target" value="$target.owner.relation.kill.min" delay="10min" decay="1" />
      </do_if>
      <debug_text text="'%1(%2) attacks and adds %5 to enemy list of %3(%4)'.[this.ship.knownname, this.ship, $homebase.knownname, $homebase, $target.knownname]" chance="$debugoutputchance" />
      <start_attack object="this.ship" target="$target" />

      <run_script name="'fight.attack.object.vanilla40'">
        <param name="target" value="$target" />
        <param name="escort" value="$homebase" />
        <param name="pursuedistance" value="$homebase.size/2" />
        <param name="allowothertargets" value="false" />
      </run_script>

      <do_if value="$target.exists">
        <stop_attack object="this.ship" target="$target" />
      </do_if>

      <!-- Return to Patrol (more enemies?) -->
      <resume label="startpatrol" />

      <!-- Final step, return to masstraffic -->
      <label name="returntomasstraffic"/>
      <do_if value="this.ship.ismasstraffic">
        <set_object_active object="this.ship" activate="false" />
        <stop_moving object="this.ship" />
        <debug_text text="'Watchdog ' + this.ship + ' returns to mass traffic'" chance="$debugoutputchance" />
        <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.closetoobject" />

        <!-- Reduce/remove the patrolling-police counter -->
        <do_if value="@$homebase.defencenpc.$policepatrol.count">
          <remove_from_group group="$homebase.defencenpc.$policepatrol" object="this.ship" />
          <do_if value="$homebase.defencenpc.$policepatrol.count" exact="0">
            <!-- No more ships patrolling, send signal -->
            <remove_value name="$homebase.defencenpc.$policepatrol" />
            <signal_objects object="$homebase" param="'police_patrol_stopped'" />
          </do_if>
        </do_if>

        <return_to_masstraffic object="this.ship" />
        <resume label="start" />
      </do_if>

      <debug_text text="'Watchdog ' + this.ship + ' self-destructs'" chance="$debugoutputchance" />
      <destroy_object object="this.ship" explosion="true" />

    </actions>
  </attention>
  <attention min="visible">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />
      <debug_text text="'Watchdog ' + this.ship + ' script started (visible)'" chance="$debugoutputchance" />

      <label name="start" />
      <set_object_active object="this.ship" activate="false" />

      <wait />

      <resume label="start" />


      <label name="startpatrol" />
      <create_position name="$pos" object="this.ship" space="this.zone"  max="500m"/>

      <label name="patrol" />

      <do_if value="not $startpatroltime?">
        <wait min="1s" max="4s"  />
        <set_value name="$startpatroltime" exact="player.age" />
      </do_if>

      <do_if value="not $pos?" comment="create an initial position if does not exists">
        <create_position name="$pos" object="this.ship" space="this.zone"  max="500m"/>
      </do_if>

      <create_position name="$pos" value="$pos" max="500m" />
      <move_to object="this.ship" destination="this.zone" flightbehaviour="flightbehaviour.closetoobject" forcesteering="true" sinceversion="2" >
        <position value="$pos" />
        <interrupt>
          <conditions>
            <event_gravidar_has_scanned object="this.ship" />
          </conditions>
          <actions>
            <do_if value="event.name == 'event_gravidar_has_scanned'">
              <find_gravidar_contact name="$targets" object="this.ship" functional="true" multiple="true">
                <match_is_in_view_of object="this.ship" vertical="90deg" horizontal="120deg" />
                <match_distance object="this.ship" max="1000m"/>
              </find_gravidar_contact>

              <do_all exact="$targets.count" counter="$i">
                <do_if value="$targets.{$i}.hasrelation.kill.{$homebase} or $targets.{$i}.hasrelation.kill.{this.ship} or $targets.{$i}.suspicious or @$homebase.defencenpc.$criminals.indexof.{$targets.{$i}}">
                  <set_value name="$target" exact="$targets.{$i}" />
                  <debug_text text="'%1 detected patrollin by %2(%3) after gravidar scan '.[$target.knownname, this.ship.knownname, this.ship]" chance="$debugoutputchance" />
                  <resume label="scancargo" />
                </do_if>
              </do_all>
            </do_if>
          </actions>
        </interrupt>
      </move_to>
      <wait min="4s" max="8s" chance="0" comment="compatibility" />

      <!-- Break the loop -->
      <do_if value="player.age gt @$startpatroltime + $patrolwaittime">
        <remove_value name="$startpatroltime" />
        <resume label="returntomasstraffic" />
      </do_if>

      <resume label="patrol" />


      <label name="startobserve" />
      <wait max="2s" chance="0" />
      <!-- Reduced version of observe case -->
      <label name="observe" />
      <do_while value="true">
        <set_object_active object="this.ship" activate="true" />

        <wait min="0.5s" max="0.75s" sinceversion="4" />
        <!-- Target not operational -->
        <do_if value="not $target.isoperational">
          <stop_observation object="this.ship" target="$target" />
          <set_object_active object="this.ship" activate="false" />
          <resume label="returntomasstraffic" />
        </do_if>

        <do_if value="$target.distanceto.{this.ship}" min="$abortseekrange">
          <debug_text text="'Watchdog ' + this.ship + ' lost target it was observing (distance check), return to mass traffic'" chance="$debugoutputchance" />
          <stop_observation object="this.ship" target="$target" />
          <set_object_active object="this.ship" activate="false" />
          <!-- Call more police ships -->
          <signal_objects object="$homebase.defencenpc.$watchdogs.random" param="'patrol'" param2="$target.position" />
          <resume label="startpatrol" />
        </do_if>

        <set_value name="$hadview" exact="@$hasview" />
        <check_line_of_sight object="this.ship" target="$target" name="$hasview" />

        <!-- Target has been seen -->
        <do_if value="$hasview">
          <set_value name="$lastviewtime" exact="player.age" />
          <do_if value="player.age gt $lastscantime + $viewaborttime">
            <stop_observation object="this.ship" target="$target" />
            <set_object_active object="this.ship" activate="false" />
            <resume label="raisealarm" />
          </do_if>
          <do_elseif value="not $hadview">
            <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.observe" forcesteering="true"  sinceversion="4">
              <interrupt_after_time time="0s" />
            </move_to>
          </do_elseif>
        </do_if>
        <!-- Target lost -->
        <do_else>
          <do_if value="player.age gt $lastviewtime + $noviewaborttime">
            <debug_text text="'Watchdog ' + this.ship + ' lost target it was observing (line of sight check), return to mass traffic'" chance="$debugoutputchance" />
            <stop_observation object="this.ship" target="$target" />
            <set_object_active object="this.ship" activate="false" />
            <!-- Call more police ships -->
            <signal_objects object="$homebase.defencenpc.$watchdogs.random" param="'patrol'" param2="$target.position" />
            <resume label="startpatrol" />
          </do_if>
          <do_elseif value="$hadview">
            <move_to object="this.ship" destination="$target.zone" flightbehaviour="flightbehaviour.observe" forcesteering="true"  sinceversion="4">
              <position value="$target.position" />
              <interrupt_after_time time="0s" />
            </move_to>
          </do_elseif>
        </do_else>
      </do_while>

      <label name="startscan" />
      <wait max="2s" />
      <label name="scancargo" />
      <resume label="returntomasstraffic" />


      <label name="raisealarm" />
      <!-- Safety check -->
      <do_if value="not $target.isoperational">
        <resume label="returntomasstraffic" />
      </do_if>

      <!-- Speak lines and final checks -->
      <!-- Check that the station is not hacked -->
      <do_if value="player.age le @$homebase.defencenpc.$hacked">
        <resume label="returntomasstraffic" />
      </do_if>
      <!-- Suspicious -->
      <do_elseif value="$target.suspicious or @$homebase.defencenpc.$criminals.indexof.{$target}">
        <debug_text text="'target %1 is suspicious or a wanted criminal'.[$target.knownname]" chance="$debugoutputchance"  />

        <!-- Set enemy to homebase (station) -->
        <set_relation_boost object="$homebase" otherobject="$target" value="$target.owner.relation.kill.min" delay="10min" decay="1" />
        <add_to_group groupname="$homebase.defencenpc.$enemies" object="$target"/>

        <!-- Add the dronecommander (if has) to the wanted criminals list (because of the IP is traced) -->
        <do_if value="$target.isclass.drone" comment="if is a drone">
          <add_to_group groupname="$homebase.defencenpc.$criminals" object="$target.dronecommander" check="false" />
          <do_if value="$target.primarypurpose" exact="objectpurpose.hack">
            <set_value name="$homebase.defencenpc.$hackerfound" exact="[$target.dronecommander, player.age]" />
          </do_if>
          <do_elseif value="$target.primarypurpose" exact="objectpurpose.scan">
            <set_value name="$homebase.defencenpc.$scannerfound" exact="[$target.dronecommander, player.age]" />
          </do_elseif>
        </do_if>

        <!-- Hacker/Scanner drone -->
        <do_if value="$target" exact="player.controlled">
          <do_if value="$target == @$homebase.defencenpc.$hackerfound.{1}">
            <add_faction_relation faction="faction.player" otherfaction="this.owner" value="$homebase.relationchange.attackfaction.hack" />
            <set_value name="$relchange" exact="$homebase.relationchange.policefaction.hack" />
          </do_if>
          <do_elseif value="$target == @$homebase.defencenpc.$scannerfound.{1}">
            <add_faction_relation faction="faction.player" otherfaction="this.owner" value="$homebase.relationchange.attackfaction.scan" />
            <set_value name="$relchange" exact="$homebase.relationchange.policefaction.scan" />
          </do_elseif>
          <set_value name="$responderdata" exact="[
                            this.ship, null, null, null,
                            0s, 0s,
                            false, false, null, 0,
                            null, null, @$relchange, 0s ]" />
          <set_value name="$lawnpc" exact="@this.sector.representative.{this.zone.policefaction}.{entitytype.lawenforcement}" />
          <!-- Illegal activity feedback, assuming "cover" if player is not on the criminals list (which also prevents police report) -->
          <!-- convparam = [ responderdata, victimdata, is_3rd_party_victim, lawnpc, relchange ] -->
          <start_conversation actor="this" conversation="IllegalActivityRetaliate" type="unqueued"
                              convparam="[$responderdata, $responderdata, true, $lawnpc, @$relchange, not @$homebase.defencenpc.$criminals.indexof.{$target}]"
                              comment="responderdata, victimdata, is_3rd_party_victim, lawnpc, relchange, has_cover"/>
          <remove_value name="$relchange" />
          <remove_value name="$responderdata" />
          <remove_value name="$lawnpc" />
        </do_if>

        <!-- If the target was on the wanted criminal list, remove it because is already identified -->
        <do_if value="@$homebase.defencenpc.$criminals.indexof.{$target}">
          <remove_from_group group="$homebase.defencenpc.$criminals" object="$target" />
        </do_if>

      </do_elseif>
      <!-- Enemy -->
      <do_elseif value="$target.hasrelation.kill.{$homebase} or $target.hasrelation.kill.{this.ship}">
        <debug_text text="'target %1 is enemy'.[$target.knownname]" chance="100"  />
        <add_to_group groupname="$homebase.defencenpc.$enemies" object="$target"/>
      </do_elseif>
      <!-- Illegal -->
      <do_elseif value="@$target.pilot.inventory.illegalto.{$homebase.zone.policefaction} or @$target.cargo.illegalto.{$homebase.zone.policefaction}">
        <debug_text text="'target %1 has illegal cargo/inventory'.[$target.knownname]" chance="$debugoutputchance"  />
        <!-- id="5120" (contraband found - police)Our official scans show you are smuggling illegal items. Now pay close attention! -->
        <!-- id="5121" (contraband found - police)You've been detected as having illegal cargo. Let's deal with this sensibly.-->
        <do_if value="$target" exact="player.primaryship">
          <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5120, 5121].random" />
        </do_if>
        <add_to_group groupname="$homebase.defencenpc.$criminals" object="$target"/>
      </do_elseif>
      <do_else>
        <!-- False alarm -->
        <debug_text text="'target %1 was almost detected'.[$target.knownname]" chance="$debugoutputchance"  />
        <!-- id="5110" (nothing found)That's fine, Sir. Please carry on with your journey. -->
        <!-- id="5111" (nothing found)All done. Your cooperation made that easy. -->
        <!-- id="5112" (nothing found - aggressive)You're squeaky-clean, this time. We'll be seeing you again! -->
        <!-- id="5113" (nothing found - aggressive)Yeah, lucky this time, eh? We'll catch you out one day! -->
        <do_if value="$target" exact="player.primaryship">
          <start_conversation actor="this" conversation="Speak" type="unqueued" convparam="[5110, 5111, 5112, 5113].random" />
        </do_if>
        <resume label="returntomasstraffic" />
      </do_else>

      <debug_text text="'Watchdog ' + this.ship + ' raises alarm and starts attacking offender'" chance="$debugoutputchance" />
      <report_illegal_activity object="$target" target="$homebase" />


      <!-- Only Attack Target -->
      <label name="attack" />
      <!-- Safety check -->
      <do_if value="not $target.isoperational">
        <resume label="returntomasstraffic" />
      </do_if>
      <set_object_active object="this.ship" activate="false" />

      <do_if value="not $target.hasrelation.kill.{this.ship}">
        <set_relation_boost object="this.ship" otherobject="$target" value="$target.owner.relation.kill.min" delay="10min" decay="1" />
      </do_if>
      <debug_text text="'%1(%2) attacks and adds %5 to enemy list of %3(%4)'.[this.ship.knownname, this.ship, $homebase.knownname, $homebase, $target.knownname]" chance="$debugoutputchance" />
      <start_attack object="this.ship" target="$target" />

      <run_script name="'fight.attack.object.vanilla40'">
        <param name="target" value="$target" />
        <param name="escort" value="$homebase" />
        <param name="pursuedistance" value="$homebase.size/2" />
        <param name="allowothertargets" value="false" />
      </run_script>

      <do_if value="$target.exists">
        <stop_attack object="this.ship" target="$target" />
      </do_if>

      <!-- Return to Patrol (more enemies?) -->
      <resume label="startpatrol" />

      <!-- Final step, return to masstraffic -->
      <label name="returntomasstraffic"/>
      <do_if value="this.ship.ismasstraffic">
        <set_object_active object="this.ship" activate="false" />
        <stop_moving object="this.ship" />
        <debug_text text="'Watchdog ' + this.ship + ' returns to mass traffic'" chance="$debugoutputchance" />
        <set_flight_behaviour object="this.ship" flightbehaviour="flightbehaviour.closetoobject" />

        <!-- Reduce/remove the patrolling-police counter -->
        <do_if value="@$homebase.defencenpc.$policepatrol.count">
          <remove_from_group group="$homebase.defencenpc.$policepatrol" object="this.ship" />
          <do_if value="$homebase.defencenpc.$policepatrol.count" exact="0">
            <!-- No more ships patrolling, send signal -->
            <remove_value name="$homebase.defencenpc.$policepatrol" />
            <signal_objects object="$homebase" param="'police_patrol_stopped'" />
          </do_if>
        </do_if>

        <return_to_masstraffic object="this.ship" />
        <resume label="start" />
      </do_if>

      <debug_text text="'Watchdog ' + this.ship + ' self-destructs'" chance="$debugoutputchance" />
      <destroy_object object="this.ship" explosion="true" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />
      <label name="start" />
      <label name="startpatrol" />
      <label name="patrol" />
      <label name="startobserve" />
      <label name="observe" />
      <label name="startscan" />
      <label name="scancargo" />
      <label name="raisealarm" />
      <label name="attack" />
      <label name="returntomasstraffic"/>
      <!-- UI icon: target attacked -->
      <do_if value="@$target.exists">
        <stop_attack object="this.ship" target="$target" />
      </do_if>
      <wait min="5s" max="10s" sinceversion="1" />

      <!-- Reduce/remove the patrolling-police counter -->
      <do_if value="@$homebase.defencenpc.$policepatrol.count">
        <remove_value name="$homebase.defencenpc.$policepatrol" />
        <signal_objects object="$homebase" param="'police_patrol_stopped'" />
      </do_if>

      <do_if value="this.ship.exists">
        <debug_text text="'Watchdog ' + this.ship + ' self-destructs (OOS)'" chance="$debugoutputchance" />
        <destroy_object object="this.ship" explosion="false" />
      </do_if>
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1"?>
<aiscript name="mining.ship.collect.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="5">
  <!--
  This script does the actual mining both high and low attention. While there is
  no difference between gas and mineral mining in low attention, both cases are
  separated in high attention (because gases can't be picked up).
  by Michael, Benedikt, Adrian
  -->
  <params>
    <param name="zone"/>
    <param name="ware"/>
    <param name="secwares"/>
    <param name="debugchance"/>
  </params>
  <patch sinceversion="3">
    <!--Reset gathertime as low attention case may have modified it incorrectly-->
    <set_value name="$gathertime" min="172s" max="188s"/>
  </patch>
  <attention min="visible">
    <actions>
      <set_value name="$dronelaunchdelay" exact="3s" comment="the minimum delay between two drone launches"/>
      <set_value name="$gathertime" min="172s" max="188s" comment="the time spent to gather resources at a certain location (gases only)"/>
      <set_value name="$traveltime" min="76s" max="84s" comment="the time between gathering at two different locations (gases only)"/>

      <run_script name="'move.undock.vanilla40'" sinceversion="4" />

      <get_safe_pos result="$destination" zone="$zone" radius="this.ship.size" min="1km" max="35km" />

      <!-- Move to destination zone -->
      <do_if value="this.ship.zone != $zone">
        <debug_text text="'Go mining to zone: ' + $zone.knownname" chance="$debugchance" />
        <!-- If the zone to mine is a highway -->
        <do_if value="$zone.isclass.highway">
          <debug_text text="'Error moving to %1. This zone is a highway'" />
          <!-- <resume label="start" /> -->
        </do_if>
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$zone"/>
          <param name="endintargetzone" value="true" />
          <param name="debugchance" value="$debugchance"/>
        </run_script>
      </do_if>

      <label name="start" />

      <!-- gas mining -->
      <do_if value="$ware.tags.indexof.{tag.liquid}">
        <!-- chance to skip initial movement -->
        <do_if value="true" chance="$gathertime / ($gathertime + $traveltime) * 100">
          <set_value name="$skipmovement" exact="true"/>
        </do_if>
        <do_else>
          <set_value name="$skipmovement" exact="false"/>
        </do_else>
        <set_value name="$gathercounter" exact="0s"/>

        <!-- loop as long as there is at least 5% free cargo space -->
        <do_while value="this.ship.cargo.{$ware}.free gt (0.05 * this.ship.cargo.{$ware}.max)">

          <!-- Command action -->
          <set_command_action commandaction="commandaction.searchingresources" />
          <!-- Zone no longer exists -->
          <do_if value="not $zone.exists">
            <return value="'aborted'" />
          </do_if>
          <!-- Drone launchpad/drones destroyed -->
          <do_if value="not this.ship.units.collect.{$ware}.count">
            <return value="'nodrones'" />
          </do_if>

          <do_if value="$skipmovement" exact="false">
            <do_if value="this.ship.distanceto.{$destination} lt 4km">
              <debug_text text="player.age+' destination almost reached, creating a new destination'" chance="$debugchance"/>
              <get_safe_pos result="$destination" zone="$zone" radius="this.ship.size" min="1km" max="35km" />
            </do_if>
            <debug_text text="player.age+' movement started (destination: '+this.ship.distanceto.{$destination}+'m)'" chance="$debugchance"/>
            <move_to object="this.ship" destination="this.ship.zone" finishonapproach="true" forceposition="false">
              <position value="$destination"/>
              <interrupt_after_time time="1s"/>
            </move_to>
            <wait exact="$traveltime"/>
            <debug_text text="player.age+' movement stopped, preparing to mine'" chance="$debugchance"/>
            <stop_moving object="this.ship" immediate="false"/>
            <wait min="4s" max="6s"/>
          </do_if>
          <do_else>
            <set_value name="$skipmovement" exact="false"/>
          </do_else>
          <!-- launch drones to collect gas -->
          <debug_text text="player.age+' starting to launch drones'" chance="$debugchance"/>
          <set_value name="$gatherstart" exact="player.age"/>
          <do_while value="player.age lt ($gatherstart + $gathertime)">
            <do_if value="this.ship.cargo.{$ware}.free le (0.05 * this.ship.cargo.{$ware}.max)">
              <break/>
            </do_if>
            <launch_drone name="$drone" object="this.ship" group="unitcategory.gascollector" exact="1"/>
            <do_if value="$drone.isoperational">
              <start_script name="'mining.ship.drone.vanilla40'" object="$drone.pilot">
                <param name="homebase" value="this.ship"/>
                <param name="ware" value="$ware"/>
              </start_script>
            </do_if>
            <wait exact="$dronelaunchdelay"/>
            <set_value name="$gathercounter" exact="$gathercounter + $dronelaunchdelay" />
            <!-- gas gathering uses low attention mechanic -->
            <do_if value="$gathercounter ge 15s">
              <set_value name="$gathercounter" exact="15s" />
              <do_if value="($gatherstart + $traveltime) lt player.age">
                <get_resource_gatherrate name="$gatherrate" refobject="this.ship" zone="$zone" ware="$ware"/>
                <set_value name="$gathered" min="$gatherrate * $gathercounter * 0.75" max="$gatherrate * $gathercounter * 1.25"/>
                <deplete_yield  zone="$zone" container="this.ship" ware="$ware" amount="$gathered"/>
                <debug_text text="player.age + ' collected %1 units of %2 (%3 units/s on average)'.[$gathered, $ware, $gatherrate]" chance="$debugchance"/>
                <set_value name="$gathercounter" exact="0"/>
              </do_if>
            </do_if>
          </do_while>
          <debug_text text="player.age+' stop launching drones'" chance="$debugchance"/>
        </do_while>
        <debug_text text="player.age+' less than 5% free cargo space'" chance="$debugchance"/>
      </do_if>
      <do_else>
        <!-- mineral mining (capital ships) -->
        <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
          <set_value name="$moving" exact="false"/>
          <set_value name="$target" exact="null"/>

          <do_while value="this.ship.cargo.{$ware}.free gt (0.05 * this.ship.cargo.{$ware}.max)">
            <!-- Command action -->
            <set_command_action commandaction="commandaction.searchingresources" />
            <!-- Zone no longer exists -->
            <do_if value="not $zone.exists">
              <return value="'aborted'" />
            </do_if>
            <!-- Drone launchpad/drones destroyed -->
            <do_if value="not this.ship.units.collect.{$ware}.count">
              <return value="'nodrones'" />
            </do_if>

            <set_value name="$checkware" exact="$ware"/>
            <!-- 20% chance to gather secondary wares that can be mined -->
            <do_if value="@$secwares.count" chance="10">
              <!-- <set_value name="$checkware" exact="$secwares.random"/> -->
              <set_value name="$tryware" exact="$secwares.random"/>
              <!-- evaluate if should use a secondary ware -->
              <do_if value="(this.ship.units.collect.{$tryware}.count and this.ship.cargo.{$tryware}.free)">
                <debug_text text="'IZ mining: try other ware (%1)'.[$tryware]" chance="$debugchance" />
                <set_value name="$checkware" exact="$tryware"/>
              </do_if>
              <remove_value name="$tryware" />
            </do_if>

            <!-- find pickup (filtered by ownership) and target -->
            <set_value name="$pickuptarget" exact="false"/>
            <set_value name="$skill" exact="(this.combinedskill - 50) * 3" />
            <find_asteroid_in_cluster name="$pickup" cluster="this.cluster" refobject="this.ship" canpickup="true" multiple="true" maxdistance="4km" viewangle="360deg" ware="$checkware" />
            <do_all exact="$pickup.count" counter="$i" reverse="true">
              <do_if value="$pickup.{$i}.owner">
                <remove_value name="$pickup.{$i}" />
              </do_if>
              <do_elseif value="not $pickup.{$i}.canbepickedup">
                <debug_text text="'%1 in %2 (: %3) cannot be picked up!'.[$pickup.{$i}, $pickup.{$i}.zone.knownname, $.knownname]" chance="$debugchance"/>
                <remove_value name="$pickup.{$i}" />
              </do_elseif>
              <do_elseif value="$pickup.{$i}.wares.{$checkware}.count le 0" chance="$skill">
                <remove_value name="$pickup.{$i}" />
              </do_elseif>
            </do_all>

            <!-- Find asteroids if there is no target -->
            <do_if value="not $target.exists">
              <!-- find asteroids and calculate their total hull -->
              <set_value name="$asteroidhull" exact="0"/>
              <find_asteroid_in_cluster name="$asteroids" cluster="this.cluster" refobject="this.ship" canpickup="false" multiple="true" maxdistance="3km + this.ship.size" viewangle="360deg" ware="$checkware" />
              <!-- Check asteroids and take the biggest -->
              <do_if value="$asteroids.count" min="1">
                <set_value name="$target" exact="$asteroids.{1}"/>
                <set_value name="$bestasteroid" exact="$asteroids.{1}.hull"/>
                <do_all exact="$asteroids.count" counter="$i">
                  <set_value name="$asteroidhull" exact="$asteroids.{$i}.hull" operation="add"/>
                  <do_if value="$asteroids.{$i}.hull gt $bestasteroid">
                    <set_value name="$target" exact="$asteroids.{$i}"/>
                    <set_value name="$bestasteroid" exact="$asteroids.{$i}.hull"/>
                  </do_if>
                </do_all>
                <!-- Attack asteroids with mining lasers -->
                <set_turret_targets object="this.ship" target="$asteroids" weapontype="mining" clearpreferred="false" preferredtarget="$target" />
              </do_if>
              <do_else>
                <!-- Find again with bigger range (only one now) -->
                <find_asteroid_in_cluster name="$target" cluster="this.cluster" refobject="this.ship" canpickup="false" multiple="false" maxdistance="55km" viewangle="360deg" ware="$checkware" />
              </do_else>
              <!-- If any target found, set it as a new position -->
              <do_if value="$target.exists">
                <set_region_object_persistence object="$target" />
                <set_value name="$destination" exact="$target.position" />
                <set_value name="$moving" exact="false" comment="to restart the movement" />
                <set_turret_targets object="this.ship" target="$asteroids" weapontype="mining" clearpreferred="false" preferredtarget="$target" />
              </do_if>
            </do_if>

            <!-- Move/Stop -->
            <do_if value="$pickup.count ge this.ship.availableunits.collect.{$checkware}.count">
              <!-- enough targets in range, stop moving -->
              <set_value name="$moving" exact="false"/>
              <debug_text text="'%1 movement stopped [pickup count: %2, asteroid count: %3 (%4)]'.[player.age, $pickup.count, $asteroids.count, ($asteroidhull)L]" chance="$debugchance"/>
              <stop_moving object="this.ship" immediate="false"/>
              <!-- Command action -->
              <set_command_action commandaction="commandaction.waitingdrones" />
            </do_if>
            <do_elseif value="$moving">
              <do_if value="this.ship.distanceto.{$destination} lt this.ship.size * 2">
                <set_value name="$moving" exact="false"/>
                <debug_text text="'%1 movement stopped because we are almost there [pickup count: %2, asteroid count: %3 (%4)]'.[player.age, $pickup.count, $asteroids.count, ($asteroidhull)L]" chance="$debugchance"/>
                <set_value name="$randmaxpos" max="this.ship.size * 2"/>
                <stop_moving object="this.ship" immediate="false"/>
              </do_if>
            </do_elseif>
            <do_else >
              <!-- not enough targets in range, start moving -->
              <wait exact="3s" sinceversion="2" chance="0" comment="TODO after the wait the target can be destroyed"  />
              <!-- Move -->
              <do_if value="$target.exists">
                <!-- Check if the target can be hit (check mining turrets) -->
                <do_if value="not @$turrets.{1}.exists" comment="check with exists, because the disappear in low attention">
                  <find_object_component object="this.ship" name="$turrets" multiple="true" class="class.turret" weapontype="mining"  />
                </do_if>

                <!-- If there is view for any turret, break the iteration -->
                <set_value name="$view" exact="false" />
                <do_all exact="$turrets.count" counter="$i" reverse="true" comment="in reverse because usually the front turret is the last, so the iteration breaks earlier">
                  <check_line_of_sight object="$turrets.{$i}" target="$target" name="$result" />
                  <do_if value="$result and $turrets.{$i}.distanceto.{$target} lt 2900">
                    <set_value name="$view" exact="true" />
                    <debug_text text="'target view in %1. Distance %2'.[$i, $turrets.{$i}.distanceto.{$target}]" chance="$debugchance" />
                    <break />
                  </do_if>
                </do_all>
                <!-- If there is no view with any turret, move to the target -->
                <do_if value="not $view">
                  <set_value name="$moving" exact="true"/>
                  <!-- first try to rotate on the spot -->
                  <debug_text text="'rotating towards asteroid: ' + $target" chance="$debugchance"/>
                  <create_orientation name="$rot" orientation="look_at" refobject="$target">
                    <position object="this.ship" />
                  </create_orientation>
                  <move_to object="this.ship" destination="$target.zone" finishonapproach="true" forceposition="false" forcerotation="true" abortpath="true" usehighways="false" sinceversion="5">
                    <position object="this.ship" max="@$randmaxpos" />
                    <rotation value="$rot" />
                    <interrupt_after_time time="500ms" />
                  </move_to>
                  <remove_value name="$randmaxpos" />
                  <do_if value="$target.exists">
                    <debug_text text="'flying to asteroid: ' + $target" chance="$debugchance"/>
                    <move_to object="this.ship" destination="$target.zone" finishonapproach="true" forceposition="false" abortpath="false" sinceversion="2" usehighways="false">
                      <position object="$target" />
                      <interrupt_after_time time="10s"/>
                    </move_to>
                  </do_if>
                </do_if>
              </do_if>
              <do_else>
                <!-- No asteroids, target or pickable so move to a random place-->
                <get_safe_pos result="$destination" zone="$zone" radius="this.ship.size" min="1km" max="50km" />
                <debug_text text="'%1 movement started Random destity [pickup count: %2, asteroid count: %3 (%4)]'.[player.age, $pickup.count, $asteroids.count, ($asteroidhull)L]" chance="$debugchance"/>
                <set_value name="$moving" exact="true"/>
                <move_to object="this.ship" destination="this.ship.zone" finishonapproach="true" forceposition="false" abortpath="true" usehighways="false">
                  <position value="$destination"/>
                  <interrupt_after_time time="20s"/>
                </move_to>
              </do_else>
            </do_else>

            <!-- launch drone to pick up the target -->
            <do_if value="$pickup.count">
              <set_value name="$pickuptarget" exact="$pickup.random"/>
              <set_region_object_persistence object="$pickuptarget" persistent="true" />
              <launch_drone name="$drone" object="this.ship" group="unitcategory.orecollector" exact="1"/>
              <do_if value="$drone.isoperational">
                <debug_text text="'%1 drone launched [pickup count: %2, asteroid count: %3 (%4)]'.[player.age, $pickup.count, $asteroids.count, ($asteroidhull)L]" chance="$debugchance"/>
                <start_script name="'mining.ship.drone.vanilla40'" object="$drone.pilot">
                  <param name="homebase" value="this.ship" />
                  <param name="target" value="$pickuptarget"/>
                </start_script>
                <set_owner object="$pickuptarget" faction="this.ship.owner"/>
              </do_if>
              <do_else>
                <debug_text text="'%1 no drone available [pickup count: %2, asteroid count: %3 (%4)]'.[player.age, $pickup.count, $asteroids.count, ($asteroidhull)L]" chance="$debugchance"/>
              </do_else>
            </do_if>

            <wait exact="$dronelaunchdelay"/>
          </do_while>
          <debug_text text="player.age+' less than 5% free cargo space'" chance="$debugchance"/>
        </do_if>
        <do_else>
          <!-- mineral mining (medium ships) -->
          <set_value name="$attackposition" exact="false"/>
          <do_while value="this.ship.cargo.{$ware}.free gt (0.05 * this.ship.cargo.{$ware}.max)">

            <!-- Command action -->
            <set_command_action commandaction="commandaction.searchingresources" />

            <!-- Zone no longer exists -->
            <do_if value="not $zone.exists">
              <return value="'aborted'" />
            </do_if>
            <!-- Drone launchpad/drones destroyed -->
            <do_if value="not this.ship.units.collect.{$ware}.count">
              <return value="'nodrones'" />
            </do_if>

            <set_value name="$checkware" exact="$ware" />
            <!-- 10% chance to gather secondary wares that can be mined -->
            <do_if value="@$secwares.count" chance="10">
              <set_value name="$tryware" exact="$secwares.random"/>
              <!-- evaluate if should use a secondary ware -->
              <do_if value="(this.ship.units.collect.{$tryware}.count and this.ship.cargo.{$tryware}.free)">
                <debug_text text="'IS mining: try other ware (%1)'.[$tryware]" chance="$debugchance" />
                <set_value name="$checkware" exact="$tryware"/>
              </do_if>
              <remove_value name="$tryware" />
            </do_if>
            <!-- find pickup (filtered by ownership) and target -->
            <set_value name="$pickuptarget" exact="false"/>
            <set_value name="$skill" exact="(this.combinedskill - 50) * 3" />

            <!-- Small asteroids to pick up -->
            <find_asteroid_in_cluster name="$pickup"  cluster="this.cluster" refobject="this.ship" canpickup="true" multiple="true" maxdistance="2km" ware="$checkware" viewangle="360deg" />
            <do_all exact="$pickup.count" counter="$i" reverse="true">
              <do_if value="$pickup.{$i}.owner">
                <remove_value name="$pickup.{$i}" />
              </do_if>
              <do_elseif value="not $pickup.{$i}.canbepickedup">
                <debug_text text="'%1 in %2 cannot be picked up!'.[$pickup.{$i}, $pickup.{$i}.zone.knownname]" chance="$debugchance"/>
                <remove_value name="$pickup.{$i}" />
              </do_elseif>
              <do_elseif value="$pickup.{$i}.wares.{$checkware}.count le 0" chance="$skill">
                <remove_value name="$pickup.{$i}" />
              </do_elseif>
            </do_all>
            <!-- evaluate movement -->
            <do_if value="$pickup.count le this.ship.units.collect.{$checkware}.count">
              <!-- No target -->
              <do_if value="not @$target.exists">
                <!-- find asteroids and the best target -->
                <find_asteroid_in_cluster name="$asteroids"  cluster="this.cluster" refobject="this.ship" canpickup="false" multiple="true" maxdistance="3km" ware="$checkware" viewangle="180deg"/>

                <do_if value="$asteroids.count" min="1">
                  <set_value name="$target" exact="$asteroids.{1}"/>
                  <set_value name="$bestasteroid" exact="$asteroids.{1}.hull"/>
                  <do_all exact="$asteroids.count" counter="$i">
                    <do_if value="$asteroids.{$i}.hull lt $bestasteroid">
                      <set_value name="$target" exact="$asteroids.{$i}"/>
                      <set_value name="$bestasteroid" exact="$asteroids.{$i}.hull"/>
                    </do_if>
                  </do_all>
                  <debug_text text="'%1 new target [pickup count: %2, asteroid count: %3 (%4)]'.[player.age, $pickup.count, $asteroids.count, $bestasteroid]" chance="$debugchance"/>
                </do_if>
                <do_else>
                  <!-- Find again with bigger range -->
                  <find_asteroid_in_cluster name="$target" cluster="this.cluster" refobject="this.ship" canpickup="false" multiple="false" maxdistance="55km" ware="$checkware" viewangle="360deg"/>
                </do_else>
              </do_if>

              <!-- Target exists -->
              <do_if value="$target.exists">
                <!-- Set asteroid persistence -->
                <set_region_object_persistence object="$target" />
                <!-- Distance check -->
                <do_if value="this.ship.distanceto.{$target} - ($target.size/2.f)" min="1200m">
                  <!-- the target is out of firing range, we have to move closer -->
                  <debug_text text="player.age+' target is out of range ('+ (this.ship.distanceto.{$target} - ($target.size/2.f)) +'m)'" chance="$debugchance"/>
                  <move_to object="this.ship" destination="$target.zone" forceposition="false" finishonapproach="true">
                    <position object="$target" />
                    <interrupt_after_time time="1s"/>
                  </move_to>
                </do_if>
                <do_else>
                  <set_value name="$attackposition" exact="true"/>
                  <shoot_at object="this.ship" slot="tag.primary_slot" target="$target" tolerance="12.0deg" weapontype="mining" />
                  <!-- stop and rotate -->
                  <debug_text text="player.age+' target is now in range ('+ (this.ship.distanceto.{$target} - ($target.size/2.f)) +'m)'" chance="$debugchance"/>
                  <move_to object="this.ship" destination="$target.zone" forcerotation="true" forcesteering="true" flightbehaviour="flightbehaviour.mining">
                    <position object="$target" max="50m" />
                    <interrupt_after_time time="1s" />
                  </move_to>
                </do_else>
              </do_if>

              <!-- No Target - Attack position -->
              <do_elseif value="not @$target.exists and $attackposition">
                <!-- We where shooting the asteroid -->
                <set_value name="$attackposition" exact="false"/>
              </do_elseif>

              <!-- No Target - No Attack position -->
              <do_elseif value="not @$target.exists and not $attackposition">
                <!-- Reset state -->
                <remove_value name="$target"/>
                <stop_shooting object="this.ship" slot="tag.primary_slot"/>
                <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.spline" />
                <!-- No more asteroids -->
                <do_if value="not @$asteroids.count">
                  <!-- when no asteroid found and nothing to pickup-->
                  <do_if value="not $pickup.count">
                    <debug_text text="'no resources found, flying to random position'" chance="$debugchance" />

                    <get_safe_pos result="$destination" zone="$zone" radius="this.ship.size" min="1km" max="50km" />
                    <!-- Fly to a random pos in zone -->
                    <move_to object="this.ship" destination="$zone" sinceversion="1">
                      <position value="$destination"/>
                      <interrupt_after_time time="2min" />
                    </move_to>
                  </do_if>
                </do_if>
              </do_elseif>
            </do_if>

            <!-- launch drone to pick up the target -->
            <do_if value="$pickup.count">
              <set_value name="$pickuptarget" exact="$pickup.random"/>
              <do_if value="$pickuptarget.exists">
                <set_region_object_persistence object="$pickuptarget" persistent="true" />
                <launch_drone name="$drone" object="this.ship" group="unitcategory.orecollector" exact="1"/>
                <do_if value="$drone.isoperational">
                  <debug_text text="'%1 drone launched [pickup count: %2, asteroid count: %3]'.[player.age, $pickup.count, @$asteroids.count]" chance="$debugchance"/>
                  <start_script name="'mining.ship.drone.vanilla40'" object="$drone.pilot">
                    <param name="homebase" value="this.ship" />
                    <param name="target" value="$pickuptarget"/>
                  </start_script>
                  <set_owner object="$pickuptarget" faction="this.ship.owner"/>
                </do_if>
                <do_else>
                  <set_command_action commandaction="commandaction.waitingdrones" />
                  <debug_text text="'%1 no drone available [pickup count: %2, asteroid count: %3]'.[player.age, $pickup.count, @$asteroids.count]" chance="$debugchance"/>
                </do_else>
              </do_if>
            </do_if>

            <wait exact="$dronelaunchdelay"/>

          </do_while>
        </do_else>
      </do_else>

      <!-- Stop mining lasers -->
      <stop_shooting object="this.ship" slot="tag.primary_slot" comment="for primary weapon" />
      <cease_fire object="this.ship" weapontype="mining" comment="for turrets" />

      <return value="'cargofull'" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <set_value name="$dronelaunchdelay" exact="3s" comment="the minimum delay between two drone launches"/>
      <set_value name="$gathertime" min="172s" max="188s" comment="the time spent to gather resources at a certain location (gases only)"/>
      <set_value name="$traveltime" min="76s" max="84s" comment="the time between gathering at two different locations (gases only)"/>

      <run_script name="'move.undock.vanilla40'" sinceversion="4" />

      <get_safe_pos result="$destination" zone="$zone" radius="this.ship.size" min="1km" max="35km" />

      <!-- Move to destination zone -->
      <do_if value="this.ship.zone != $zone">
        <debug_text text="'Go mining to zone: ' + $zone.knownname" chance="$debugchance" />
        <!-- If the zone to mine is a highway -->
        <do_if value="$zone.isclass.highway">
          <debug_text text="'Error moving to %1. This zone is a highway'" />
          <!-- <resume label="start" /> -->
        </do_if>
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$zone"/>
          <param name="endintargetzone" value="true" />
          <param name="debugchance" value="$debugchance"/>
        </run_script>
      </do_if>

      <label name="start" />

      <wait min="8s" max="12s" />
      <do_while value="this.ship.cargo.{$ware}.free gt 0">

        <!-- command action simulation -->
        <do_any>
          <set_command_action commandaction="commandaction.searchingresources" weight="60" />
          <set_command_action commandaction="commandaction.flying" weight="40" />
        </do_any>

        <!-- Zone no longer exists -->
        <do_if value="not $zone.exists">
          <return value="'aborted'" />
        </do_if>
        <!-- Drone launchpad/drones destroyed -->
        <do_if value="not this.ship.units.collect.{$ware}.count">
          <return value="'nodrones'" />
        </do_if>

        <set_value name="$currentware" exact="$ware" />
        <!-- 20% chance that we try to collect one of the other resources that can be gathered in this zone if they are useful to our homebase, $tryware can be the same as $ware -->
        <do_if value="@$secwares.count" chance="10">
          <set_value name="$tryware" exact="$secwares.random"/>
          <!-- evaluate if should use a secondary ware -->
          <do_if value="(this.ship.units.collect.{$tryware}.count and this.ship.cargo.{$tryware}.free)">
            <debug_text text="'OOZ mining: try other ware (%1)'.[$tryware]" chance="$debugchance" />
            <set_value name="$currentware" exact="$tryware"/>
          </do_if>
          <remove_value name="$tryware" />
        </do_if>
        <get_resource_gatherrate name="$gatherrate" refobject="this.ship" zone="$zone" ware="$currentware" />
        <do_if value="$gatherrate" max="0">
          <debug_text text="player.age + ' WARNING: gatherrate for %1 in zone %2 is %4'.[$currentware, $zone.knownname, $gatherrate]" chance="$debugchance" />
        </do_if>
        <set_value name="$gatherstart" exact="player.age" />
        <!-- smaller mining ships need some time to gather more than zero resources -->
        <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
          <wait min="16s" max="24s"/>
        </do_if>
        <do_else>
          <wait min="112s" max="128s"/>
        </do_else>
        <set_value name="$currentgathertime" exact="player.age - $gatherstart" />
        <set_value name="$gathered" exact="$currentgathertime * $gatherrate" />
        <do_if value="this.ship.cargo.{$currentware}.free lt $gathered">
          <set_value name="$gathered" exact="this.ship.cargo.{$currentware}.free" />
        </do_if>
        <deplete_yield zone="$zone" container="this.ship" ware="$currentware" amount="$gathered" />
        <debug_text text="player.age + ' collected %1 units of %2 in zone %3 in %4 seconds (%5 units/s)'.[$gathered, $currentware, $zone.knownname, $currentgathertime, $gatherrate]" chance="$debugchance" />

      </do_while>

      <debug_text text="player.age + ' %1(job: \'%2\') completed gather-run of %3 in %4. Cargo: %5'.[this.ship.knownname, this.ship.job, $ware, $zone.knownname, this.ship.cargo.list]" chance="$debugchance" />

      <return value="'cargofull'" />

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="mining.ship.drone.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <!--
  This script can be either used with a target or a ware. If a target is provided,
  the drone tries to collect the target and returns to its homebase with the pickup.
  If instead the ware parameter is set, the drone flys to some random locations and
  returns to the homebase afterwards. The corresponding ware is then added via script.
  by Michael and Benedikt
  -->
  <params>
    <param name="homebase" default="this.ship.commander" comment="the homebase for this drone"/>
    <param name="target" default="null" comment="the target pickup (if there is one for the corresponding resource)"/>
    <param name="ware" default="null" comment="the resource this drone should collect (if there is no target)"/>
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
  </interrupts>
  <init>
    <set_command command="command.mining" param="$homebase.zone" />
  </init>
  <attention min="visible">
    <actions>

      <set_value name="$debugchance" exact="0" comment="the chance to display debug messages"/>
      <set_value name="$gatherlocations" exact="3" comment="the number of locations required to gather a resource (no target)"/>
      <set_value name="$gatherdistance" exact="2km" comment="the distance between the homebase and the first gather location (no target)"/>
      <set_value name="$gatheroffset" exact="1km" comment="the distance between each gather location after the first one (no target)"/>

      <label name="start" />
      <!-- undock -->
      <debug_text text="player.age+' undocking'" chance="$debugchance" />
      <wait min="1min" max="2min">
        <interrupt>
          <conditions>
            <check_any>
              <!-- <event_object_approaching_waypoint object="this.ship" lastwaypoint="true"/> -->
              <event_object_arrived_at_waypoint object="this.ship" lastwaypoint="true"/>
            </check_any>
          </conditions>
        </interrupt>
      </wait>
      <debug_text text="player.age+' successfully undocked'" chance="$debugchance" />
      <clear_collision_filter object="this.ship" />

      <label name="collect" />
      <!-- collect -->
      <do_if value="$target" exact="null">
        <!-- there is no pickup, fly to random positions instead -->
        <set_value name="$currentlocation" exact="0"/>
        <create_position name="$nextlocation" object="this.ship" min="$gatherdistance - 0.5km" max="$gatherdistance + 0.5km"/>
        <do_while value="$currentlocation lt $gatherlocations">
          <!-- repeatedly move to random locations -->
          <set_value name="$currentlocation" operation="add" exact="1"/>
          <debug_text text="player.age+' moving to gather location #'+$currentlocation" chance="$debugchance" />
          <move_to destination="this.ship.zone" object="this.ship" flightbehaviour="flightbehaviour.generic" finishonapproach="true" forcesteering="true">
            <position value="$nextlocation"/>
          </move_to>
          <create_position name="$nextlocation" object="this.ship" min="$gatheroffset - 0.5km" max="$gatheroffset - 0.5km"/>
        </do_while>
        <!-- dock again -->
        <run_script name="'move.dockat.drone.vanilla40'">
          <param name="destination" value="$homebase" />
        </run_script>
        <assert value="false" text="'\'move.dockat.drone\' returned to visible-block of \'mining.ship.drone\' for drone %1 [%2] [ Michael ]'.[this.ship.knownname, this.ship]" />
      </do_if>
      <do_else>
        <!-- there is a pickup, go and get it -->
        <run_script name="'move.collect.drone.vanilla40'">
          <param name="target" value="$target" />
          <param name="homebase" value="$homebase" />
          <param name="stayactive" value="true" />
          <param name="launching" value="false" />
          <param name="debugoutputchance" value="$debugchance" />
        </run_script>
        <!-- move.collect.drone also handles docking -->
      </do_else>

      <!-- we are only down here if docking didn't work, most likely because the homebase is dead, we just wait until the low-attention case cleans up -->
      <stop_moving object="this.ship" />
      <wait sinceversion="1" max="5s"  />

      <resume label="collect"/>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <!-- cleanup -->
      <label name="start" />
      <label name="collect" />

      <do_if value="this.ship.commander.isoperational">
        <run_script name="'move.dockat.drone.vanilla40'" sinceversion="1">
          <param name="destination" value="this.ship.commander" />
        </run_script>
        <assert value="false" text="'\'move.dockat.drone\' returned to unknown-block of \'mining.ship.drone\' for drone %1 [%2] [ Michael ]'.[this.ship.knownname, this.ship]" />
      </do_if>
      <do_else>
        <destroy_object object="this.ship" explosion="false" />
      </do_else>

      <!-- drone no longer exists if the drone docked successfully -->
      <debug_text text="player.age+' drone docked.'" chance="@$debugchance"/>
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="mining.ship.free.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="10">
  <!--
  This script will try to automatically supply stations and will only work with
  a valid warebasket parameter (defined via jobs). It can do gas and mineral
  mining and works for all ship classes. Based on mining.ship.station.
  by Benedikt
  -->
  <params>
    <param name="basketoverride" default="null" comment="list of wares that takes precedence over any defined warebasket" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler ref="AttackHandler.vanilla40" />
  </interrupts>
  <init>
    <set_command command="command.freemining" />
  </init>
  <patch sinceversion="3">
    <do_if value="not $buyer? and @$buyoffer.exists">
      <set_value name="$buyer" exact="$buyoffer.buyer" />
    </do_if>
  </patch>
  <patch sinceversion="5">
    <do_if value="not $Possible_Wares?">
      <set_value name="$Possible_Wares" exact="this.ship.cargo.list" />
      <set_value name="$fuelindex" exact="$Possible_Wares.indexof.{ware.fuelcells}" />
      <do_if value="$fuelindex gt 0">
        <remove_value name="$Possible_Wares.{$fuelindex}" />
      </do_if>
    </do_if>
  </patch>
  <patch sinceversion="8">
    <do_if value="this.sector.exists">
      <set_value name="$startsector" exact="this.sector" />
    </do_if>
    <do_elseif value="this.zone.isclass.highway">
      <set_value name="$startsector" exact="this.zone.destination.sector" />
    </do_elseif>
  </patch>
  <patch sinceversion="10">
    <!-- all reservations have been wiped as of 4.0, if we are currently processing the $unloadlist restore reservations for the current and remaining items -->
    <do_if value="@$buyer.exists and $unloadlist? and $u?">
      <do_all exact="$unloadlist.count" counter="$u_patch">
        <do_if value="$u_patch ge $u">
          <add_ware_reservation type="sell" ware="$unloadlist.{$u_patch}.{1}" amount="$unloadlist.{$u_patch}.{2}" entity="this" object="$buyer" replace="true" />
        </do_if>
      </do_all>
    </do_if>
  </patch>

  <attention min="unknown">
    <actions>
      <set_value name="$debugchance" exact="0" />
      <set_value name="$debugchance2" exact="0" />

      <!-- basic checks first -->
      <label name="init" />
      <wait min="5s" max="15s" />

      <!-- safety check -->
      <do_if value="not this.ship.cluster.exists">
        <set_value name="$failreason" exact="'ERR_NO_CLUSTER'" />
        <set_value name="$failreason2" exact="'Good bye cruel world! ' + this.ship" />
        <resume label="finish" />
      </do_if>

      <do_if value="this.ship.cargo.capacity" max="0">
        <debug_text text="'%1 has cargo capacity of %2!'.[this.ship.knownname, this.ship.cargo.capacity]" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_CARGOSPACE'" />
        <set_value name="$failreason2" exact="'Macro: ' + this.ship.macro.name" />
        <resume label="finish" />
      </do_if>
      <do_if value="this.ship.units.collect.count" exact="0">
        <debug_text text="'mining ship does not have any units for collecting!'" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_COLLECT'" />
        <set_value name="$failreason2" exact="'Macro: %1, Job: %2'.[this.ship.macro.name, this.ship.job]" />
        <resume label="finish" />
      </do_if>
      <do_if value="not $basketoverride">
        <do_if value="this.ship.warebasket.count" exact="0">
          <debug_text text="'mining without warebasket defined in jobs not supported!'" chance="$debugchance" />
          <set_value name="$failreason" exact="'ERR_NO_WAREBASKET'" />
          <set_value name="$failreason2" exact="'Job: ' + this.ship.job" />
          <resume label="finish" />
        </do_if>
        <set_value name="$warebasket" exact="this.ship.warebasket.list" />
      </do_if>
      <do_else>
        <set_value name="$warebasket" exact="$basketoverride" />
      </do_else>

      <!-- store startsector as preferred sector for selling -->
      <set_value name="$startsector" exact="this.sector" />
      <!-- Has a job main zone? -->
      <do_if value="this.ship.jobmainzone">
        <set_value name="$startsector" exact="this.ship.jobmainzone.sector"/>
      </do_if>

      <!-- find mineable wares within the cluster -->
      <create_list name="$availablewares" exact="0"/>
      <debug_text text="player.age + ' searching for wares...'" chance="$debugchance"/>
      <do_all exact="$warebasket.count" counter="$i">
        <set_value name="$ware" exact="$warebasket.{$i}"/>
        <find_resource ware="$ware" refobject="this.ship" zone="$zone"/>
        <do_if value="$zone.exists">
          <do_if value="this.ship.cluster" exact="$zone.cluster">
            <append_to_list name="$availablewares" exact="$ware"/>
            <debug_text text="player.age + ' there is %1 in this cluster'.[$ware]" chance="$debugchance"/>
          </do_if>
        </do_if>
      </do_all>
      <do_if value="$availablewares.count" exact="0">
        <debug_text text="'unable to find any ware that can be collected by this ship in this cluster!'" chance="$debugchance"/>
        <set_value name="$failreason" exact="'ERR_NO_WARES'"/>
        <resume label="finish"/>
      </do_if>

      <!-- primary loop start -->
      <label name="loop" />

      <do_if value="not $nextbuyoffercheck? or $nextbuyoffercheck le player.age">
        <set_value name="$sellablewares" exact="[]"/>
        <find_sector space="this.ship.cluster" multiple="true" name="$sectors" />
        <do_while value="$sectors.count gt 0">
          <set_value name="$s" min="1" max="$sectors.count" />
          <find_buy_offer tradepartner="this.ship" space="$sectors.{$s}" multiple="true" result="$buyoffers" wares="$availablewares" excludeempty="false" />
          <do_all exact="$buyoffers.count" counter="$b">
            <do_if value="$warebasket.indexof.{$buyoffers.{$b}.ware} gt 0">
              <do_if value="$sellablewares.indexof.{$buyoffers.{$b}.ware} == 0">
                <append_to_list name="$sellablewares" exact="$buyoffers.{$b}.ware" />
              </do_if>
            </do_if>
          </do_all>
          <remove_value name="$sectors.{$s}" />
          <wait min="2s" max="5s" sinceversion="9" />
        </do_while>
        <set_value name="$nextbuyoffercheck" min="player.age + 5min" max="player.age + 10min"/>
      </do_if>

      <set_value name="$buyoffer" exact="null" />

      <!-- sell wares first if less than 50% free cargo -->
      <do_if value="(this.ship.cargo.free)f / this.ship.cargo.capacity" max="0.5">
        <resume label="sellwares" />
      </do_if>
      <do_else>
        <debug_text text="player.age + ' looking good, starting new mining run'" chance="$debugchance" />
      </do_else>

      <!-- safety check -->
      <do_if value="not this.ship.cluster.exists">
        <set_value name="$failreason" exact="'ERR_NO_CLUSTER'" />
        <set_value name="$failreason2" exact="'Good bye cruel world! ' + this.ship" />
        <resume label="finish" />
      </do_if>

      <!-- command action -->
      <set_command_action commandaction="commandaction.searchingresources" />

      <!-- find a buyoffer for the mineable wares in this cluster, split into sector searches to keep the spikes lower 
      go to a random sector in the cluster and look for offers there, then a random matching offer is chosen -->
      <find_sector space="this.ship.cluster" multiple="true" name="$sectors" />
      <do_while value="$sectors.count gt 0">
        <set_value name="$s" min="1" max="$sectors.count" />
        <find_buy_offer tradepartner="this.ship" space="$sectors.{$s}" result="$buyoffer" wares="$availablewares">
          <offeramount min="this.ship.cargo.capacity / 20" entity="this" />
          <!-- NOTE: relevant ware volumes are range from 14 to 18 so this fills at least 70% of our cargo -->
        </find_buy_offer>
        <do_if value="$buyoffer.available">
          <break />
        </do_if>
        <remove_value name="$sectors.{$s}" />
        <wait min="2s" max="5s" />
      </do_while>
      <do_if value="$buyoffer.available">
        <set_value name="$ware" exact="$buyoffer.ware"/>
        <set_value name="$buyer" exact="$buyoffer.buyer"/>
        <debug_text text="player.age + ' %1 in zone %2 wants %3 units of %4'.[$buyer.knownname, $buyer.zone.knownname, $buyoffer.amount, $buyoffer.ware.name]" chance="$debugchance" />
      </do_if>
      <do_else>
        <debug_text text="player.age + ' could not find any buyoffer, waiting...'" chance="$debugchance" />
        <wait chance="0" />
        <set_value name="$idletime" min="50s" max="70s"/>
        <run_script name="'move.idle.vanilla40'" sinceversion="3">
          <param name="TimeOut" value="$idletime" />
        </run_script>
        <resume label="loop"/>
      </do_else>

      <label name="findware" />
      <!-- now check if we can find a deposit of the needed resource nearby -->
      <debug_text text="player.age + ' now looking for %1...'.[$ware]" chance="$debugchance" />
      <find_resource ware="$ware" refobject="this.ship" zone="$zone" wares="$secwares" minamount="this.ship.cargo.{$ware}.free" />
      <do_if value="not $zone.exists">
        <debug_text text="player.age + ' failed finding %1!'.[$ware]" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_FIND_WARE'" />
        <resume label="finish" />
      </do_if>
      <!-- remove wares that we should not or can not sell from the secwares list -->
      <do_if value="$sellablewares? and $secwares.count gt 0">
        <do_if value="$sellablewares.count == 0">
          <set_value name="$secwares" exact="[]"/>
        </do_if>
        <do_else>
          <do_all exact="$secwares.count" counter="$i" reverse="true">
            <do_if value="$sellablewares.indexof.{$secwares.{$i}} == 0">
              <remove_value name="$secwares.{$i}"/>
            </do_if>
          </do_all>
        </do_else>
      </do_if>
      <debug_text text="player.age + ' there is %1 in zone %2'.[$ware, $zone.knownname]" chance="$debugchance" />

      <label name="movetocollect" />
      <!-- TODO: pre-flight check, calculate jump energy for trip to resource and back home, ensure we have enough fuel -->
      <!-- TODO: don't just go to the zone center, find an asteroid/gas cloud... and go there -->
      <run_script name="'move.generic.vanilla40'">
        <param name="destination" value="$zone" />
        <param name="endintargetzone" value="true" />
        <param name="debugchance" value="$debugchance" />
      </run_script>
      <wait min="1s" max="3s" />
      <do_if value="this.zone == $zone" >
        <debug_text text="player.age + ' destination reached'" chance="$debugchance" />
      </do_if>
      <do_else>
        <debug_text text="'Destination %1 not reached. Try other place'.[$zone]" />
        <resume label="loop" />
      </do_else>

      <do_if value="not $zone.exists">
        <resume label="findware" />
      </do_if>

      <label name="collect"/>
      <!-- collecting is done in an external script -->
      <run_script name="'mining.ship.collect.vanilla40'">
        <param name="zone" value="$zone"/>
        <param name="ware" value="$ware"/>
        <param name="secwares" value="$secwares"/>
        <param name="debugchance" value="$debugchance"/>
      </run_script>
      <run_script name="'lib.recall.drones.vanilla40'" sinceversion="1" />


      <label name="sellwares" />

      <!-- safety check -->
      <do_if value="not this.ship.cluster.exists">
        <set_value name="$failreason" exact="'ERR_NO_CLUSTER'" />
        <set_value name="$failreason2" exact="'Good bye cruel world! ' + this.ship" />
        <resume label="finish" />
      </do_if>

      <set_command_action commandaction="commandaction.searchingtrades" />
      <debug_text text="player.age + ' trying to sell wares...'" chance="$debugchance" />

      <do_if value="@$capacityfactor lt 1">
        <set_value name="$capacityfactor" exact="1" />
      </do_if>

      <!-- Find a ware in the ship cargo to sell -->
      <set_value name="$Possible_Wares" exact="this.ship.cargo.list" />
      <set_value name="$fuelindex" exact="$Possible_Wares.indexof.{ware.fuelcells}" />
      <do_if value="$fuelindex gt 0">
        <remove_value name="$Possible_Wares.{$fuelindex}" />
      </do_if>

      <!-- if we have wares that cannot be sold in this area, just dump them -->
      <do_if value="$sellablewares?">
        <do_all exact="$Possible_Wares.count" counter="$i">
          <set_value name="$possibleware" exact="$Possible_Wares.{$i}"/>
          <do_if value="$sellablewares.indexof.{$possibleware} == 0">
            <set_value name="$amount" exact="this.ship.cargo.{$possibleware}.count"/>
            <drop_cargo object="this.ship" ware="$possibleware" min="($amount * 0.2f)i" max="($amount * 0.8f)i" amounts="$droppedamounts" wares="$droppedwares"/>
            <do_all exact="$droppedwares.count" counter="$d" chance="$debugchance">
              <debug_text text="'%1 (%2) dropped %3 %4 because that ware is unsellable in %5'.[this.ship.knownname, this.ship, $droppedamounts.{$d}, $droppedwares.{$d}, this.cluster.knownname]"/>
            </do_all>
          </do_if>
        </do_all>
      </do_if>

      <do_if value="$Possible_Wares.count" exact="0">
        <!-- If we are here, the ship has nothing to sell -->
        <debug_text text="this.ship.pilot + ' has nothing to sell.'" chance="$debugchance" />
        <remove_value name="$capacityfactor" />
        <wait min="5s" max="10s" sinceversion="7" />
        <resume label="loop" />
      </do_if>

      <!-- find a buyoffer for the mineable wares in this cluster, split into sector searches to keep the spikes lower -->
      <set_value name="$preferredsector" exact="$startsector" />
      <do_if value="this.ship.isclass.ship_s or this.ship.isclass.ship_m">
        <set_value name="$preferredsector" exact="this.sector" />
      </do_if>
      <do_all exact="$Possible_Wares.count" counter="$w">
        <set_value name="$Ware" exact="$Possible_Wares.{$w}" />
        <!-- Set the amount to sell (on first attempt, all of them)  -->
        <set_value name="$Amount_In_Cargo" exact="this.ship.cargo.{$Ware}.count" />
        <set_value name="$Amount_To_Sell" exact="$Amount_In_Cargo / $capacityfactor" />
        <debug_text text="this.name + ' trying to sell ' + $Amount_To_Sell + ' of ' + $Ware + ' in ' + $preferredsector.knownname" chance="$debugchance" />
        <find_buy_offer tradepartner="this.ship" space="$preferredsector" result="$buyoffer" wares="$Ware">
          <offeramount min="$Amount_To_Sell" entity="this"/>
        </find_buy_offer>
        <do_if value="$buyoffer.available">
          <break />
        </do_if>
        <wait min="2s" max="5s" sinceversion="6" />
        <do_if value="not $preferredsector?">
          <!-- in case we saved in the above wait, this will initialise the variable -->
          <set_value name="$preferredsector" exact="this.sector" />
        </do_if>
      </do_all>
      <do_if value="not @$buyoffer.available">
        <find_sector space="this.ship.cluster" multiple="true" name="$sectors" />
        <set_value name="$sectorindex" exact="$sectors.indexof.{$preferredsector}" />
        <remove_value name="$sectors.{$sectorindex}" />
        <remove_value name="$sectorindex" />

        <do_while value="$sectors.count gt 0">
          <set_value name="$s" min="1" max="$sectors.count" />
          <do_all exact="$Possible_Wares.count" counter="$w">

            <set_value name="$Ware" exact="$Possible_Wares.{$w}" />
            <!-- Set the amount to sell (on first attempt, all of them)  -->
            <set_value name="$Amount_In_Cargo" exact="this.ship.cargo.{$Ware}.count" />
            <set_value name="$Amount_To_Sell" exact="$Amount_In_Cargo / $capacityfactor" />
            <debug_text text="this.name + ' trying to sell ' + $Amount_To_Sell + ' of ' + $Ware + ' in ' + $sectors.{$s}.knownname" chance="$debugchance" />

            <find_buy_offer tradepartner="this.ship" space="$sectors.{$s}" result="$buyoffer" wares="$Ware">
              <offeramount min="$Amount_To_Sell" entity="this"/>
            </find_buy_offer>
            <do_if value="$buyoffer.available">
              <break />
            </do_if>
            <wait min="2s" max="5s" sinceversion="6" />
          </do_all>
          <do_if value="$buyoffer.available">
            <break />
          </do_if>
          <remove_value name="$sectors.{$s}" />
          <wait min="2s" max="5s" />
        </do_while>
      </do_if>
      <do_if value="$buyoffer.available">
        <set_value name="$ware" exact="$buyoffer.ware"/>
        <set_value name="$buyer" exact="$buyoffer.buyer"/>
        <debug_text text="player.age + ' %1 in zone %2 wants %3 units of %4'.[$buyer.knownname, $buyer.zone.knownname, $buyoffer.amount, $buyoffer.ware.name]" chance="$debugchance" />
      </do_if>
      <do_else>
        <debug_text text="player.age + ' could not find any buyoffer, waiting...'" chance="$debugchance" />
        <wait chance="0" />
        <set_value name="$idletime" min="50s" max="70s"/>
        <run_script name="'move.idle.vanilla40'" sinceversion="3">
          <param name="TimeOut" value="$idletime" />
        </run_script>
        <do_if value="@$capacityfactor lt 1">
          <set_value name="$capacityfactor" exact="1" />
        </do_if>
        <do_else>
          <set_value name="$capacityfactor" exact="($capacityfactor * 1.5 + 0.5)i" />
          <do_if value="$capacityfactor gt (this.ship.cargo.capacity / 10)">
            <!-- we've failed selling stuff many times, get out of the sellwares loop -->
            <remove_value name="$capacityfactor" />
            <resume label="loop"/>
          </do_if>
        </do_else>
        <resume label="sellwares"/>
      </do_else>
      <remove_value name="$capacityfactor" />

      <!-- TODO: pre-flight check, calculate jump energy for trip to resource and back home, ensure we have enough fuel -->
      <run_script name="'move.generic.vanilla40'">
        <param name="destination" value="$buyer" />
        <param name="debugchance" value="$debugchance" />
      </run_script>
      <wait min="1s" max="3s" />
      <do_if value="@$buyer.exists">
        <do_if value="(this.zone == $buyer.zone) or (this.ship.distanceto.{$buyer} lt ($buyer.size * 2f))" >
          <debug_text text="player.age + ' destination reached'" chance="$debugchance" />
        </do_if>
        <do_else>
          <debug_text text="'Buyer is %1 in %2(%3), we are at %7 in %4(%5), distance to buyer is %6'.[$buyer.knownname, $buyer.zone.knownname, $buyer.sector.knownname, this.zone.knownname, this.sector.knownname, this.ship.distanceto.{$buyer}, this.ship.position]" />
        </do_else>
      </do_if>
      <do_else>
        <debug_text text="player.age + ' no buyer exists'" chance="$debugchance" />
        <resume label="sellwares" />
      </do_else>

      <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
        <!-- big ships park -->
        <do_if value="not $buyoffer.available">
          <resume label="sellwares"/>
        </do_if>
        <debug_text text="player.age + ' moving to park at ' + $buyer.knownname" chance="$debugchance" />
        <run_script name="'move.park.vanilla40'" result="$parkresult">
          <param name="destination" value="$buyer" />
          <param name="tradeoffer" value="$buyoffer" />
        </run_script>
        <do_if value="$parkresult">
          <debug_text text="player.age + ' now parked at ' + $buyer.knownname" chance="$debugchance" />
        </do_if>
        <do_elseif value="this.$reevaluate_parking?">
          <remove_value name="this.$reevaluate_parking" />
          <debug_text text="player.age + ' need to re-evaluate our reason for parking at' + $buyer.knownname" chance="$debugchance" />
          <resume label="sellwares" />
        </do_elseif>
        <do_else>
          <debug_text text="player.age + ' critical parking error!'" chance="$debugchance" />
          <resume label="loop" />
        </do_else>
      </do_if>
      <do_else>
        <!-- small ships dock -->
        <debug_text text="player.age + ' moving to dock...'" chance="$debugchance" />
        <run_script name="'move.dockat.vanilla40'" result="$dockresult">
          <param name="destination" value="$buyer" />
        </run_script>
        <do_if value="not $dockresult">
          <wait chance="0" />
          <set_value name="$idletime" min="50s" max="70s"/>
          <run_script name="'move.idle.vanilla40'" sinceversion="3">
            <param name="TimeOut" value="$idletime" />
          </run_script>
          <resume label="sellwares"/>
        </do_if>
        <debug_text text="player.age + ' successfully docked'" chance="$debugchance" />
      </do_else>

      <label name="unload" />
      <!-- unload our ware and any other ware that the buyer can use -->
      <do_if value="$buyer.isoperational">
        <create_list name="$unloadlist" />
        <!-- step 1: build list of stuff to unload and reserve amounts -->
        <find_buy_offer buyer="$buyer" wares="this.ship.cargo.list" tradepartner="this.ship" result="$resourceoffers" multiple="true" />
        <do_if value="$resourceoffers.count == 0">
          <remove_value name="$resourceoffers" />
          <!-- small ships can wait inside the dock until it can unload, big ships are idling before parking already -->
          <do_if value="this.ship.isclass.ship_m or this.ship.isclass.ship_s">
            <remove_value name="$resourceoffers" />
            <remove_value name="$reserved" />
            <set_command_action commandaction="commandaction.standingby" />
            <wait min="2min" max="5min" />
            <run_script name="null" sinceversion="3" chance="0" />
            <resume label="sellwares" />
          </do_if>
        </do_if>
        <do_else>
          <do_all counter="$r" exact="$resourceoffers.count">
            <set_value name="$offer" exact="$resourceoffers.{$r}" />
            <do_if value="not $offer.available">
              <continue />
            </do_if>
            <set_value name="$currentware" exact="$offer.ware" />
            <set_value name="$amount" exact="$offer.offeramount.{this}" />
            <do_if value="this.ship.cargo.{$currentware}.count lt $amount">
              <set_value name="$amount" exact="this.ship.cargo.{$currentware}.count" />
            </do_if>
            <do_if value="$amount gt 0">
              <add_ware_reservation type="sell" ware="$currentware" amount="$amount" entity="this" object="$buyer" replace="true" result="$reserved" />
              <do_if value="$reserved gt 0">
                <debug_text text="player.age + ': reserved %1 %2 for unloading at buyer %5(%6) (have %3, buyer has room for %4)'.[$reserved, $currentware, this.ship.cargo.{$currentware}.count, $buyer.cargo.{$currentware}.free, $buyer.knownname, $buyer]" chance="$debugchance" />
                <append_to_list name="$unloadlist" exact="[$currentware, $reserved]" />
              </do_if>
            </do_if>
          </do_all>
          <remove_value name="$resourceoffers" />
          <remove_value name="$reserved" />
          <!-- step 2: unload wares -->
          <set_value name="$leftovers" exact="false" />
          <do_all exact="$unloadlist.count" counter="$u">
            <set_value name="$currentware" exact="$unloadlist.{$u}.{1}" />
            <set_value name="$amount" exact="$unloadlist.{$u}.{2}" />
            <debug_text text="player.age + ' unloading %1 units of %2 to %3...'.[$amount, $currentware, $buyer.knownname]" chance="$debugchance" />
            <execute_custom_trade buyer="$buyer" seller="this.ship" amount="$amount" ware="$currentware" result="$traderesult" />
            <do_if value="not $traderesult">
              <debug_text text="player.age + ': unloading FAILED! tried to transfer %1 %2 to %3(%4)'.[$amount, $currentware, $buyer.knownname, $buyer]" chance="$debugchance" />
            </do_if>
            <do_else>
              <debug_text text="player.age + ' %1(job: \'%5\') unloaded %2 units of \'%3\' at \'%4\', traderesult: %5'.[this.ship.knownname, $amount, $currentware, $buyer.knownname, this.ship.job, $traderesult]" chance="$debugchance2" />
            </do_else>
            <remove_ware_reservation type="sell" entity="this" object="$buyer" ware="$currentware" />
            <detach_from_masstraffic object="this.ship" wait="true">
              <interrupt_after_time time="5min" />
            </detach_from_masstraffic>
            <do_if value="not $unloadlist?">
              <!-- when loading a save that was created while the above execute_custom_trade action was in progress in a < 3.0 game, the $unloadlist list might not exist, abort and start the unload process properly again -->
              <resume label="unload" />
            </do_if>
          </do_all>
        </do_else>
        <detach_from_masstraffic object="this.ship" wait="true">
          <interrupt_after_time time="5min" />
        </detach_from_masstraffic>
        <wait min="2s" max="5s" />
      </do_if>
      <remove_value name="$unloadlist"/>

      <!-- ok, resource gathering run complete, start the next run -->
      <debug_text text="player.age + ' unloading complete, clearing parking area.'" chance="$debugchance" />
      <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
        <debug_text text="player.age + ' un-parking...'" chance="$debugchance" />
        <run_script name="'move.undock.vanilla40'" />
      </do_if>

      <!-- command action -->
      <set_command_action commandaction="commandaction.calculating" />

      <wait chance="0" />
      <set_value name="$idletime" min="20s" max="40s"/>
      <run_script name="'move.idle.vanilla40'" sinceversion="3">
        <param name="TimeOut" value="$idletime" />
      </run_script>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <debug_text text="'%1 doing job %2 has expired, die!'.[this.ship.knownname, this.ship.job]" chance="$debugchance" />
        <set_value name="$bigship" exact="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" />
        <run_script name="'move.die.vanilla40'" sinceversion="2">
          <param name="byjump" value="$bigship" />
          <param name="byhighway" value="not $bigship" />
          <param name="bydock" value="not $bigship" />
          <param name="byidle" value="true" />
        </run_script>
      </do_if>

      <debug_text text="player.age + ' starting new mining run'" chance="$debugchance" />
      <resume label="loop" />

      <label name="finish" />
      <debug_text text="'script ends with reason %1. Looking to gather %5 for job \'%6\'. This ship in %2 (%3), destination %4'.[$failreason, this.ship.zone.knownname, this.ship.position, @$zone.knownname, $warebasket, this.ship.job]" />
      <do_if value="$failreason2?">
        <debug_text text="$failreason2" />
      </do_if>
      <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
        <debug_text text="player.age + ' un-parking...'" chance="$debugchance" />
        <run_script name="'move.undock.vanilla40'" />
      </do_if>

      <run_script name="'move.die.vanilla40'" sinceversion="4">
        <param name="byidle" value="true" />
      </run_script>

    </actions>
  </attention>
  <on_abort>
    <do_if value="@$buyer.exists">
      <remove_ware_reservation object="$buyer" entity="this" virtual="true" />
      <remove_ware_reservation object="$buyer" entity="this" />
    </do_if>
  </on_abort>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="mining.ship.mineplot.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <!--
  This script is used in chapter 2.6 and lets the Amber Excavator mine resources during the plot (leightweight version of mining.ship.free)  
  -->
  <params>
    <param name="basketoverride" default="null" comment="list of wares that takes precedence over any defined warebasket" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler ref="AttackHandler.vanilla40" />
    <handler ref="ScannedHandler.vanilla40" />
  </interrupts>
  <init>
    <set_command command="command.freemining" />
  </init>

  <attention min="unknown">
    <actions>
      <set_value name="$debugchance" exact="100" />
      <set_value name="$debugchance2" exact="100" />

      <!-- basic checks first -->
      <label name="init" />

      <!-- command action -->
      <set_command_action commandaction="commandaction.searchingresources" />
      
      <wait min="5s" max="15s" />

      <do_if value="this.ship.cargo.capacity" max="0">
        <debug_text text="'%1 has cargo capacity of %2!'.[this.ship.knownname, this.ship.cargo.capacity]" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_CARGOSPACE'" />
        <set_value name="$failreason2" exact="'Macro: ' + this.ship.macro.name" />
        <resume label="finish" />
      </do_if>
      <do_if value="this.ship.units.collect.count" exact="0">
        <debug_text text="'mining ship does not have any units for collecting!'" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_COLLECT'" />
        <set_value name="$failreason2" exact="'Macro: %1, Job: %2'.[this.ship.macro.name, this.ship.job]" />
        <resume label="finish" />
      </do_if>
      <do_if value="not $basketoverride">
        <do_if value="this.ship.warebasket.count" exact="0">
          <debug_text text="'mining without warebasket defined in jobs not supported!'" chance="$debugchance" />
          <set_value name="$failreason" exact="'ERR_NO_WAREBASKET'" />
          <set_value name="$failreason2" exact="'Job: ' + this.ship.job" />
          <resume label="finish" />
        </do_if>
        <set_value name="$warebasket" exact="this.ship.warebasket.list" />
      </do_if>
      <do_else>
        <set_value name="$warebasket" exact="$basketoverride" />
      </do_else>

      <!-- find mineable wares within the cluster -->
      <create_list name="$availablewares" exact="0"/>
      <debug_text text="player.age + ' searching for wares...'" chance="$debugchance"/>
      <do_all exact="$warebasket.count" counter="$i">
        <set_value name="$ware" exact="$warebasket.{$i}"/>
        <find_closest_resource ware="$ware" refobject="this.ship" zone="$zone" wares="$secwares"/>
        <do_if value="$zone.exists">
          <do_if value="this.ship.cluster" exact="$zone.cluster">
            <append_to_list name="$availablewares" exact="$ware"/>
            <debug_text text="player.age + ' there is %1 in this cluster'.[$ware]" chance="$debugchance"/>
          </do_if>
        </do_if>
      </do_all>
      <do_if value="$availablewares.count" exact="0">
        <debug_text text="'unable to find any ware that can be collected by this ship in this cluster!'" chance="$debugchance"/>
        <set_value name="$failreason" exact="'ERR_NO_WARES'"/>
        <resume label="finish"/>
      </do_if>

      <!-- primary loop start -->
      <label name="loop" />

      <label name="findware" />
      <!--Try to find wares, starting with the first in the list-->
      <do_all exact="$availablewares.count" counter="$Counter">
        <set_value name="$ware" exact="$availablewares.{$Counter}"/>
        <!-- now check if we can find a deposit of the needed resource nearby -->
        <debug_text text="player.age + ' now looking for %1...'.[$ware]" chance="$debugchance" />
        <find_closest_resource ware="$ware" refobject="this.ship" zone="$zone" wares="$secwares" minamount="this.ship.cargo.{$ware}.free" />
        <do_if value="$zone.exists">
          <debug_text text="player.age + ' there is %1 in zone %2'.[$ware, $zone.knownname]" chance="$debugchance" />
          <!-- collecting is done in an external script -->
          <run_script name="'mining.ship.collect.vanilla40'">
            <param name="zone" value="$zone"/>
            <param name="ware" value="$ware"/>
            <param name="secwares" value="$secwares"/>
            <param name="debugchance" value="$debugchance"/>
          </run_script>
          <run_script name="'lib.recall.drones.vanilla40'" sinceversion="1" />

          <!--Try to find next ware-->
          <resume label="findware"/>
        </do_if>
        <do_else>
          <debug_text text="player.age + ' failed finding %1!'.[$ware]" chance="$debugchance" />
        </do_else>
      </do_all>
      
      <label name="finish" />
      <debug_text text="'script ends with reason ' + $failreason" />
      <do_if value="$failreason2?">
        <debug_text text="$failreason2" />
      </do_if>
      <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
        <debug_text text="player.age + ' un-parking...'" chance="$debugchance" />
        <run_script name="'move.undock.vanilla40'" />
      </do_if>
      <return />

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="utf-8" ?>
<aiscript name="mining.ship.player.vanilla40" version="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--
  This script controls the mining ship, that is assisting the player. It can either just
  follow the player and launch drones to pick up chunks for the player or do some mining
  simultaneously (that option should only be available if it has mining turrets).
  by Benedikt
  -->
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
  </interrupts>
  <attention min="unknown">
    <actions>
      <set_value name="$debugoutputchance" exact="0"/>
      <set_value name="$dronelaunchdelay" exact="3s" comment="the minimum delay between two drone launches"/>

      <!-- basic checks first -->
      <label name="init"/>
      <do_if value="this.ship.cargo.capacity" max="0">
        <debug_text text="'%1 has cargo capacity of %2!'.[this.ship.knownname, this.ship.cargo.capacity]" chance="$debugoutputchance" />
        <set_value name="$failreason" exact="'ERR_NO_CARGOSPACE'" />
        <resume label="finish" />
      </do_if>
      <do_if value="this.ship.units.collect.count" exact="0">
        <debug_text text="'this ship does not have any units for collecting!'" chance="$debugoutputchance" />
        <set_value name="$failreason" exact="'ERR_NO_COLLECT'" />
        <resume label="finish" />
      </do_if>
      <do_if value="this.ship.commander" exact="player.primaryship" negate="true">
        <debug_text text="'this ship is not commanded by the player!'" chance="$debugoutputchance" />
        <set_value name="$failreason" exact="'ERR_NO_COMMANDER'" />
        <resume label="finish" />
      </do_if>

      <label name="loop"/>

      <create_group groupname="$asteroidgroup"  />

      <set_value name="$moving" exact="false"/>
      <do_while value="(this.ship.cargo.free)f / this.ship.cargo.capacity" min="0.05">

        <!-- set the action to fly to player -->
        <set_command_action commandaction="commandaction.flyingto" param="player.primaryship" />

        <do_if value="this.ship.commander" exact="player.primaryship" negate="true">
          <debug_text text="player.age + ' the player is no longer commanding this ship, aborting...'" chance="$debugoutputchance"/>
          <resume label="stop"/>
        </do_if>
        <do_while value="@player.ship.zone.isclass.highway">
          <!-- wait until the player has left the highway -->
          <wait min="3s" />
        </do_while>
        <do_if value="this.ship.distanceto.{player.primaryship}" min="50km">
          <!-- jump to the player ship -->
          <wait exact="10s" chance="0"/>
          <debug_text text="player.age + ' moving/jumping to player ship...'" chance="$debugoutputchance"/>
          <run_script name="'move.generic.vanilla40'">
            <param name="destination" value="player.primaryship" />
            <param name="debugoutputchance" value="$debugoutputchance" />
          </run_script>
          <wait min="1s" max="3s" />
          <debug_text text="player.age + ' successfully moved/jumped'" chance="$debugoutputchance"/>
        </do_if>
        <do_if value="this.ship.distanceto.{player.primaryship}" min="2.5km">
          <do_if value="$moving">
            <!-- update the player position if necessary -->
            <do_if value="player.primaryship.distanceto.{$cachedplayerpos}" min="1km">
              <set_value name="$cachedplayerpos" exact="player.primaryship.position"/>
              <run_script name="'move.undock.vanilla40'" />
              <debug_text text="player.age + ' updated player position...'" chance="$debugoutputchance"/>
              <move_to object="this.ship" destination="player.primaryship" finishonapproach="true" forceposition="false">
                <interrupt_after_time time="1s"/>
              </move_to>
            </do_if>
          </do_if>
          <do_else>
            <!-- start moving and cache player position -->
            <set_value name="$moving" exact="true"/>
            <set_value name="$cachedplayerpos" exact="player.primaryship.position"/>
            <debug_text text="player.age + ' moving to player ship...'" chance="$debugoutputchance"/>
            <run_script name="'move.undock.vanilla40'" />
            <move_to object="this.ship" destination="player.primaryship" finishonapproach="true">
              <interrupt_after_time time="1s"/>
            </move_to>
          </do_else>
        </do_if>
        <do_if value="this.ship.distanceto.{player.primaryship}" max="2.5km">
          <!-- close to the player, stop moving -->
          <do_if value="$moving">
            <set_value name="$moving" exact="false"/>
            <stop_moving object="this.ship" immediate="false"/>
            <debug_text text="player.age + ' movement stopped'" chance="$debugoutputchance"/>
          </do_if>
        </do_if>

        <!-- this is for debug output only -->
        <set_value name="$freechunks" exact="0"/>
        <debug_text text="'wait for shoot'" chance="$debugoutputchance" />

        <!-- set the action to search/wait for asteroids -->
        <set_command_action commandaction="commandaction.searchingresources" />

        <!-- Wait for the player's actions -->
        <wait sinceversion="1">
          <interrupt>
            <conditions>
              <check_any>
                <event_object_tagged tagger="player.primaryship" />
                <event_player_attacked_object />
              </check_any>
              <check_object object="event.param" class="class.asteroid" />
            </conditions>
            <actions>
              <set_value name="$asteroid" exact="event.param" />
              <!-- Add a big asteroid to turrets list -->
              <do_if value="event.name" exact="'event_player_attacked_object'">
                <debug_text text="'player attack: ' + $asteroid" chance="$debugoutputchance" />
                <do_if value="not $asteroid.canbepickedup">
                  <debug_text text="$asteroid.knownname + ' is Big (can not be picked up)'" chance="$debugoutputchance" />
                  <!-- Update the Big asteroids list -->
                  <add_to_group groupname="$asteroidgroup" object="$asteroid" />
                  <!-- manage a list with a group-->
                  <create_list name="$asteroidlist" />
                  <do_all exact="$asteroidgroup.count" counter="$i">
                    <append_to_list name="$asteroidlist" exact="$asteroidgroup.{$i}" />
                  </do_all>

                  <!-- set turret targets -->
                  <do_if value="$asteroidlist.count" min="1">
                    <set_turret_targets object="this.ship" target="$asteroidlist" weapontype="mining" preferredtarget="$asteroid"/>
                    <debug_text text="'shooting/mining ' + $asteroidlist" chance="$debugoutputchance" />
                  </do_if>
                </do_if>
              </do_if>

              <!-- The player tag an asteroid -->
              <do_if value="event.param" exact="'event_object_tagged'">
                <debug_text text="'player tag: ' + $asteroid" chance="$debugoutputchance" />
              </do_if>

            </actions>
          </interrupt>
          <interrupt_after_time time="$dronelaunchdelay" />
        </wait>

        <!-- evaluate tagged chunks -->
        <do_if value="this.$taggedobjects?">
          <do_all exact="this.$taggedobjects.count" counter="$i" reverse="true">
            <do_if value="not this.$taggedobjects.{$i}.exists">
              <remove_value name="this.$taggedobjects.{$i}" />
              <continue />
            </do_if>
            <do_if value="not this.$taggedobjects.{$i}.parent.isclass.zone">
              <!-- this is usually the case once a drone has picked up the rock -->
              <remove_value name="this.$taggedobjects.{$i}" />
              <continue />
            </do_if>
            <do_if value="not this.$taggedobjects.{$i}.owner or (this.$taggedobjects.{$i}.owner == this.ship.owner)" >
              <set_value name="$dronetarget" exact="this.$taggedobjects.{$i}"/>
              <remove_value name="this.$taggedobjects.{$i}" />
              <break />
            </do_if>
          </do_all>
          <set_value name="$freetagged" exact="this.$taggedobjects.count"/>
        </do_if>
        <do_else>
          <!-- this is for debug output only -->
          <set_value name="$freetagged" exact="0"/>
        </do_else>

        <!-- launch drone to pick up the target -->
        <do_if value="@$dronetarget.exists">
          <launch_drone name="$drone" object="this.ship" group="unitcategory.orecollector" exact="1"/>

          <wait exact="$dronelaunchdelay"/>

          <do_if value="$drone.isoperational">
            <debug_text text="'%1 drone launched [tagged: %2, chunks: %3]'.[player.age, $freetagged, $freechunks]" chance="$debugoutputchance"/>
            <start_script name="'mining.ship.drone.vanilla40'" object="$drone.pilot">
              <param name="homebase" value="this.ship" />
              <param name="target" value="$dronetarget"/>
            </start_script>
            <set_owner object="$dronetarget" faction="this.ship.owner"/>
            <!-- now clear the drone target -->
            <set_value name="$dronetarget" exact="null"/>
          </do_if>
          <do_else>
            <debug_text text="'%1 no drone available [tagged: %2, chunks: %3]'.[player.age, $freetagged, $freechunks]" chance="$debugoutputchance"/>
          </do_else>
        </do_if>
        <do_else>
          <debug_text text="'%1 no target available [tagged: %2, chunks: %3]'.[player.age, $freetagged, $freechunks]" chance="$debugoutputchance"/>
        </do_else>

      </do_while>
      <debug_text text="player.age+': less than 5% free cargo space'" chance="$debugoutputchance"/>
      <!-- TODO: inform player about this -->

      <!-- TODO: we can define what happens next here -->
      <label name="stop"/>
      <stop_moving object="this.ship" immediate="false"/>

      <do_if value="this.$taggedobjects?">
        <do_if value="this.$taggedobjects.count" min="1">
          <debug_text text="player.age + ' removed %1 tagged objects from the blackboard'.[this.$taggedobjects.count]" chance="$debugoutputchance"/>
        </do_if>
        <remove_value name="this.$taggedobjects" />
      </do_if>

      <!-- TODO: the ship should probably resume its last task now -->
      <!--<resume_last_task/>-->
      <return/>

      <label name="finish"/>
      <debug_text text="player.age + ' script ends with reason ' + $failreason"/>
      <return/>

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="mining.ship.station.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="6">
  <!--
  This script will try to automatically supply its homebase and will only work
  with valid warebasket and homebase parameters (defined via jobs). It can do
  gas and mineral mining and works for all ship classes.
  by Michael and Benedikt
  -->
  <params>
    <param name="warebasket" default="null" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler ref="AttackHandler.vanilla40" />
    <handler ref="ScannedHandler.vanilla40" />
  </interrupts>
  <init>
    <set_command command="command.freemining" />
  </init>
  <patch sinceversion="6">
    <!-- all reservations have been wiped as of 4.0, if we are currently processing the $unloadlist restore reservations for the current and remaining items -->
    <do_if value="$homebase.exists and $unloadlist? and $u?">
      <do_all exact="$unloadlist.count" counter="$u_patch">
        <do_if value="$u_patch ge $u">
          <add_ware_reservation type="sell" ware="$unloadlist.{$u_patch}.{1}" amount="$unloadlist.{$u_patch}.{2}" entity="this" object="$homebase" replace="true" />
        </do_if>
      </do_all>
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>
      <set_value name="$debugchance" exact="0" />
      <set_value name="$debugchance2" exact="0" />

      <!-- basic checks first -->
      <label name="init" />

      <!-- command action -->
      <set_command_action commandaction="commandaction.calculating" />

      <wait min="5s" max="15s" />

      <do_if value="this.ship.cargo.capacity" max="0">
        <debug_text text="'%1 has cargo capacity of %2!'.[this.ship.knownname, this.ship.cargo.capacity]" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_CARGOSPACE'" />
        <resume label="finish" />
      </do_if>
      <do_if value="not this.ship.commander.exists">
        <debug_text text="'%1 in %2: mining without commander not supported!'.[this.ship.knownname, this.ship.zone.knownname]" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_HOMEBASE'" />
        <resume label="finish" />
      </do_if>
      <set_value name="$homebase" exact="this.ship.commander" />
      <do_if value="this.ship.units.collect.count" exact="0">
        <debug_text text="'mining ship does not have any units for collecting!'" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_COLLECT'" />
        <resume label="finish" />
      </do_if>
      <do_if value="$warebasket == null">
        <set_value name="$warebasket" exact="this.ship.warebasket.list" />
      </do_if>
      <do_if value="$warebasket.count" exact="0">
        <debug_text text="'mining without warebasket defined in jobs not supported!'" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_WAREBASKET'" />
        <resume label="finish" />
      </do_if>

      <!-- unload first if less than 50% free cargo -->
      <do_if value="(this.ship.cargo.free)f / this.ship.cargo.capacity" max="0.5">
        <resume label="returnhome" />
      </do_if>
      <do_else>
        <debug_text text="player.age + ' looking good, starting new mining run'" chance="$debugchance" />
      </do_else>

      <!-- primary loop start -->
      <label name="loop" />
      <set_value name="$failcount" exact="0" />

      <!-- update the wares we deal with for a new trade run - ensure that we don't miss any wares if the list has changed due to the homebase being expanded -->
      <do_if value="this.ship.commander.isoperational">
        <set_value name="$resources" exact="this.ship.commander.resources.list" />
        <do_all exact="$resources.count" counter="$i">
          <set_value name="$ware" exact="$resources.{$i}" />
          <do_if value="($ware.tags.indexof.{tag.minable}) and (this.ship.cargo.{$ware}.max gt 0)">
            <do_if value="this.ship.units.collect.{$ware}.count gt 0">
              <do_if value="$warebasket.indexof.{$ware}" exact="0">
                <append_to_list name="$warebasket" exact="$ware" />
              </do_if>
            </do_if>
          </do_if>
        </do_all>
        <!-- support working for trade stations / warehouses as well -->
        <set_value name="$tradewares" exact="this.ship.commander.tradewares.list" />
        <do_all exact="$tradewares.count" counter="$i">
          <set_value name="$ware" exact="$tradewares.{$i}" />
          <do_if value="($ware.tags.indexof.{tag.minable}) and (this.ship.cargo.{$ware}.max gt 0)">
            <do_if value="this.ship.units.collect.{$ware}.count gt 0">
              <do_if value="$warebasket.indexof.{$ware}" exact="0">
                <append_to_list name="$warebasket" exact="$ware" />
              </do_if>
            </do_if>
          </do_if>
        </do_all>
        <debug_text text="'updating warebasket on %1(%2) to collect %3'.[this.ship.knownname, this.ship, $warebasket]" chance="$debugchance" />
        <remove_value name="$resources" />
        <remove_value name="$tradewares" />
      </do_if>

      <!-- clear ware for new iteration -->
      <set_value name="$ware" exact="null" />

      <!-- we build our shopping list by intersecting our warebasket and the resources of our homebase -->
      <label name="buildshoppinglist" />
      <create_list name="$shoppinglist" exact="0" />
      <find_buy_offer buyer="$homebase" multiple="1" result="$buyoffers" wares="$warebasket" tradepartner="this.ship" />
      <debug_text text="player.age + ' homebase %1 [%2] has %3 offers for %4'.[$homebase.knownname, $homebase, $buyoffers.count, $warebasket]" chance="$debugchance" />
      <set_value name="$neededAmount" exact="0" />
      <do_if value="$buyoffers.count" min="1">
        <!-- use the buyoffers on our homebase to determine resource need -->
        <set_value name="$needed" exact="-10000" comment="needpct can become negative if more than what is needed is already expected to be delivered, we don't want errors because $ware is not defined" />
        <do_all counter="$b" exact="$buyoffers.count">
          <set_value name="$buyoffer" exact="$buyoffers.{$b}" />
          <get_ware_reservation object="$homebase" type="sell" ware="$buyoffer.ware" virtual="true" result="$reserved" />
          <debug_text text="player.age + ' %1 wants %5(want %2, expecting %4) units of %3'.[$homebase.knownname, $buyoffer.offeramount.{this}, $buyoffer.ware, $reserved, $buyoffer.offeramount.{this} - $reserved]" chance="$debugchance" />
          <do_if value="this.ship.units.collect.{$buyoffer.ware}.count" min="1">
            <append_to_list name="$shoppinglist" exact="$buyoffer.ware" />
            <set_value name="$needpct" exact="1f - (($homebase.cargo.{$buyoffer.ware}.count + @$reserved)f / ($buyoffer.offeramount.{this} + $homebase.cargo.{$buyoffer.ware}.count))" />
            <do_if value="$needpct gt $needed">
              <set_value name="$needed" exact="$needpct" />
              <set_value name="$neededAmount" exact="$buyoffer.offeramount.{this}" />
              <set_value name="$ware" exact="$buyoffer.ware" />
            </do_if>
          </do_if>
        </do_all>
        <do_if value="$reserved?">
          <remove_value name="$reserved" />
        </do_if>
      </do_if>
      <!-- if there are no valid buyoffers, look for the ware that our homebase has the least amount of (%-wise) -->
      <!-- disabled because we don't want that at the moment (maybe we can use it later to continue mining slowly)
      <do_else>
        <set_value name="$maxcargopct" exact="1.0" />
        <do_all counter="$w" exact="$homebase.cargo.count">
          <do_all counter="$b" exact="$warebasket.count">
            <do_if value="$homebase.cargo.list.{$w}" exact="$warebasket.{$b}">
              <set_value name="$currentware" exact="$warebasket.{$b}" />
              <do_if value="this.ship.units.collect.{$currentware}.count" min="1">
                <append_to_list name="$shoppinglist" exact="$currentware" />
                <set_value name="$warepct" exact="($homebase.cargo.{$currentware}.count)f / $homebase.cargo.{$currentware}.max" />
                <debug_text text="player.age + ' %1 stores %2 (capacity: %3)'.[$homebase.knownname, $currentware, $warepct * 100]" chance="$debugchance" />
                <do_if value="$warepct lt $maxcargopct">
                  <set_value name="$maxcargopct" exact="$warepct" />
                  <set_value name="$ware" exact="$currentware" />
                </do_if>
              </do_if>
            </do_if>
          </do_all>
        </do_all>
      </do_else>
      <do_if value="$shoppinglist.count" exact="0">
        <debug_text text="'unable to find any ware that is useful to our homebase and can be collected by this ship!'" chance="$debugchance" />
        <set_value name="$failreason" exact="'ERR_NO_WARES'" />
        <resume label="finish" />
      </do_if>-->
      <do_if value="$shoppinglist.count" exact="0">
        <debug_text text="player.age + ' unable to find an appropriate buyoffer, waiting...'" chance="$debugchance" />
        <wait chance="0" />
        <set_value name="$idletime" min="30s" max="90s"/>
        <run_script name="'move.idle.vanilla40'" sinceversion="1">
          <param name="TimeOut" value="$idletime" />
        </run_script>
        <resume label="loop"/>
      </do_if>

      <!-- min amount of ware. Default: max free space in cargo ship or amount homebase wants, whichever is the smaller value -->
      <set_value name="$minAmountWare" exact="this.ship.cargo.{$ware}.free" />
      <do_if value="$minAmountWare gt $neededAmount">
        <set_value name="$minAmountWare" exact="$neededAmount" />
      </do_if>
      <add_ware_reservation type="sell" amount="$minAmountWare" entity="this" object="$homebase" duration="5h" virtual="true" ware="$ware" />

      <label name="findware" />

      <!-- command action -->
      <set_command_action commandaction="commandaction.searchingresources" />

      <!-- now check if we can find a deposit of the needed resource nearby -->
      <debug_text text="player.age + ' now looking for %1...'.[$ware]" chance="$debugchance" />

      <!-- only use the closest resource finder for player property - otherwise too many ships focus on very few zones causing issues with too many drones flying and killing performance -->
      <do_if value="$homebase.isplayerowned">
        <find_closest_resource ware="$ware" refobject="$homebase" zone="$zone" wares="$secwares" minamount="$minAmountWare" />
      </do_if>
      <do_else>
        <find_resource ware="$ware" refobject="$homebase" zone="$zone" wares="$secwares" minamount="$minAmountWare" />
      </do_else>
      <!-- If a zone is found -->
      <do_if value="not $zone.exists">
        <!-- try other ware -->
        <do_if value="$failcount lt $shoppinglist.count">
          <set_value name="$failcount" exact="$failcount + 1" />
          <debug_text text="player.age + ' could not find any zone that contains ' + $minAmountWare + ' of ' + $ware" chance="$debugchance" />
          <set_value name="$ware" exact="$shoppinglist.{$failcount}" />
          <wait min="5s" max="30s" />
          <resume label="findware" />
        </do_if>
        <do_else>

          <!-- Try less ware amount, just for security -->
          <do_if value="$minAmountWare gt 10">
            <set_value name="$minAmountWare" exact="$minAmountWare / 2" />
            <set_value name="$failcount" exact="0" />
            <debug_text text="player.age + ' trying with less amount for all wares ' + $minAmountWare " chance="$debugchance" />
            <wait min="1s" max="5s" />
            <resume label="findware" />
          </do_if>

          <!-- Impossible to find any resources with any amount (should not happends)-->
          <run_script name="'move.idle.vanilla40'">
            <param name="TimeOut" value="5min" />
          </run_script>
          <debug_text text=" 'end of idle script '" chance="$debugchance" />
          <set_value name="$firstIdle" exact="true" />
          <resume label="loop"/>
        </do_else>
      </do_if>
      <debug_text text="player.age + ' there is %1 in zone %2'.[$ware, $zone.knownname]" chance="$debugchance" />

      <label name="movetocollect" />
      <!-- TODO: pre-flight check, calculate jump energy for trip to resource and back home, ensure we have enough fuel -->
      <!-- TODO: don't just go to the zone center, find an asteroid/gas cloud... and go there -->
      <do_if value="not $zone.exists">
        <resume label="findware" />
      </do_if>
      <set_command command="command.mining" param="$zone" />

      <run_script name="'move.generic.vanilla40'">
        <param name="destination" value="$zone" />
        <param name="endintargetzone" value="true" />
        <param name="debugchance" value="$debugchance" />
      </run_script>
      <wait min="1s" max="3s" />
      <do_if value="this.zone == $zone" >
        <debug_text text="player.age + ' destination reached'" chance="$debugchance" />
      </do_if>
      <do_else>
        <debug_text text="'Destination %1 not reached. Try other place'.[$zone]" />
        <resume label="loop" />
      </do_else>

      <do_if value="not $zone.exists">
        <resume label="findware" />
      </do_if>

      <label name="collect"/>
      <!-- clean up secwares so we don't collect minerals our homebase does not need -->
      <set_value name="$homebaseresources" exact="$homebase.resources.list" />
      <do_all exact="$secwares.count" reverse="true" counter="$w">
        <do_if value="$homebaseresources.indexof.{$secwares.{$w}} == 0">
          <debug_text text="'miner not interested in ' + $secwares.{$w}" chance="$debugchance2" />
          <remove_value name="$secwares.{$w}" />
        </do_if>
      </do_all>
      <!-- collecting is done in an external script -->
      <run_script name="'mining.ship.collect.vanilla40'">
        <param name="zone" value="$zone"/>
        <param name="ware" value="$ware"/>
        <param name="secwares" value="$secwares"/>
        <param name="debugchance" value="$debugchance"/>
      </run_script>
      <run_script name="'lib.recall.drones.vanilla40'" sinceversion="3" />

      <label name="returnhome" />
      <debug_text text="player.age + ' returning to %1 in %2...'.[$homebase.knownname, $homebase.zone.knownname]" chance="$debugchance" />
      <do_if value="$homebase.exists">

        <do_if value="this.zone != $homebase.zone" >
          <!-- TODO: pre-flight check, calculate jump energy for trip to resource and back home, ensure we have enough fuel -->
          <run_script name="'move.generic.vanilla40'">
            <param name="destination" value="$homebase" />
            <param name="debugchance" value="$debugchance" />
          </run_script>
          <wait min="1s" max="3s" />
          <do_if value="(this.zone == $homebase.zone) or (this.ship.distanceto.{$homebase} lt ($homebase.size * 2f))" >
            <debug_text text="player.age + ' destination reached'" chance="$debugchance" />
          </do_if>
          <do_else>
            <debug_text text="'Homebase is %1 in %2(%3), we are at %7 in %4(%5), distance to homebase is %6'.[$homebase.knownname, $homebase.zone.knownname, $homebase.sector.knownname, this.zone.knownname, this.sector.knownname, this.ship.distanceto.{$homebase}, this.ship.position]" />
          </do_else>
        </do_if>
        <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
          <find_buy_offer buyer="$homebase" result="$buyoffer" tradepartner="this.ship" wares="this.ship.cargo.list" comment="result may be null, that's ok" />
          <do_if value="not $buyoffer.available">
            <!-- we can't unload wares at the moment, idle for a while, then try again -->
            <set_value name="$idletime" min="2min" max="5min"/>
            <run_script name="'move.idle.vanilla40'" sinceversion="2">
              <param name="TimeOut" value="$idletime" />
            </run_script>
            <resume label="loop"/>
          </do_if>
          <do_else>
            <debug_text text="player.age + ' moving to park at homebase ' + $homebase.knownname" chance="$debugchance" />
            <run_script name="'move.park.vanilla40'" result="$parkresult">
              <param name="destination" value="$homebase" />
              <param name="tradeoffer" value="$buyoffer" />
            </run_script>
            <do_if value="$parkresult">
              <debug_text text="player.age + ' now parked at homebase ' + $homebase.knownname" chance="$debugchance" />
            </do_if>
            <do_elseif value="this.$reevaluate_parking?">
              <remove_value name="this.$reevaluate_parking" />
              <debug_text text="player.age + ' need to re-evaluate our reason for parking at' + $targetobject.knownname" chance="$debugchance" />
              <resume label="returnhome" />
            </do_elseif>
            <do_else>
              <debug_text text="player.age + ' critical parking error!'" chance="$debugchance" />
              <resume label="loop" />
            </do_else>
          </do_else>
        </do_if>
        <do_else>
          <debug_text text="player.age + ' moving to dock...'" chance="$debugchance" />
          <run_script name="'move.dockat.vanilla40'" result="$dockresult">
            <param name="destination" value="$homebase" />
          </run_script>
          <do_if value="not $dockresult">
            <wait chance="0" />
            <set_value name="$idletime" min="30s" max="90s"/>
            <run_script name="'move.idle.vanilla40'" sinceversion="1">
              <param name="TimeOut" value="$idletime" />
            </run_script>
            <resume label="loop" />
          </do_if>
          <debug_text text="player.age + ' successfully docked'" chance="$debugchance" />
        </do_else>
      </do_if>
      <do_else>
        <set_value name="$failreason" exact="'ERR_HOMEBASE_DEAD'" />
        <resume label="finish" />
      </do_else>

      <label name="unload" />
      <!-- unload our ware and any other ware that our homebase can use -->
      <do_if value="$homebase.exists">
        <do_while value="not $homebase.isoperational">
          <wait chance="0" />
          <set_value name="$idletime" min="30s" max="90s"/>
          <run_script name="'move.idle.vanilla40'" sinceversion="1">
            <param name="TimeOut" value="$idletime" />
          </run_script>
        </do_while>

        <create_list name="$unloadlist" />
        <!-- step 1: build list of stuff to unload and reserve amounts -->
        <find_buy_offer buyer="$homebase" wares="this.ship.cargo.list" tradepartner="this.ship" result="$resourceoffers" multiple="true" />
        <do_if value="$resourceoffers.count == 0">
          <remove_value name="$resourceoffers" />
          <!-- small ships can wait inside the dock until it can unload, big ships are idling before parking already -->
          <do_if value="this.ship.isclass.ship_m or this.ship.isclass.ship_s">
            <set_command_action commandaction="commandaction.standingby" />
            <wait min="2min" max="5min" sinceversion="5" />
            <resume label="unload" />
          </do_if>
        </do_if>
        <do_else>
          <do_all counter="$r" exact="$resourceoffers.count">
            <set_value name="$offer" exact="$resourceoffers.{$r}" />
            <do_if value="not $offer.available">
              <continue />
            </do_if>
            <set_value name="$currentware" exact="$offer.ware" />
            <set_value name="$amount" exact="$offer.offeramount.{this}" />
            <do_if value="this.ship.cargo.{$currentware}.count lt $amount">
              <set_value name="$amount" exact="this.ship.cargo.{$currentware}.count" />
            </do_if>
            <do_if value="$amount gt 0">
              <add_ware_reservation type="sell" ware="$currentware" amount="$amount" entity="this" object="$homebase" replace="true" result="$reserved" />
              <do_if value="$reserved gt 0">
                <debug_text text="player.age + ': reserved %1 %2 for unloading at homebase %5(%6) (have %3, homebase has room for %4)'.[$reserved, $currentware, this.ship.cargo.{$currentware}.count, $homebase.cargo.{$currentware}.free, $homebase.knownname, $homebase]" chance="$debugchance" />
                <append_to_list name="$unloadlist" exact="[$currentware, $reserved]" />
              </do_if>
            </do_if>
          </do_all>
          <remove_value name="$resourceoffers" />
          <remove_value name="$reserved" />
          <!-- step 2: unload wares -->
          <set_value name="$leftovers" exact="false" />
          <do_all exact="$unloadlist.count" counter="$u">
            <set_value name="$currentware" exact="$unloadlist.{$u}.{1}" />
            <set_value name="$amount" exact="$unloadlist.{$u}.{2}" />
            <debug_text text="player.age + ' unloading %1 units of %2 to %3...'.[$amount, $currentware, $homebase.knownname]" chance="$debugchance" />
            <execute_custom_trade buyer="$homebase" seller="this.ship" amount="$amount" ware="$currentware" result="$traderesult" />
            <do_if value="not $traderesult">
              <debug_text text="player.age + ': unloading FAILED! tried to transfer %1 %2 to %3(%4)'.[$amount, $currentware, $homebase.knownname, $homebase]" chance="$debugchance" />
            </do_if>
            <do_else>
              <debug_text text="player.age + ' %1(job: \'%5\') unloaded %2 units of \'%3\' at \'%4\', traderesult: %5'.[this.ship.knownname, $amount, $currentware, $homebase.knownname, this.ship.job, $traderesult]" chance="$debugchance2" />
            </do_else>
            <remove_ware_reservation type="sell" entity="this" object="$homebase" ware="$currentware" />
            <detach_from_masstraffic object="this.ship" wait="true">
              <interrupt_after_time time="5min" />
            </detach_from_masstraffic>
            <do_if value="not $unloadlist?">
              <!-- when loading a save that was created while the above execute_custom_trade action was in progress in a < 1.24 game, the $unloadlist list might not exist, abort and start the unload process properly again -->
              <resume label="unload" />
            </do_if>
          </do_all>
        </do_else>
        <detach_from_masstraffic object="this.ship" wait="true">
          <interrupt_after_time time="5min" />
        </detach_from_masstraffic>
        <wait min="2s" max="5s" />
        <!-- step 3: see what's left in the cargo hold -->
        <!--
        <set_value name="$cargolist" exact="this.ship.cargo.list" />
        <do_all exact="$cargolist.count" counter="$c">
          <set_value name="$currentware" exact="$cargolist.{$c}" />
          <do_if value="($homebase.resources.{$currentware}.exists) or ($homebase.tradewares.{$currentware}.exists)">
            
          </do_if>
        </do_all>
        -->
      </do_if>

      <!-- ok, resource gathering run complete, start the next run -->
      <debug_text text="player.age + ' unloading complete, clearing parking area.'" chance="$debugchance" />
      <remove_ware_reservation object="$homebase" entity="this" virtual="true" />
      <remove_ware_reservation object="$homebase" entity="this" />
      <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
        <debug_text text="player.age + ' un-parking...'" chance="$debugchance" />
        <run_script name="'move.undock.vanilla40'" />
      </do_if>
      <wait chance="0" />
      <set_value name="$idletime" min="30s" max="50s"/>
      <run_script name="'move.idle.vanilla40'" sinceversion="1">
        <param name="TimeOut" value="$idletime" />
      </run_script>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <debug_text text="'%1 doing job %2 has expired, die!'.[this.ship.knownname, this.ship.job]" chance="$debugchance" />
        <set_value name="$bigship" exact="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" />
        <run_script name="'move.die.vanilla40'" sinceversion="4">
          <param name="byjump" value="$bigship" />
          <param name="byhighway" value="not $bigship" />
          <param name="bydock" value="not $bigship" />
          <param name="byidle" value="true" />
        </run_script>
      </do_if>

      <debug_text text="player.age + ' starting new mining run'" chance="$debugchance" />
      <resume label="loop" />

      <label name="finish" />
      <!-- DEBUG DISABLED TEMPORARILY DUE TO MISSING REGIONS CAUSING SPAM -->
      <debug_text text="player.age + ' script ends with reason ' + $failreason" />
      <return />

    </actions>
  </attention>
  <on_abort>
    <do_if value="$homebase.exists">
      <remove_ware_reservation object="$homebase" entity="this" virtual="true" />
      <remove_ware_reservation object="$homebase" entity="this" />
    </do_if>
  </on_abort>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="mission.escortconvoy.behaviours.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

  Mission Behaviour script for Escorting ships
  by Owen
  
  The MD library RML_Escort_Convoy waits for its ships to be signalled via <event_object_signalled group="$ConvoyGroup" param="'RML_Escort_Convoy'" param2="true"/>
  param  = 'RML_Escort_Convoy'
  param2 = BOOL: Was the ship successful or not. If not, the player may not be credited for succesfully escorting it.
  
  This AI script is run on the ships of $ConvoyGroup and when they are finished their task (e.g docking or flying to a position) they will be signalled.
  
  ***NOTE***
  This does not have to be the only script which can be used with RML_Escort_Convoy.
  As long as the object is signalled with the correct parameters you can create your own replacement behaviours.

  -->
  <params>
    <param name="Command" comment="STRING: 'dock' or 'flyto'"/>
    <param name="CommandTarget" comment="'dock':  Either the Dockslot or the Container (e.g. station)
                                         'flyto': The object or zone to fly to"/>
    
    <param name="Offset" default="null" comment="Optional for 'flyto'"/>
    <param name="debugchance" default="0"/>
  </params>
  <attention min="unknown">
    <actions>
      <set_value name="$Result" exact="false"/>
      <do_if value="$CommandTarget">
        
        <do_if value="$Command" exact="'dock'">
          <do_if value="typeof $CommandTarget == datatype.componentslot">
            <run_script name="'move.dockat.vanilla40'" result="$Result">
              <param name="dockingslot" value="$CommandTarget"/>
            </run_script>
          </do_if>
          <do_elseif value="typeof $CommandTarget == datatype.component">
            <run_script name="'move.dockat.vanilla40'" result="$Result">
              <param name="destination" value="$CommandTarget"/>
            </run_script>
          </do_elseif>
          <do_else>
            <debug_text text="'Dock CommandTarget was neither a component nor componentslot'"/>
          </do_else>
        </do_if>

        <do_elseif value="$Command" exact="'flyto'">
          <run_script name="'move.generic.vanilla40'" result="$Result">
            <param name="destination" value="$CommandTarget"/>
            <param name="position" value="$Offset"/>
          </run_script>
        </do_elseif>

        <do_else>
          <debug_text text="'Unknown command'"/>
        </do_else>

      </do_if>
      <signal_objects object="this.ship" param="'RML_Escort_Convoy'" param2="$Result"/>
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.autopilot.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <params>
    <param name="target" />
    <param name="targetpos" default="position.[0, 0, 0]" />
    <param name="isguidance" default="false" />
  </params>
  <interrupts>
    <handler>
      <conditions>
        <check_all>
          <check_any>
            <event_object_signalled object="this.ship" param="'guidance_updated'" />
            <event_object_signalled object="this.ship" param="'guidance_ended'" />
          </check_any>
          <check_value value="$isguidance" />
        </check_all>
      </conditions>
      <actions>
        <do_if value="event.param == 'guidance_updated'">
          <debug_text text="'guidance updated'" chance="$debugchance" />
          <set_value name="$target" exact="event.param2" />
          <abort_called_scripts resume="start" />
        </do_if>
        <do_else>
          <debug_text text="'guidance ended, stopping autopilot'" chance="$debugchance" />
          <abort_called_scripts resume="end" />
        </do_else>
      </actions>
    </handler>
  </interrupts>
  <patch sinceversion="3">
    <set_value name="$isguidance" exact="false" />
  </patch>
  <attention min="visible">
    <actions>

      <label name="start" />

      <set_value name="$debugchance" exact="0" />

      <!-- <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.steering" /> -->

      <do_if value="$target.isclass.zone">
        <debug_text text="'autopilot activated, flying to %1 (pos: %2, isguidance: %3)'.[$target.knownname, $targetpos, $isguidance]" chance="$debugchance" />
      </do_if>
      <do_else>
        <debug_text text="'autopilot activated, flying to %1 in %2 (pos: %3, isguidance: %4)'.[$target.knownname, @$target.zone.knownname, $targetpos, $isguidance]" chance="$debugchance" />
      </do_else>

      <!-- Set the command -->
      <do_if value="$target.isclass.ship">
        <debug_text text="'follow ship'" chance="$debugchance" />
        <set_command command="command.follow" param="$target" />
      </do_if>
      <do_elseif value="$target.isclass.zone">
        <debug_text text="'fly to zone'" chance="$debugchance" />
        <set_command command="command.movetozone" param="$target" />
      </do_elseif>
      <do_else>
        <debug_text text="'fly to object'" chance="$debugchance" />
        <set_command command="command.move" param="$target" />
      </do_else>

      <!-- Subposition calculations -->
      <do_if value="$target.infopoint">
        <set_value name="$subtargetpos" exact="$target.infopoint.staticoffset" />
        <set_value name="$targetpos" exact="$subtargetpos" />
      </do_if>
      <do_elseif value="$target.isclass.dockingbay">
        <set_value name="$subtargetpos" exact="$target.dockslot.todockpos" />
        <set_value name="$targetpos" exact="$subtargetpos" />
      </do_elseif>

      <label name="loop" />

      <!-- Autopilot loop, while target is operational -->
      <do_while value="$target.isoperational">
        <debug_text text="'target = %1 [%2], zone = %3 [%4]'.[$target.knownname, $target, @$target.zone.knownname, @$target.zone]" chance="$debugchance" />

        <set_value name="$tooclose" exact="false" />
        <set_value name="$forcesteering" exact="false" />
        <set_value name="$allowhighways" exact="true" />
        <do_if value="$target.isclass.ship">
          <do_if value="($target.zone == this.zone) or ((this.ship.distanceto.{$target} lt 25km) and (not $target.zone.isclass.highway))">
            <set_value name="$forcesteering" exact="true" />
          </do_if>
          <do_elseif value="this.zone.isclass.highway">
            <do_if value="$target.zone.distanceto.{this.zone.destination} lt 25km">
              <set_value name="$forcesteering" exact="true" />
            </do_if>
          </do_elseif>
        </do_if>
        <set_value name="$interrupted" exact="true" />
        <do_if value="$forcesteering">
          <set_value name="$targetrot" exact="rotation.[0,0,0]" />
        </do_if>
        <do_elseif value="$target.isclass.highway">
          <set_value name="$allowhighways" exact="false" />
          <set_value name="$targetpos" exact="$target.closestpointtoplayer" />
          <set_value name="$targetrot" exact="rotation.[0,0,0]" />
        </do_elseif>
        <do_elseif value="$target.isclass.zone">
          <set_value name="$targetrot" exact="rotation.[0,0,0]" />
          <get_safe_pos result="$targetpos" zone="$target" radius="this.ship.size" object="$target" value="$targetpos" />
        </do_elseif>
        <do_elseif value="$target.isclass.gate">
          <get_gate_approach_pos ship="this.ship" gate="$target" position="$targetpos" rotation="$targetrot" />
        </do_elseif>
        <do_else>
          <set_value name="$targetrot" exact="rotation.[0,0,0]" />
          <do_if value="not $target.isclass.object">
            <set_value name="$maintarget" exact="$target.container" />
            <do_if value="$maintarget.exists">
              <do_if value="this.ship.distanceto.{$maintarget} lt ($maintarget.size / 2.f) ">
                <set_value name="$tooclose" exact="true" />
              </do_if>
            </do_if>
          </do_if>
          <do_if value="not @$tooclose">
            <do_if value="($target.zone == this.zone) or ((this.ship.distanceto.{$target} lt 25km) and (not $target.zone.isclass.highway))">
              <get_safe_pos result="$targetpos" zone="$target.zone" radius="this.ship.size * 2.f" object="$target" value="$targetpos" directionobject="this.ship" ignored="this.ship" />
              <create_orientation name="$targetrot" orientation="look_at" refobject="$target" >
                <position value="$targetpos" />
              </create_orientation>
              <create_position name="$targetpos" object="$target.zone" space="$target" value="$targetpos" />
            </do_if>
          </do_if>
        </do_else>
        <do_if value="not $forcesteering and not this.zone.isclass.highway">
          <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.spline" />
        </do_if>
        <do_if value="not @$tooclose">
          <move_to object="this.ship" usehighways="$allowhighways" destination="$target" abortpath="true" flightbehaviour="flightbehaviour.playerautopilot2" forcesteering="$forcesteering" finishonapproach="false" forceposition="false">
            <position value="$targetpos" />
            <rotation value="$targetrot" comment="rotation node is important, otherwise the internal targetoffset will have an incorrect rotation" />
            <interrupt>
              <conditions>
                <check_any>
                  <event_object_changed_zone object="$target" />
                  <event_object_destroyed object="$target" />
                  <event_object_docked object="$target" />
                  <check_all>
                    <event_object_approaching_waypoint object="this.ship" lastwaypoint="true" />
                    <check_value value="not $target.isclass.ship" />
                    <check_value value="not $target.isclass.highway" />
                  </check_all>
                </check_any>
              </conditions>
              <actions>
                <debug_text text="'%1: param = %2, param2 = %3'.[event.name, event.param, event.param2]" chance="$debugchance" />
                <do_if value="event.name == 'event_object_changed_zone'">
                  <set_value name="$interrupted" exact="false" />
                </do_if>
              </actions>
            </interrupt>
          </move_to>
        </do_if>
        <do_if value="$interrupted">
          <!-- the move_to finished, exit gracefully -->
          <do_if value="not $target.isclass.object and not $target.isclass.highway and $subtargetpos?">
            <!-- target is a subcomponent -->
            <debug_text text="'move to subcomponent'" chance="$debugchance" />
            <move_to usehighways="true" object="this.ship" destination="$target" abortpath="true" flightbehaviour="flightbehaviour.playerautopilot2" forcesteering="$forcesteering" finishonapproach="false" forceposition="false" sinceversion="1">
              <position value="$subtargetpos" />
              <rotation yaw="0deg" comment="rotation node is important, otherwise the internal targetoffset will have an incorrect rotation" />
              <interrupt>
                <conditions>
                  <event_object_destroyed object="$target" />
                </conditions>
              </interrupt>
            </move_to>
          </do_if>
          <do_elseif value="$target.isclass.gate">
            <!-- target is a jumpgate -->
            <debug_text text="'move to gate'" chance="$debugchance" />
            <do_if value="this.cluster != $target.destination.cluster">
              <move_gate object="this.ship" gate="$target" abortpath="true" sinceversion="2">
                <interrupt>
                  <conditions>
                    <event_object_changed_cluster object="this.ship" />
                  </conditions>
                  <actions>
                    <debug_text text="'just changed from cluster %1 to cluster %2 (moved through gate)'.[event.param2.knownname, event.param.knownname]" chance="$debugchance" />
                  </actions>
                </interrupt>
              </move_gate>
            </do_if>
            <do_else>
              <debug_text text="'already there, skipping move_to'" chance="$debugchance" />
            </do_else>
          </do_elseif>
          <break />
        </do_if>
      </do_while>

      <label name="end" />

      <do_if value="$target.isclass.highway">
        <!-- when using autopilot to enter a highway we want the throttle set to max speed -->
        <set_playership_throttle value="1" />
      </do_if>
      <do_elseif value="$subtargetpos?">
        <!-- when using autopilot to fly to a sub-component, we want the throttle to make us stop flying -->
        <set_playership_throttle value="0" />
      </do_elseif>

      <debug_text text="'arrived / target docked'" chance="$debugchance" />

      <stop_boost object="this.ship" />
      <stop_player_autopilot />

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="utf-8" ?>
<aiscript name="move.buildership.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <!--

  Move to Script
  by Michael
  
  Generic routine for moving to a specific location.

  -->
  <params>
    <param name="destination" comment="build location or station"/>
    <param name="macro" default="null" comment="macro of object to be built"/>
    <param name="debugchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
  </interrupts>
  <attention min="unknown">
    <actions>
      <label name="start" />
      
      <do_if value="typeof $destination == datatype.componentmacroslot and $macro">
        <do_if value="not $destination.child">
          <set_value name="$zone" exact="$destination.component"/>
        </do_if>
      </do_if>
      <do_elseif value="typeof $destination == datatype.component">
        <do_if value="not $destination.buildingmodule">
          <set_value name="$zone" exact="$destination.zone"/>
        </do_if>
      </do_elseif>
      
      <do_if value="not $zone?">
        <return value="false"/>
      </do_if>

      <run_script name="'move.undock.vanilla40'" />

      <label name="movetozone"/>
      
      <do_if value="typeof $destination == datatype.componentmacroslot">
        <set_command command="command.movetozone" param="$destination.component" />
      </do_if>
      <do_else>
        <set_command command="command.move" param="$destination" />
      </do_else>

      <leave_formation object="this.ship"/>

      <debug_text text="'check if already in correct zone'" chance="$debugchance" />
      <do_if value="this.ship.zone != $zone">
        <debug_text text="'move to correct zone'" chance="$debugchance" />
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$zone"/>
          <param name="endintargetzone" value="true" />
        </run_script>
      </do_if>

      <label name="movetodestination" />

      <do_if value="typeof $destination == datatype.componentmacroslot">
        <get_building_position position="$position" object="this.ship" macro="$macro" buildlocation="$destination" />
        <set_value name="$lookatpos" exact="$destination.offset"/>
      </do_if>
      <do_elseif value="typeof $destination == datatype.component">
        <get_building_position position="$position" object="this.ship" construction="$destination" />
        <set_value name="$stationpos" exact="$destination.position"/>
        <set_value name="$lookatpos" exact="position.[$stationpos.x, $position.y, $stationpos.z]"/>
      </do_elseif>

      <get_safe_pos result="$safepos" value="$position" radius="this.ship.size" zone="$zone"/>

      <create_orientation name="$rotation" orientation="look_at" refposition="$lookatpos">
        <position value="$safepos" />
      </create_orientation>
      <set_value name="$rotation" exact="rotation.[$rotation.yaw, 0, 0]"/>
      <move_to object="this.ship" destination="$zone" forcerotation="true" abortpath="true">
        <position value="$safepos" />
        <rotation value="$rotation"/>
      </move_to>

      <do_if value="this.ship.distanceto.{$safepos}" min="1km">
        <debug_text text="this.ship + ' ' + this.ship.knownname + ' is ' + this.ship.distanceto.{$safepos} + ' away from its destionation. Should be closer [Owen]'"/>
      </do_if>

      <do_if value="typeof $destination == datatype.componentmacroslot">
        <do_if value="$destination.child">
          <!--Build location taken-->
          <signal_objects object="this.ship" param="'move.buildership'" param2="false"/>
        </do_if>
        <do_else>
          <!--Successfully reached build location-->
          <signal_objects object="this.ship" param="'move.buildership'" param2="true"/>
        </do_else>
      </do_if>
      <do_elseif value="typeof $destination == datatype.component">
        <do_if value="$destination.buildingmodule">
          <!--Station already has a building module-->
          <signal_objects object="this.ship" param="'move.buildership'" param2="false"/>
        </do_if>
        <do_else>
          <!--Successfully reached station-->
          <signal_objects object="this.ship" param="'move.buildership'" param2="true"/>
        </do_else>
      </do_elseif>
    </actions>
  </attention>
  <on_abort>
    <!--Ship was aborted-->
    <debug_text text="'aborting move.buildership'"/>
    <signal_objects object="this.ship" param="'move.buildership'" param2="false"/>
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.claim.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <params>
    <param name="target" />
  </params>
  <patch sinceversion="1">
    <set_to_default_flight_control_model object="$target" />
  </patch>
  <attention min="visible">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />

      <do_if value="not $target.isoperational">
        <return value="false" />
      </do_if>

      <set_value name="$startship" exact="this.ship" />

      <run_script name="'droneability.launch.vanilla40'" />

      <label name="move" />

      <move_to destination="$target" object="this.ship" flightbehaviour="flightbehaviour.default" finishonapproach="true" forcesteering="true" />

      <!-- Make sure that the target has default FCM -->
      <set_to_default_flight_control_model object="$target" />
      <!-- Disable my collision with the target -->
      <disable_collisions_between object="this.ship" target="$target" />
      <!-- Try to find the cockpit -->
      <find_object_component class="class.cockpit" object="$target" name="$cockpit" />

      <do_if value="$cockpit.exists">
        <create_position name="$targetpos" object="$cockpit" min="$cockpit.size" space="$target" />
        <move_to destination="$target" object="this.ship" flightbehaviour="flightbehaviour.dock" forcesteering="true" >
          <position value="$targetpos" />
        </move_to>
      </do_if>
      <do_else>
        <move_to destination="$target" object="this.ship" flightbehaviour="flightbehaviour.droneattach" forcesteering="true" />
      </do_else>

      <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.forced" />
      <set_object_active object="this.ship" activate="true" />
      <!-- give the animation some time to play, before we lock it -->
      <wait min="3s" />
      <claim_ship target="$target" pilot="this" />
      <wait min="100ms" />
      <!-- attachment needs to hapen after claim or the pilot will be wrecked! -->
      <!-- DANGER DANGER! do NOT use this.ship here, as this has already been moved to $target in claim_ship, therefore this.ship == $target ! -->
      <attach_object_to_target object="$startship" target="$target" keepoffset="true" />
      <wait min="2s" />

      <do_if value="this.ship == $target">
        <debug_text text="'successfully claimed ' + $target.knownname" chance="$debugoutputchance" />
        <!-- <destroy_object object="$startship" explosion="false" /> -->
        <do_if value="this.isplayerowned">
          <set_value name="stat.ships_claimed" operation="add" />
          <signal_objects object="player.entity" param="'ClaimedShip'" param2="this" delay="10ms" comment="Signal MD listener to start default script" />
        </do_if>
      </do_if>
      <do_else>
        <debug_text text="'claiming ' + $target.knownname + ' failed!'" chance="$debugoutputchance" />
      </do_else>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <set_value name="$debugoutputchance" exact="100" />
      <set_value name="$startship" exact="this.ship" />

      <label name="move" />
      <wait min="10s" max="30s" />

      <claim_ship target="$target" pilot="this" />

      <wait min="1s" max="3s" />

      <do_if value="this.ship == $target">
        <debug_text text="'successfully claimed ' + $target.knownname" chance="$debugoutputchance" />
        <destroy_object object="$startship" explosion="false" />
        <do_if value="this.isplayerowned">
          <set_value name="stat.ships_claimed" operation="add" />
          <signal_objects object="player.entity" param="'ClaimedShip'" param2="this" delay="10ms" comment="Signal MD listener to start default script" />
        </do_if>
      </do_if>
      <do_else>
        <debug_text text="'claiming ' + $target.knownname + ' failed!'" chance="$debugoutputchance" />
      </do_else>

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<!--
this script sends a drone to pick up an object (crate or rock)
-->
<aiscript name="move.collect.drone.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="2">
  <params>
    <param name="homebase" comment="the homebase to return to" />
    <param name="target" comment="the object to pick up" />
    <param name="masstraffic" default="false" comment="is this a masstraffic drone that should return to the appropriate dock?" />
    <param name="stayactive" default="true" comment="should the drone remain in activated animation state?" />
    <param name="launching" default="true" comment="whether this drone is still in its launch movement" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler comment="target destroyed">
      <conditions>
        <check_any>
          <event_object_destroyed object="$target" check="false" />
          <event_object_picked_up object="$target" check="false" />
        </check_any>
        <check_value value="event.param" exact="this.ship" negate="true" />
      </conditions>
      <actions>
        <abort_called_scripts resume="targetlost" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.collect" param="$target"  />
  </init>
  <attention min="visible">
    <actions>

      <label name="start" />

      <label name="launch" />
      <do_if value="$launching">
        <debug_text text="player.age+' launching'" chance="$debugoutputchance" />
        <wait min="1min" max="2min">
          <interrupt>
            <conditions>
              <check_any>
                <event_object_approaching_waypoint object="this.ship" lastwaypoint="true"/>
                <event_object_arrived_at_waypoint object="this.ship" lastwaypoint="true"/>
              </check_any>
            </conditions>
          </interrupt>
        </wait>
        <debug_text text="player.age+' successfully launched'" chance="$debugoutputchance" />
        <clear_collision_filter object="this.ship" />
      </do_if>

      <do_if value="not $target.exists">
        <resume label="targetlost" />
      </do_if>

      <run_script name="'drone.pickup.vanilla40'" result="$success">
        <param name="target" value="$target"/>
        <param name="stayactive" value="$stayactive"/>
        <param name="debugoutputchance" value="$debugoutputchance"/>
      </run_script>

      <do_if value="$success">
        <resume label="dock" />
      </do_if>

      <label name="targetlost" />
      <debug_text text="player.age+' picking up target failed'" chance="$debugoutputchance"/>

      <label name="dock" />
      <!-- The $masstraffic variable is only for Transport/Collector drones (not real masstraffic) -->
      <do_if value="$homebase.isoperational">
        <do_if value="$masstraffic">
          <!-- First it will fly with Generic behaviour, and at the last way point Dock behaviour -->
          <debug_text text="player.age+' returning to homebase %1[%2] in %3 (masstrafficdock)'.[$homebase.knownname, $homebase, $homebase.zone.knownname]" chance="$debugoutputchance"/>
          <dock_masstraffic_drone object="this.ship" destination="$homebase" />
        </do_if>
        <do_else>
          <debug_text text="player.age+' returning to homebase %1[%2] in %3 (dronelaunchpad)'.[$homebase.knownname, $homebase, $homebase.zone.knownname]" chance="$debugoutputchance"/>
          <!-- enable steering fcm temporarily since spline flight has problems with moving targets -->
          <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.steering"/>
          <run_script name="'move.dockat.drone.vanilla40'">
            <param name="destination" value="$homebase" />
          </run_script>
          <assert value="false" text="'\'move.dockat.drone\' returned to visible-block of \'move.collect.drone\' for drone %1 [%2] [ Michael ]'.[this.ship.knownname, this.ship]" />
          <!-- fallback in case we are still not docked -->
          <do_if value="$homebase.isoperational">
            <debug_text text="'drone docking failed, using fallback'" chance="$debugoutputchance"/>
            <dock_drone object="this.ship" homebase="$homebase" />
          </do_if>
          <debug_text text="player.age+' drone docked.'" chance="$debugoutputchance"/>
        </do_else>
      </do_if>

      <!-- we are only down here if docking didn't work, most likely because the homebase is dead, we just wait until the low-attention case cleans up -->
      <stop_moving object="this.ship" />
      <wait sinceversion="1" max="5s" />
      <resume label="dock"/>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <label name="start" />
      <label name="launch" />
      <label name="targetlost" />

      <do_if value="$target.exists">
        <!-- Move to the target and pick it up -->
        <move_to object="this.ship" destination="$target" sinceversion="2" finishonapproach="true" forceposition="false"/>
      </do_if>
      <!-- Pick up the target -->
      <do_if value="$target.exists">
        <pickup_target ship="this.ship" target="$target" />
      </do_if>

      <label name="dock" />

      <!-- Try to fly back -->
      <do_if value="$homebase.isoperational">
        <!-- Move back to home -->
        <move_to object="this.ship" destination="$homebase" finishonapproach="true" forceposition="false" sinceversion="2"/>
      </do_if>
      <!-- cleanup -->
      <do_if value="$homebase.isoperational">
        <!-- Dock -->
        <do_if value="$masstraffic">
          <dock_masstraffic_drone object="this.ship" destination="$homebase" immediate="true" />
          <!-- <return_units object="$homebase" macro="this.ship.macro" /> -->
        </do_if>
        <do_else>
          <run_script name="'move.dockat.drone.vanilla40'">
            <param name="destination" value="$homebase" />
          </run_script>
          <assert value="false" text="'\'move.dockat.drone\' returned to unknown-block of \'move.collect.drone\' for drone %1 [%2] [ Michael ]'.[this.ship.knownname, this.ship]" />
        </do_else>
      </do_if>
      <do_else>
        <destroy_object object="this.ship" explosion="false" />
      </do_else>

      <!-- drone no longer exists if the drone docked successfully -->
      <debug_text text="player.age+' drone docked.'" chance="$debugoutputchance"/>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<!--
Script used by capships to collect crates/objects in space using drones
-->
<aiscript name="move.collect.ship.capship.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="2">
  <params>
    <param name="targets" comment="group of targets to collect"/>
    <param name="debugoutputchance" default="0"/>
  </params>

  <attention min="unknown">
    <actions>
      <label name="start"/>

      <do_if value="not this.defensible.isclass.ship_xl and not this.defensible.isclass.ship_l">
        <debug_text text="this.controllable.knownname + ' is not a capital ship'"/>
        <return value="false"/>
      </do_if>

      <!-- Nothing to pick up -->
      <do_if value="not $targets.count">
        <debug_text text="'%1 has no nothing to pick up %3'.[this.ship.knownname]" chance="$debugoutputchance" />
        <return/>
      </do_if>
      <do_else>
        <add_to_group groupname="$collecttargets" group="$targets"/>
      </do_else>

      <!-- Stop moving -->
      <stop_moving object="this.ship" />

      <label name="collect"/>

      <!-- Safety check -->
      <do_if value="not this.ship.units.{unitcategory.transport}.count">
        <debug_text text="'%1 has no transport drones %3'.[this.ship.knownname]" chance="$debugoutputchance" />
        <return/>
      </do_if>

      <!-- Collect all targets -->
      <do_all exact="@$collecttargets.count" counter="$i" reverse="true">
        <!-- Check if the target exists -->
        <do_if value="@$collecttargets.{$i}.exists">
          <!-- If I have a available transport drone -->
          <do_if value="this.ship.availableunits.{unitcategory.transport}.count">
            <set_value name="$pickuptarget" exact="$collecttargets.{$i}"/>
            <!-- Launch transport drones to pick up the crates -->
            <launch_masstraffic_drone name="$drone" object="this.ship" category="unitcategory.transport" pickup="true" target="$pickuptarget" />
            <!-- If drone was launched-->
            <do_if value="$drone.isoperational">
              <!-- Start collect routine -->
              <start_script name="'move.collect.drone.vanilla40'" object="$drone.pilot">
                <param name="homebase" value="this.ship" />
                <param name="target" value="$pickuptarget"/>
                <param name="masstraffic" value="true"/>
                <param name="stayactive" value="false" comment="deactivate animation after picked up" />
                <param name="debugoutputchance" value="$debugoutputchance"/>
              </start_script>
              <!-- Remove from the group -->
              <remove_from_group group="$collecttargets" object="$pickuptarget" />
              <!-- Give time to the next transport drones -->
              <wait min="3s" max="5s" sinceversion="2" />
            </do_if>
          </do_if>
          <!-- No available units -->
          <do_else>
            <break/>
          </do_else>
        </do_if>
      </do_all>

      <!-- still targets or drones unavailable (if units == available all returned) -->
      <do_if value="@$collecttargets.count or (this.ship.units.{unitcategory.transport}.count != this.ship.availableunits.{unitcategory.transport}.count) ">
        <!-- command action -->
        <set_command_action commandaction="commandaction.waitingdrones" />
        <wait min="10s" max="30s"/>
        <resume label="collect"/>
      </do_if>
      <!-- No remaining targets to collect, but still the initial group has some-->
      <do_elseif value="$targets.count">
        <!-- Retry again? -->
        <do_if value="@$attempt lt 3">
          <set_value name="$attempt" exact="@$attempt + 1" />
          <resume label="start" />
        </do_if>
        <do_else>
          <debug_text text="'Too many collect attempts (%1). Original targets: %2, Collect targets %3'.[$attempt, $targets, $collecttargets]" chance="$debugoutputchance" />
        </do_else>
      </do_elseif>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>

<!--

Script for a ship to collect crates from space
Handled cases:
- small ship collecting crates of inventory wares via flying into it

-->

<aiscript name="move.collect.ship.smallship.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="targets" comment="Crate to pickup" />

    <!-- debugging -->
    <param name="debugoutputchance" default="0" comment="informational debug output"/>
  </params>
  <attention min="unknown">
    <actions>
      <label name="start" />

      <wait min="10ms" max="50ms"/>

      <do_all exact="$targets.count" counter="$i" reverse="true">
        <do_if value="not $targets.{$i}.isclass.collectable">
          <debug_text text="'target ' + $targets.{$i} + ' ' + $targets.{$i}.macro.id + ' is not of class collectable. Removing from group.'" chance="$debugoutputchance"/>
          <remove_from_group group="$targets" object="$targets.{$i}"/>
        </do_if>
        <do_else>
          <set_value name="$wares" exact="$targets.{$i}.wares.list"/>
          <do_all exact="$wares.count" counter="$o">
            <do_if value="$targets.{$i}.unbundle">
              <do_if value="not $wares.{$o}.isinventory and not this.ship.ammostorage.{$wares.{$o}}.free">
                <debug_text text="'target ' + $targets.{$i} + ' ' + $targets.{$i}.macro.id + ' cannot collect contained ware. ' + $wares + ' Removing from group.'" chance="$debugoutputchance"/>
                <remove_from_group group="$targets" object="$targets.{$i}"/>
                <break/>
              </do_if>
            </do_if>
            <do_else>
              <do_if value="not $wares.{$o}.isinventory and not this.ship.cargo.{$wares.{$o}}.free">
                <debug_text text="'target ' + $targets.{$i} + ' ' + $targets.{$i}.macro.id + ' cannot collect contained ware. ' + $wares + ' Removing from group.'" chance="$debugoutputchance"/>
                <remove_from_group group="$targets" object="$targets.{$i}"/>
                <break/>
              </do_if>
            </do_else>
          </do_all>
          <remove_value name="$wares"/>
        </do_else>
      </do_all>

      <do_if value="not $targets.count">
        <return value="true"/>
      </do_if>

      <set_value name="$nearest" exact="null"/>
      <set_value name="$nearestdist" exact="null"/>
      <do_all exact="$targets.count" counter="$i">
        <do_if value="not $nearest and $targets.{$i}.sector == this.sector">
          <set_value name="$nearest" exact="$targets.{$i}"/>
          <set_value name="$nearestdist" exact="$targets.{$i}.distanceto.{this.ship}"/>
        </do_if>
        <do_elseif value="$nearest and $targets.{$i}.sector == this.sector">
          <do_if value="$targets.{$i}.distanceto.{this.ship} lt $nearestdist">
            <set_value name="$nearest" exact="$targets.{$i}"/>
            <set_value name="$nearestdist" exact="$targets.{$i}.distanceto.{this.ship}"/>
          </do_if>
        </do_elseif>
      </do_all>

      <do_if value="$nearest">
        <set_value name="$target" exact="$nearest"/>
      </do_if>
      <do_else>
        <!--Apparently not in the sector of either target, just move to the first in the list-->
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$targets.{1}"/>
          <param name="endintargetzone" value="true"/>
        </run_script>

        <resume label="start"/>
      </do_else>

      <label name="collect"/>

      <run_script name="'move.undock.vanilla40'" />

      <do_if value="not $target.exists">
        <resume label="start"/>
      </do_if>

      <!-- Now there is a target -->
      <set_command command="command.collect" param="$target" />

      <!-- leave formation (if there is any) as that would block our movement -->
      <leave_formation object="this.ship" />

      <!-- if necessary order the ship to move to the correct zone -->
      <debug_text text="'check if already in correct zone'" chance="$debugoutputchance" />
      <do_if value="this.ship.zone != $target.zone">
        <debug_text text="'move to correct zone'" chance="$debugoutputchance" />
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$target"/>
          <param name="endintargetzone" value="true"/>
        </run_script>
      </do_if>

      <label name="movetotarget" />

      <do_if value="not $target.exists">
        <resume label="start"/>
      </do_if>

      <debug_text text="'movetotarget'" chance="$debugoutputchance"/>

      <set_value name="$success" exact="false"/>
      <!--TODO: Better flight behaviour-->
      <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.generic" forcesteering="true" finishonapproach="$target.canbepickedup">
        <interrupt>
          <conditions>
            <event_object_destroyed object="$target"/>
          </conditions>
          <actions>
            <do_if value="event.param == this.ship and event.param2 == killmethod.collected">
              <set_value name="$success" exact="true"/>
            </do_if>
          </actions>
        </interrupt>
      </move_to>
      <stop_moving object="this.ship"/>

      <do_if value="not $success and $target.exists">
        <debug_text text="'Moveto failed to collect the target. May be in low attention, check distance and manaully add'" chance="$debugoutputchance"/>
        <do_if value="this.ship.distanceto.{$target}" max="this.ship.size">
          <collect_drop object="this.ship" drop="$target"/>
          <wait exact="10ms"/>
          <set_value name="$success" exact="true"/>
        </do_if>
      </do_if>

      <!-- Iterate -->
      <do_if value="$targets.count">
        <resume label="start" />
      </do_if>

      <set_to_default_flight_control_model object="this.ship" />

      <return value="$success"/>
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<!--
Script used by ships (excluding drones) to collect crates/objects in space
-->
<aiscript name="move.collect.ship.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1" priority="2">
  <params>
    <param name="targetgroup" comment="group of targets to collect."/>
    <param name="debugoutputchance" default="0"/>
  </params>
  <attention min="unknown">
    <actions>
      <label name="start"/>

      <do_if value="not this.ship.isclass.ship or this.ship.isclass.drone">
        <debug_text text="this.ship.knownname + ' is not a valid ship class for this script'"/>
        <return value="false"/>
      </do_if>

      <label name="findcrates"/>

      <label name="collect"/>

      <do_if value="@$targetgroup.count">
        <!-- Capital or small -->
        <do_if value="this.ship.isclass.[class.ship_l, class.ship_xl]">
          <run_script name="'move.collect.ship.capship.vanilla40'">
            <param name="targets" value="$targetgroup"/>
            <param name="debugoutputchance" value="$debugoutputchance"/>
          </run_script>
        </do_if>
        <do_else>
          <run_script name="'move.collect.ship.smallship.vanilla40'">
            <param name="targets" value="$targetgroup"/>
            <param name="debugoutputchance" value="$debugoutputchance"/>
          </run_script>
        </do_else>

        <wait min="1s" max="2s"/>
      </do_if>
      <do_else>
        <debug_text text="' not targets to collect: group %1'.[$targetgroup]" chance="$debugoutputchance" />
      </do_else>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>

<!--

this script should be able to perform the cleanup of a ship spawned in a mission

-->

<aiscript name="move.die.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="5">
  <params>
    <param name="mintime" default="0s"/>
    <param name="byjump" default="false" />
    <param name="bydock" default="false" />
    <param name="bysale" default="null" />
    <param name="byhighway" default="false" />
    <param name="byhostile" default="false" />
    <param name="byidle" default="true" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler>
      <conditions>
        <event_object_changed_attention object="this.ship" />
        <check_value value="event.param lt attention.visible" />
      </conditions>
      <actions>
        <abort_called_scripts resume="start" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.explore" />
    <set_value name="$StartTime" exact="player.age"/>
  </init>
  <patch sinceversion="3">
    <!-- added new parameter, ensure it is initialized for running scripts -->
    <set_value name="$bysale" exact="null" />
  </patch>
  <attention min="visible">
    <actions>
      <!-- Safety check for player-owned ships -->
      <do_if value="this.ship.isplayerowned">
        <debug_text text="'This player-owned ship is trying to auto-destroy itself!'" filter="error" />
        <return/>
      </do_if>

      <debug_text text="'visible'" chance="$debugoutputchance"/>

      <do_if value="$bysale.exists">
        <!-- bysale implictely means bydock -->
        <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
          <set_value name="$byjump" exact="true" />
        </do_if>
        <do_else>
          <set_value name="$bydock" exact="true" />
        </do_else>
      </do_if>

      <!-- Block all dockslots to prevent the player from docking at this ship -->
      <find_dock_location name="$ship_docks" container="this.ship" size="tag.dock_p" multiple="true"/>
      <do_all exact="$ship_docks.count" counter="$Count">
        <set_room_locked room="$ship_docks.{$Count}.component" locked="true"/>
      </do_all>
      <remove_value name="$ship_docks" />

      <!-- Label to allow us to repeat indefinitely -->
      <label name="start" />
      <set_value name="$Attempt" exact="false" />

      <!-- don't allow the ship to die if the player is on that ship! -->
      <do_while value="player.ship == this.ship">
        <wait sinceversion="4" exact="10s" />
      </do_while>

      <do_if value="not $bydock">
        <run_script name="'move.undock.vanilla40'" />
      </do_if>

      <!--If in a highway, be sure to get out first. Just to be safe if the ship was spawned in a highway and nothing told it what to do yet-->
      <do_if value="this.zone.isclass.highway">
        <run_script name="'move.generic.vanilla40'" sinceversion="2">
          <param name="destination" value="this.zone.destination"/>
        </run_script>
      </do_if>

      <do_if value="$bydock">
        <set_value name="$Attempt" exact="true" />
        <do_if value="$bysale.exists">
          <debug_text text="'MoveDie bysale ' + this.ship + ', sold to: ' + $bysale" chance="$debugoutputchance"/>
          <do_if value="$bysale.isclass.dockingbay">
            <set_value name="$dock" exact="$bysale" />
          </do_if>
          <do_elseif value="$bysale.isclass.container">
            <find_dock_location container="$bysale" size="this.ship.docksize" name="$dock" />
          </do_elseif>
          <do_elseif value="$bysale.isclass.entity">
            <find_dock_location container="$bysale.container" size="this.ship.docksize" name="$dock" />
          </do_elseif>
        </do_if>
        <do_else>
          <debug_text text="'MoveDie bydock ' + this.ship" chance="$debugoutputchance"/>
          <find_station name="$station" space="this.zone">
            <match_relation object="this" relation="neutral" comparison="ge" />
            <match_dock size="this.ship.docksize" />
          </find_station>
          <do_if value="not $station.exists and this.sector">
            <find_station name="$station" space="this.sector">
              <match_relation object="this" relation="neutral" comparison="ge" />
              <match_dock size="this.ship.docksize" />
            </find_station>
          </do_if>
          <do_if value="$station.exists">
            <find_dock_location container="$station" size="this.ship.docksize" name="$dock" />
          </do_if>
        </do_else>
        <do_if value="@$dock">
          <debug_text text="'MoveDie docking at ' + $dock.component" chance="$debugoutputchance"/>
          <run_script name="'move.dockat.vanilla40'" sinceversion="3" result="$success">
            <param name="dockingslot" value="$dock" />
          </run_script>
          <do_if value="$success">
            <destroy_object object="this.ship" explosion="false" />
            <wait sinceversion="3" />
          </do_if>
        </do_if>
        <do_else>
          <debug_text text="'MoveDie could not find a dock to die at'" chance="$debugoutputchance"/>
        </do_else>
      </do_if>

      <do_if value="$byjump">
        <debug_text text="'MoveDie byjump ' + this.ship" chance="$debugoutputchance"/>
        <set_value name="$Attempt" exact="true" />
        <set_value name="$Cluster" exact="null" />
        <find_cluster groupname="$Clusters" multiple="true" presentation="false" />
        <do_if value="$Clusters.count" min="1">
          <do_all exact="$Clusters.count" counter="$Counter">
            <do_if value="$Clusters.{$Counter} != player.cluster">
              <set_value name="$Cluster" exact="$Clusters.{$Counter}" />
              <break />
            </do_if>
          </do_all>
          <do_if value="$Cluster != null">
            <find_zone name="$Targetzone" space="$Cluster" priorityzone="true" tempzone="false">
              <match class="class.highway" negate="true" />
            </find_zone>
            <run_script name="'move.jump.vanilla40'" result="$result">
              <param name="destination" value="$Targetzone" />
              <param name="ignorefuel" value="true" />
              <param name="forcejump" value="true" />
              <param name="nonstop" value="true" />
            </run_script>
          </do_if>
          <do_else>
            <debug_text text="'MoveDie byjump: Jump failed - No non-player Zone found'" chance="$debugoutputchance"/>
          </do_else>
        </do_if>
        <do_else>
          <debug_text text="'MoveDie byjump: Jump failed - No Cluster found'" chance="$debugoutputchance"/>
        </do_else>
      </do_if>

      <do_if value="$byhighway">
        <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l" negate="true">
          <debug_text text="'MoveDie byhighway ' + this.ship" chance="$debugoutputchance"/>
          <set_value name="$Attempt" exact="true" />

          <do_if value="player.zone.isclass.highway">
            <set_value name="$Targetspace" exact="player.zone.destination.sector" />
          </do_if>
          <do_elseif value="player.sector">
            <set_value name="$Targetspace" exact="player.sector" />
          </do_elseif>
          <do_else>
            <set_value name="$Targetspace" exact="this.sector" />
          </do_else>
          <find_zone name="$Targetzone" space="$Targetspace" priorityzone="true" tempzone="false">
            <match class="class.highway" negate="true" />
          </find_zone>
          <remove_value name="$Targetspace" />
          <create_position name="$Pos" space="$Targetzone" max="5km" />
          <do_if value="$Targetzone != player.zone">
            <run_script name="'move.generic.vanilla40'">
              <param name="destination" value="$Targetzone" />
              <param name="position" value="$Pos" />
            </run_script>
          </do_if>
        </do_if>
        <do_else>
          <debug_text text="'MoveDie Ship would not fit into highway ' + this.ship" chance="$debugoutputchance"/>
        </do_else>
      </do_if>

      <do_if value="$byhostile">
        <debug_text text="'MoveDie byhostile ' + this.ship" chance="$debugoutputchance"/>
        <set_value name="$Attempt" exact="true" />
        <run_script name="'move.patrol.vanilla40'"/>
      </do_if>

      <do_if value="$byidle">
        <debug_text text="'MoveDie byidle ' + this.ship" chance="$debugoutputchance"/>
        <set_value name="$Attempt" exact="true" />
        <run_script name="'move.random.vanilla40'" >
          <param name="TimeOut" value="30s" />
        </run_script>
      </do_if>

      <do_if value="not $Attempt">
        <debug_text text="'There was not a working MoveDie attempt ' + this.ship" chance="$debugoutputchance"/>
      </do_if>
      <wait exact="5s" />
      <resume label="start" />
    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <!-- Safety check for player-owned ships -->
      <do_if value="this.ship.isplayerowned">
        <debug_text text="'This player-owned ship is trying to auto-destroy itself!'" filter="error" />
        <return/>
      </do_if>

      <!-- Block all dockslots to prevent the player from docking at this ship -->
      <find_dock_location name="$ship_docks" container="this.ship" size="tag.dock_p" multiple="true"/>
      <do_all exact="$ship_docks.count" counter="$Count">
        <set_room_locked room="$ship_docks.{$Count}.component" locked="true"/>
      </do_all>
      <remove_value name="$ship_docks" />

      <label name="start" />
      <do_if value="$mintime?">
        <do_if value="typeof $mintime == datatype.time and $mintime gt 0">
          <do_if value="(player.age - $StartTime) lt $mintime">
            <wait exact="$mintime" sinceversion="2"/>
            <resume label="start"/>
          </do_if>
        </do_if>
      </do_if>

      <debug_text text="'MoveDie just killed ' + this.ship" chance="$debugoutputchance"/>
      <destroy_object object="this.ship" explosion="false" />
      <!-- infinite wait to stop any actions in calling scripts from running in the same frame -->
      <wait sinceversion="5" />
    </actions>
  </attention>
  <on_abort>
    <!-- Unblock all dockslots again in case this script gets aborted -->
    <find_dock_location name="$ship_docks" container="this.ship" size="tag.dock_p" multiple="true"/>
    <do_all exact="$ship_docks.count" counter="$Count">
      <set_room_locked room="$ship_docks.{$Count}.component" locked="false"/>
    </do_all>
  </on_abort>
</aiscript>

<?xml version="1.0" encoding="iso-8859-1" ?>

<!--

this script should be able to perform all the default checks and make sure a ship docks at the specified destination

-->

<aiscript name="move.dockat.drone.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="5">
  <params>
    <param name="destination" />
    <param name="dronelaunchpad" default="null" />
    <param name="dockfollowers" default="true" />
  </params>
  <init>
    <set_command command="command.dockat" param="$destination" />
    <set_command_action commandaction="commandaction.waitingtodock" />
  </init>
  <attention min="visible">
    <actions>
      <!-- debugging -->
      <set_value name="$debugchance" exact="0" />

      <!-- Label to allow us to repeat indefinitely -->
      <label name="start" />

      <clear_collision_filter object="this.ship" />
      <set_avoid_collisions object="this.ship" enabled="true" />

      <do_if value="not $destination.isoperational">
        <resume label="nolaunchpad" />
      </do_if>

      <do_if value="not this.ship.isclass.ship_xs">
        <debug_text text="player.age + ': move.dockat.drone is only meant for ships of size ship_xs, forwarding to move.dockat...'" />
        <run_script name="'move.dockat.vanilla40'" result="$result">
          <param name="destination" value="$destination" />
          <param name="dockingslot" value="$dockingslot" />
        </run_script>
        <return value="$result"/>
      </do_if>

      <wait min="20ms" max="200ms" />


      <!-- check if there is a suitable dock at the destination at all -->
      <do_if value="not $dronelaunchpad.isoperational">
        <find_object_component object="$destination" name="$dronelaunchpad" class="class.dronelaunchpad" />
      </do_if>

      <do_if value="not $dronelaunchpad.isoperational">
        <debug_text text="player.age + ': could not find valid dronelaunchpad at destination!'" chance="$debugchance" />
        <resume label="nolaunchpad" />
      </do_if>

      <do_if value="not $dockfollowers">
        <!-- if only we should dock, leave current formation -->
        <leave_formation object="this.ship" />
      </do_if>

      <label name="movetozone" />
      
      <do_if value="not $destination.isoperational">
        <resume label="nolaunchpad" />
      </do_if>

      <!-- if necessary order the ship to move to the correct zone -->
      <debug_text text="player.age + ': check if already in correct zone'" chance="$debugchance" />
      <do_if value="this.ship.zone != $destination.zone">
        <debug_text text="player.age + ': move to correct zone'" chance="$debugchance" />
        <do_if value="(this.ship.distanceto.{$destination} lt 30km) and (@this.ship.sector == @$destination.sector)">
          <debug_text text="player.age + ': forcing zone transition at current position'" chance="$debugchance" />
          <move_to object="this.ship" destination="$destination" forcesteering="true" sinceversion="2" finishonapproach="true" usehighways="false">
            <interrupt>
              <conditions>
                <event_object_changed_zone object="$destination" />
              </conditions>
              <actions>
                <resume label="start" />
              </actions>
            </interrupt>            
          </move_to>
        </do_if>
        <do_else>
          <move_to object="this.ship" destination="$destination" finishonapproach="true" forcesteering="true" chance="0"/>
          <debug_text text="player.age + ': leader is too far away, waiting for it to be closer (start timeout)'" chance="$debugchance" />
          <set_value name="$timeout" min="player.age + 10min" max="player.age + 15min" />
          <resume label="nolaunchpad" />
        </do_else>
      </do_if>

      <label name="movetodestination" />

      <do_if value="not $dronelaunchpad.isoperational">
        <resume label="nolaunchpad" />
      </do_if>

      <do_if value="this.ship.zone != $destination.zone">
        <wait min="1s" max="2s" sinceversion="2"/>
        <resume label="movetozone"/>
      </do_if>

      <label name="movetodockingbay" />

      <debug_text text="player.age + ': move to approachpos in single-file formation'" chance="$debugchance" />
      <!-- If there is already a formation, it will only change the shape -->
      <create_formation object="this.ship" formation="formationshape.singlefile" param="this.ship.size * 3" />
      <get_target_points macro="$destination.macro" tags="[tag.ship_xs, tag.dockpath]" result="$targetpoints" />

      <do_if value="$targetpoints.count" min="1">
        <!-- Move to the first safe point. Needed for avoid collision before move_target_points-->
        <move_to object="this.ship" destination="$destination" finishonapproach="true" forcesteering="true">
          <position value="$targetpoints.{1}" />
        </move_to>
      </do_if>

      <!-- safety check, the dronelaunchpad could have been destroyed while we were moving into position -->
      <do_if value="not $dronelaunchpad.isoperational">
        <resume label="nolaunchpad" />
      </do_if>

      <!-- Prepare to enter in the dock slot-->
      <set_command_action commandaction="commandaction.docking" />
      <open_dockingbay_doors dronedock="$dronelaunchpad" />

      <!-- Final step -->
      <break_formation object="this.ship" />
      <!-- tell subordinates to dock as well -->
      <do_if value="$dockfollowers">
        <set_value name="$subordinates" exact="this.ship.subordinates" />
        <do_all exact="$subordinates.count" counter="$i">
          <start_script name="'move.dockat.drone.vanilla40'" object="$subordinates.{$i}.pilot">
            <param name="destination" value="$destination" />
            <param name="dronelaunchpad" value="$dronelaunchpad" />
            <param name="dockfollowers" value="$dockfollowers" />
          </start_script>
          <!-- Change commander of subordinates, to not let them promote when this ship docks -->
          <set_object_commander object="$subordinates.{$i}" commander="this.ship.commander" />
        </do_all>
        <remove_value name="$subordinates" />
      </do_if>

      <!-- With targetpoints, disable the collision avoidance first-->
      <do_if value="$targetpoints.count" min="1">
        <set_avoid_collisions object="this.ship" enabled="false" />
        <!-- move to the remaining target points (if there are) -->
        <move_target_points object="this.ship" destination="$destination" tags="[tag.ship_xs, tag.dockpath]" relativemovement="true" finishonapproach="false" flightbehaviour="flightbehaviour.dronedock" >
          <nextposition value="$dronelaunchpad.position" />
          <interrupt>
            <conditions>
              <event_object_destroyed object="$dronelaunchpad" />
            </conditions>
            <actions>
              <resume label="nolaunchpad" />
            </actions>
          </interrupt>
        </move_target_points>
      </do_if>
      <do_else>
        <!-- move_approach_path not properly working on stations -->
        <!-- Move without targetpoints-->
        <move_approach_path object="this.ship" destination="$destination" dronedock="$dronelaunchpad" finishonapproach="true" relativemovement="true" chance="0" >
          <interrupt>
            <conditions>
              <event_object_destroyed object="$dronelaunchpad" />
            </conditions>
            <actions>
              <resume label="nolaunchpad" />
            </actions>
          </interrupt>
        </move_approach_path>
        <!-- Move to a point in front od the drone launchpad -->
        <create_orientation name="$todockposrot" orientation="look_at" refobject="$dronelaunchpad">
          <position value="$dronelaunchpad.todockpos" object="$dronelaunchpad" />
        </create_orientation>
        <move_to object="this.ship" destination="$dronelaunchpad" finishonapproach="false" forceposition="true" relativemovement="true" sinceversion="4">
          <position value="$dronelaunchpad.todockpos" />
          <rotation value="$todockposrot" />
          <interrupt>
            <conditions>
              <event_object_destroyed object="$dronelaunchpad" />
            </conditions>
            <actions>
              <resume label="nolaunchpad" />
            </actions>
          </interrupt>
        </move_to>
        <!-- It wasn't set to false in this case, set it now -->
        <set_avoid_collisions object="this.ship" enabled="false" />
      </do_else>

      <!-- safety check, the dronelaunchpad could have been destroyed while we were moving into position -->
      <do_if value="not $dronelaunchpad.isoperational">
        <resume label="nolaunchpad" />
      </do_if>

      <label name="movetodockpos" />

      <disable_collisions_between object="this.ship" target="$destination" />
      <debug_text text="player.age + ': move_docking'" chance="$debugchance" />
      <move_docking object="this.ship" dronedock="$dronelaunchpad" abortpath="true" forcesteering="true">
        <interrupt>
          <conditions>
            <event_object_destroyed object="$dronelaunchpad" />
          </conditions>
          <actions>
            <resume label="nolaunchpad" />
          </actions>
        </interrupt>
      </move_docking>

      <wait min="1s" max="4s" sinceversion="3" />

      <!-- Reaching this section means not-docked -->
      <label name="nolaunchpad" />

      <!-- In the case of drone launchpad, destination destroyed or too far away-->
      <do_if value="(not $dronelaunchpad.isoperational) or (not $destination.isoperational) or (this.ship.distanceto.{$destination} ge 30km)">

        <set_command_action commandaction="commandaction.waitingtodock" />
        <wait min="1s" max="5s" sinceversion="1"/>

        <do_if value="not @$timeout">
          <set_value name="$timeout" min="player.age + 2min" max="player.age + 4min" />
        </do_if>

        <do_if value="not $destination.isoperational or player.age gt $timeout">
          <!-- auto-destroy -->
          <destroy_object object="this.ship" explosion="true" />
          <!-- do not let this script return, the drone will be killed in the next frame anyway
          and if we return, any unknown-attention blocks of calling scripts might call this script again which causes problems (multiple ReturnUnit() calls)! -->
          <wait sinceversion="5"/>
        </do_if>
        <do_else>
          <!-- give it another try -->
          <resume label="start" />
        </do_else>
      </do_if>

      <!-- Re-try by default, if the destination and drone launchpad is still ok -->
      <resume label="start" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <label name="start" />
      <label name="movetozone" />
      <label name="movetodestination" />
      <label name="movetodockingbay" />
      <label name="movetodockpos" />
      <label name="nolaunchpad" />

      <do_if value="$destination.isoperational">
        <do_if value="$dockfollowers">
          <do_all exact="this.ship.subordinates.count" counter="$i">
            <start_script name="'move.dockat.drone.vanilla40'" object="this.ship.subordinates.{$i}.pilot">
              <param name="destination" value="$destination" />
              <param name="dronelaunchpad" value="$dronelaunchpad" />
              <param name="dockfollowers" value="$dockfollowers" />
            </start_script>
          </do_all>
        </do_if>
        <!-- this will dock the drone immediately, if there is a launchpad -->
        <dock_drone homebase="$destination" object="this.ship" />
        <wait min="1s" max="2s" sinceversion="3"/>
      </do_if>

      <destroy_object object="this.ship" explosion="false" />


      <!-- do not let this script return, the drone will be killed in the next frame anyway
      and if we return, any unknown-attention blocks of calling scripts might call this script again which causes problems (multiple ReturnUnit() calls)! -->
      <wait sinceversion="3"/>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>

<!--

this script perform all the default checks and make sure a drone docks at Player ship
Author: Adrian

-->

<aiscript name="move.dockat.playerdrone.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <!--Either destination or dockingslot must be valid-->
    <param name="destination" default="player.primaryship" comment="default is player.primaryship" />
    <param name="immediate" default="false" comment="force dock without checking (OOS)" />
    <param name="debugchance" default="0" comment="informational debug output"/>
  </params>
  <interrupts>
    <handler>
      <conditions>
        <event_object_changed_zone object="$destination" />
        <check_value value="event.param.isclass.highway or event.param2.isclass.highway" />
      </conditions>
      <actions>
        <debug_text text="'Interrupt drone docking because %1 entered/exit a highway'.[$destination]" chance="$debugchance" />
        <abort_called_scripts resume="movetodockingbay" />
      </actions>
    </handler>
  </interrupts>
  <attention min="visible">
    <actions>

      <!-- Label to allow us to repeat indefinitely -->
      <label name="start" />

      <do_if value="not this.ship.isclass.ship_xs">
        <debug_text text="player.age + ': ERROR move.dockat.playerdrone is only meant for ships of size ship_xs, END'" />
        <return />
      </do_if>

      <do_if value="not $destination.exists">
        <!--No dock or destination container provided-->
        <debug_text text="'was not provided with valid destination for for \'%1\' (%2)!'.[this.ship.macro.id, this.ship]" chance="$debugchance" />
        <return value="false"/>
      </do_if>

      <!-- check if there is a suitable dock at the destination at all -->
      <find_dock_location container="$destination" name="$dockingslot" size="this.ship.docksize"/>

      <do_if value="$dockingslot == null">
        <debug_text text="'could not find valid docking slot for \'%1\' at destination \'%2\'(%3) - %4!'.[this.ship.macro.id, $destination.macro.id, $destination, this.cluster.knownname]" chance="$debugchance" />
        <return value="false"/>
      </do_if>

      <check_object result="$result" object="$destination">
        <match_relation object="this.ship" comparison="not" relation="enemy"/>
      </check_object>
      <do_if value="not $result">
        <debug_text text="'The destination will not allow ship to dock due to relations'" chance="$debugchance" />
        <return value="false"/>
      </do_if>
      <remove_value name="$result"/>

      <!-- check if we are currently docked -->
      <do_if value="this.ship.dockslot != null">
        <do_if value="this.ship.container" exact="$destination">
          <debug_text text="'we are already docked at our destination!'" chance="$debugchance" />
          <return value="true"/>
        </do_if>

        <!-- <run_script name="'move.undock'" /> -->

      </do_if>

      <!-- check if is a valid dock slot -->
      <do_if value="not $dockingslot.component.exists">
        <debug_text text="'dockingslot was lost. look for new one of size ' + this.ship.docksize + ' on ' + $destination" chance="$debugchance" />
        <find_dock_location name="$dockingslot" container="$destination" size="this.ship.docksize" />
        <do_if value="not $dockingslot" >
          <debug_text text="'hm, now apparently the dock location cannot be found, HELP!'" chance="$debugchance" />
          <return value="false"/>
        </do_if>
        <debug_text text="'Found new dock slot found: ' + $dockingslot.component" chance="$debugchance" />
      </do_if>

      <!-- After all initial checks, if immediate set: dock immediately -->
      <do_if value="$immediate">
        <resume label="dock" />
      </do_if>

      <label name="movetodockingbay" />

      <leave_formation object="this.ship" />

      <get_docking_approach_pos position="$approachpos" rotation="$approachrot" dock="$dockingslot" ship="this.ship" />
      <do_if value="this.ship.distanceto.{$approachpos} gt this.ship.size" >
        <debug_text text="'move to approach pos'" chance="$debugchance" />
        <move_to object="this.ship" destination="$dockingslot.component" abortpath="true" finishonapproach="true" flightbehaviour="flightbehaviour.generic" forcesteering="true" usehighways="true" >
          <position value="$approachpos" />
          <rotation value="$approachrot" />
          <interrupt_after_time time="100s" />
        </move_to>
      </do_if>

      <do_if value="not $dockingslot" >
        <debug_text text="'hm, now apparently the dock location cannot be found, HELP!'" chance="$debugchance" />
        <return value="false"/>
      </do_if>

      <label name="movetodockpos" />

      <disable_collisions_between object="this.ship" target="$destination" />
      <debug_text text="'move_docking'" chance="$debugchance" />

      <move_docking object="this.ship" dock="$dockingslot" >
        <interrupt_after_time time="100s" />
      </move_docking>

      <!-- ok, everything checks out, now start the docking procedure and request approach path -->
      <label name="dock" />

      <do_if value="not $dockingslot" >
        <debug_text text="'hm, now apparently the dock location cannot be found, HELP!'" chance="$debugchance" />
        <return value="false"/>
      </do_if>

      <!-- ok, got a clear approach path -->
      <debug_text text="'request docking, open doors'" chance="$debugchance" />
      <request_docking ship="this.ship" dock="$dockingslot" result="$success" />
      <do_while value="$success" exact="0">
        <wait min="10ms" max="400ms" />
        <debug_text text="'request dock NO queued'" chance="$debugchance" />
        <request_docking ship="this.ship" dock="$dockingslot" result="$success" />
      </do_while>
      <!-- the doors are now opening automatically -->

      <debug_text text="'dock!'" chance="$debugchance" />
      <dock ship="this.ship" />

      <close_dockingbay_doors dock="$dockingslot" />

      <do_if value="this.ship.dockslot == null">
        <debug_text text="'move.dockat returns true but we are not docked!'" chance="$debugchance" />
      </do_if>

      <return value="true"/>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <label name="start" />
      <label name="movetodockingbay" />
      <label name="movetodockpos" />
      <label name="dock" />

      <!-- Compatibility blocks -->
      <move_to object="null" destination="null" chance="0" />
      <move_docking object="null" chance="0" />
      <wait chance="0" />

      <debug_text text="'OOZ self destruction'" chance="$debugchance" />
      <destroy_object object="this.ship" />
    </actions>
  </attention>
  <on_abort>
    <stop_moving object="this.ship"/>
    <do_if value="this.ship.docklink">
      <!--Drone may have been interrupted from docking and so has a docking connection but is not docked-->
      <debug_text text="'docking at %1(%2) was aborted for some reason, disconnecting docking connection!'.[this.ship.docklink.container.knownname, this.ship.docklink.container]" chance="$debugchance" />
      <undock ship="this.ship" />
    </do_if>
    <clear_collision_filter object="this.ship" />
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>

<!--

this script should be able to perform all the default checks and make sure a ship docks at the specified destination

-->

<aiscript name="move.dockat.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="11">
  <params>
    <!--Either destination or dockingslot must be valid-->
    <param name="destination" default="null" />
    <param name="dockingslot" default="null" />
    <param name="precisiondocking" default="true"/>

    <!-- debugging -->
    <param name="debugchance" default="0" comment="informational debug output"/>
  </params>
  <attention min="unknown">
    <actions>

      <set_value name="$debugchance2" exact="$debugchance + 0" comment="error debug output"/>

      <!-- Label to allow us to repeat indefinitely -->
      <label name="start" />

      <do_if value="not $dockingslot and not $destination.exists">
        <!--No dock or destination container provided-->
        <debug_text text="'was not provided with valid dockingslot or destination for for \'%1\' (%2)!'.[this.ship.macro.id, this.ship]" chance="$debugchance2" />
        <return value="false"/>
      </do_if>

      <!-- check if there is a suitable dock at the destination at all -->
      <do_if value="$dockingslot">
        <do_if value="$destination.exists">
          <do_if value="$dockingslot.component.container != $destination">
            <assert value="false" text="'The dockslots container ' + $dockingslot.component.container.knownname + ' is different to $destination: ' + $destination.knownname" break="1"/>
            <set_value name="$destination" exact="$dockingslot.component.container"/>
          </do_if>
        </do_if>
        <do_else>
          <set_value name="$destination" exact="$dockingslot.component.container"/>
        </do_else>
      </do_if>
      <do_else>
        <find_dock_location container="$destination" name="$dockingslot" size="this.ship.docksize"/>
      </do_else>

      <do_if value="$dockingslot == null">
        <debug_text text="'could not find valid dockingslot for \'%1\' at destination \'%2\'(%3) - %4!'.[this.ship.macro.id, $destination.macro.id, $destination, this.cluster.knownname]" chance="$debugchance2" />
        <return value="false"/>
      </do_if>

      <check_object result="$result" object="$destination">
        <match_relation object="this.ship" comparison="not" relation="enemy"/>
      </check_object>
      <do_if value="not $result">
        <debug_text text="'The destination will not allow ship to dock due to relations'" chance="$debugchance2" />
        <return value="false"/>
      </do_if>
      <remove_value name="$result"/>

      <!-- check if we are currently docked / parked -->
      <do_if value="this.ship.dockslot != null or this.ship.docklink or this.ship.parkedat">
        <do_if value="this.ship.container" exact="$destination">
          <debug_text text="'we are already docked at our destination!'" chance="$debugchance" />
          <return value="true"/>
        </do_if>

        <run_script name="'move.undock.vanilla40'" />

      </do_if>

      <label name="movetozone" />

      <!-- After the checks, set command dock -->
      <set_command command="command.dockat" param="$destination" />

      <!-- leave formation (if there is any) as that would block our movement -->
      <leave_formation object="this.ship" />

      <!-- if necessary order the ship to move to the correct zone -->
      <debug_text text="'check if already in correct zone'" chance="$debugchance" />
      <do_if value="this.ship.zone != $destination.zone">
        <debug_text text="'move to correct zone'" chance="$debugchance" />
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$destination"/>
        </run_script>
      </do_if>

      <label name="movetodestination" />

      <!-- move closer to our destination -->
      <do_if value="false">
        <!-- TEMP deactivated as a random point is oftentimes unsuitable and delays the whole deal -->
        <debug_text text="'move within 3km of destination station'" chance="$debugchance" />
        <move_to object="this.ship" destination="$destination" abortpath="true" finishonapproach="true" flightbehaviour="flightbehaviour.default">
          <position min="1km" max="3km" />
          <!-- TODO: make this dependent on ship and destination size -->
        </move_to>
      </do_if>

      <do_if value="not $dockingslot.component.isoperational">
        <debug_text text="'dockingslot was lost. look for new one of size ' + this.ship.docksize + ' on ' + $destination" chance="$debugchance" />
        <find_dock_location name="$dockingslot" container="$destination" size="this.ship.docksize" />
        <do_if value="not $dockingslot" >
          <debug_text text="'hm, now apparently the dock location cannot be found, HELP!'" chance="$debugchance2" />
          <return value="false"/>
        </do_if>
        <debug_text text="'Found new dock slot found: ' + $dockingslot.component" chance="$debugchance" />
      </do_if>

      <label name="movetodockingbay" />

      <get_docking_approach_pos position="$approachpos" rotation="$approachrot" dock="$dockingslot" ship="this.ship" />
      <do_if value="this.ship.distanceto.{$approachpos} gt this.ship.size">
        <debug_text text="'move to approachpos'" chance="$debugchance" />
        <move_to object="this.ship" destination="$dockingslot.component" finishonapproach="true" flightbehaviour="flightbehaviour.default">
          <position value="$approachpos" />
          <rotation value="$approachrot" />
        </move_to>
      </do_if>

      <do_if value="not $dockingslot.component.isoperational">
        <debug_text text="'dockingslot has become invalid by the time we are ready to request clearance'" chance="$debugchance" />
        <return value="false" />
      </do_if>

      <!-- waiting to dock -->
      <set_command_action commandaction="commandaction.waitingtodock" param="player.primaryship" />

      <!-- ok, everything checks out, now start the docking procedure and request approach path -->
      <debug_text text="'request docking (queued)'" chance="$debugchance" />
      <request_docking ship="this.ship" dock="$dockingslot" queued="1" result="$success" />
      <do_while value="$success" exact="0">
        <wait min="2s" max="10s" />
        <do_if value="not $dockingslot.component.isoperational">
          <debug_text text="'dockingslot has become invalid while waiting for docking clearance'" chance="$debugchance" />
          <return value="false" />
        </do_if>
        <!-- TODO: this is where we would either move to waiting position or go into a holding pattern -->
        <request_docking ship="this.ship" dock="$dockingslot" queued="1" result="$success" />
        <do_if value="not $success">
          <do_if value="not $queuestarttime?">
            <set_value name="$queuestarttime" exact="player.age" />
            <set_value name="$maxtime" exact="30min" />
            <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
              <set_value name="$maxtime" exact="3h" />
            </do_if>
          </do_if>
          <do_if value="(player.age - $queuestarttime) gt $maxtime">
            <debug_text text="'been waiting for more than %1s to get docking clearance, aborting'.[$maxtime]" chance="$debugchance" />
            <return value="false" />
          </do_if>
        </do_if>
      </do_while>

      <!-- ok, got a clear approach path -->
      <debug_text text="'request docking, open doors'" chance="$debugchance" />
      <request_docking ship="this.ship" dock="$dockingslot" result="$success" />
      <do_while value="$success" exact="0">
        <wait min="2s" max="10s" />
        <do_if value="not $dockingslot.component.isoperational">
          <do_if value="this.ship.docklink">
            <!-- we should have a docklink because the queued request above must have succeeded for us to be in here, force-disconnect that to avoid stale connections -->
            <undock ship="this.ship" />
          </do_if>
          <debug_text text="'dockingslot has become invalid during docking'" chance="$debugchance" />
          <return value="false" />
        </do_if>
        <request_docking ship="this.ship" dock="$dockingslot" result="$success" />
        <do_if value="not $success">
          <do_if value="not $queuestarttime?">
            <set_value name="$queuestarttime" exact="player.age" />
            <set_value name="$maxtime" exact="30min" />
            <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
              <set_value name="$maxtime" exact="3h" />
            </do_if>
          </do_if>
          <do_if value="(player.age - $queuestarttime) gt $maxtime">
            <do_if value="this.ship.docklink">
              <debug_text text="'been waiting for more than %1s to get final docking clearance, aborting and disconnecting'.[$maxtime]" chance="$debugchance" />
              <!-- we should have a docklink because the queued request above must have succeeded for us to be in here, force-disconnect that to avoid stale connections -->
              <undock ship="this.ship" />
            </do_if>
            <return value="false" />
          </do_if>
        </do_if>
      </do_while>
      <!-- the doors are now opening automatically -->

      <label name="movetodockpos" />

      <disable_collisions_between object="this.ship" target="$destination" />
      <debug_text text="'move_docking'" chance="$debugchance" />
      <do_if value="$precisiondocking">
        <move_docking object="this.ship" dock="$dockingslot" abortpath="false" />
      </do_if>
      <do_else>
        <move_to object="this.ship" destination="$dockingslot.component" finishonapproach="1" flightbehaviour="flightbehaviour.dock"/>
      </do_else>

      <do_if value="not $dockingslot.component.isoperational">
        <do_if value="this.ship.docklink">
          <!-- we should have a docklink because the queued request above must have succeeded for us to be in here, force-disconnect that to avoid stale connections -->
          <undock ship="this.ship" />
        </do_if>
        <debug_text text="'dockingslot has become invalid during final approach to the dock'" chance="$debugchance" />
        <clear_collision_filter object="this.ship" />
        <return value="false" />
      </do_if>

      <do_if value="not $dockingslot.component.external">
        <close_dockingbay_doors dock="$dockingslot" />
        <!-- wait for the doors to close! -->
        <wait exact="5s" />
      </do_if>
      <debug_text text="'dock!'" chance="$debugchance" />
      <dock ship="this.ship" />

      <do_if value="this.ship.dockslot == null">
        <debug_text text="'move.dockat returns true but we are not docked!'" chance="$debugchance2" />
      </do_if>

      <return value="true"/>

    </actions>
  </attention>
  <on_abort>
    <do_if value="this.ship.docklink">
      <!--Ship may have been interrupted from docking and so has a docking connection but is not docked-->
      <debug_text text="'docking at %1(%2) was aborted for some reason, disconnecting docking connection!'.[this.ship.docklink.container.knownname, this.ship.docklink.container]" chance="$debugchance" />
      <undock ship="this.ship" />
    </do_if>
    <clear_collision_filter object="this.ship" />
  </on_abort>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.escapepod.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <attention min="visible">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />

      <wait min="1s" max="3s" />

      <label name="search" />

      <find_station name="$stations" functional="true" space="this.zone" multiple="true">
        <match_relation object="this" relation="neutral" comparison="ge" />
      </find_station>

      <do_if value="not $stations.count">
        <wait min="100ms" max="250ms" />
        <find_station name="$stations" functional="true" space="this.sector" multiple="true">
          <match_relation object="this" relation="neutral" comparison="ge" />
        </find_station>
      </do_if>

      <do_if value="not $stations.count">
        <resume label="waitforrescue" />
      </do_if>

      <debug_text text="'found '+ $stations.count + ' potential targets, finding closest one.'" chance="$debugoutputchance" />
      <create_list name="$stationdists" exact="$stations.count" />
      <do_all exact="$stations.count" counter="$i">
        <set_value name="$stationdists.{$i}" exact="this.ship.distanceto.{$stations.{$i}}" />
      </do_all>
      <set_value name="$station" exact="$stations.{$stationdists.indexof.{$stationdists.min}}" />


      <label name="dock" />
      <run_script name="'move.dockat.vanilla40'" result="$dockresult">
        <param name="destination" value="$station" />
      </run_script>

      <do_if value="not $dockresult">
        <!-- ship_xs cannot dock at regular docking bays, for now just have the pod fly to a station -->
        <debug_text text="'going to fly to ' + $station.knownname" chance="$debugoutputchance" />
        <run_script name="'move.generic.vanilla40'" >
          <param name="destination" value="$station" />
        </run_script>
      </do_if>

      <resume label="selfdestruct" />


      <label name="waitforrescue" />
      <!-- TODO: send out distress call, ships that come to pick up etc., activate beacon lights or something -->
      <!-- <debug_text text="'no station found that would let me dock, hoping someone will come to rescue me...'" chance="$debugoutputchance" /> -->
      <debug_text text="'waiting for someone to come to rescue me...'" chance="$debugoutputchance" />
      <do_while value="this.ship.attention ge attention.visible">
        <!-- wait until this is no longer visible, then self-destruct -->
        <wait>
          <interrupt>
            <conditions>
              <event_object_changed_attention object="this.ship" />
            </conditions>
          </interrupt>
        </wait>
      </do_while>

      <label name="selfdestruct" />
      <debug_text text="'good bye, cruel world!'" chance="$debugoutputchance" />
      <destroy_object explosion="false" object="this.ship" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <wait min="1s" max="3s" />

      <label name="search" />
      <label name="dock" />
      <label name="waitforrescue" />
      <label name="selfdestruct" />
      <debug_text text="'good bye, cruel world! (oos)'" chance="$debugoutputchance" />
      <destroy_object explosion="false" object="this.ship" />

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.escort.capital.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="6">
  <!--

  Escort Capital ship
  
  Movement of a ship escorting a big ship (m, l, xl).
  This will stay in a group with a cylinder formation while
  target to escort is operational.
    
  Movement:
	1 - Stay in formation
	2 - Break formation to attack enemy if:
		2.1 - Leader send a signal
		2.2 - Leader under attack
		2.3 - Escort group under attack

	Will return to this formation if:
	- enemy destroyed
	- far away from escortee (if exists)

  -->
  <params>
    <param name="target" comment="the big ship to escort" />
    <param name="timeout" default="-1" />
    <param name="formationparam" default="null" comment="Separation between circles that surround the capship target. Default: max of 400m and ship length" />
    <param name="formationparam2" default="null" comment="Maximum number of ships per circle. Default 6" />
    <!-- <param name="aggressive" default="1.0" comment="If set to true, the escort system will send all ships. Aggressive mode [0.0, 2.0]. Normal level is 1.0" /> -->
    <param name="defendtarget" default="true" comment="Always defend the target, even if he is attacking the escorting ships" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="ScannedHandler.vanilla40" />
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler>
      <conditions>
        <event_object_changed_zone object="$target" check="false" />
        <check_value value="event.param.istemporaryzone" negate="true" />
      </conditions>
      <actions>
        <abort_called_scripts resume="start"/>
      </actions>
    </handler>
  </interrupts>
  <init>
    <!-- Command already set on move.escort <set_command command="command.escort" param="$target" /> -->
    <set_command_action commandaction="commandaction.flying" />
    <!-- distance to check and abort attacks -->
    <set_value name="$pursuedistance" exact="5km + $target.size" />
  </init>
  <patch sinceversion="5">
    <set_value name="$pursuedistance" exact="5km + @$target.size" />
  </patch>
  <attention min="visible">
    <actions>

      <label name="start" />

      <!-- if is big ship (cannot fly in highways) -->
      <set_value name="$capship" exact="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" />
      <!-- Set cylindrical values -->
      <set_value name="$nships" exact="-1" />
      <set_value name="$separation" exact="$formationparam" />
      <set_value name="$nmax" exact="$formationparam2" />
      <do_if value="not $separation">
        <set_value name="$separation" exact="[400m, this.ship.length].max"/>
      </do_if>
      <set_value name="$nmax" exact="$formationparam2" />
      <do_if value="not $nmax">
        <set_value name="$nmax" exact="6" />
      </do_if>

      <!-- Start -->
      <wait min="200ms" />

      <stop_moving object="this.ship" immediate="false" />
      <cease_fire object="this.ship" />

      <do_if value="$target.isoperational and @$target.pilot" negate="true">
        <resume label="finish" />
      </do_if>

      <do_if value="$target.isclass.ship_m or $target.isclass.ship_l or $target.isclass.ship_xl">
        <debug_text text="' escorting Big ship'" chance="$debugoutputchance" />
      </do_if>
      <do_else>
        <debug_text text="'No valid escortee specified, no l or xl ship size'" chance="$debugoutputchance" />
        <resume label="finish" />
      </do_else>

      <set_value name="$enemy" exact="null" />
      <set_value name="$starttime" exact="player.age" />

      <!-- If far away/different zone -->
      <do_if value="this.ship.distanceto.{$target} gt 20km">
        <debug_text text="'leader in different zone'" chance="$debugoutputchance" />
        <run_script name="'move.generic.vanilla40'" >
          <param name="destination" value="$target" />
          <param name="endintargetzone" value="true" />
        </run_script>
      </do_if>

      <!-- Create / add to escort group -->
      <do_if value="$target.isoperational">
        <do_if value="not @$target.pilot.$escortgroup">
          <debug_text text="'creating escort list'" chance="$debugoutputchance" />
          <create_group groupname="$target.pilot.$escortgroup" />
        </do_if>
        <add_to_group groupname="$target.pilot.$escortgroup" object="this.ship" />
      </do_if>

      <!-- Flag attack -->
      <set_value name="this.$goattack" exact="false" />

      <!-- Loop -->
      <do_while value="$target.isoperational and @$target.pilot">
        <!-- Calculate Positions -->
        <do_if value="$nships != $target.pilot.$escortgroup.count and $target.pilot.$escortgroup.count gt 0">
          <set_value name="$nships" exact="$target.pilot.$escortgroup.count" />

          <do_if value="$nships ge $nmax" >
            <set_value name="$alpha" exact="2.0*pi / $nmax" />
          </do_if>
          <do_else>
            <set_value name="$alpha" exact="2.0*pi / $nships" />
          </do_else>

          <set_value name="$myindex" exact="$target.pilot.$escortgroup.indexof.{this.ship}" />
          <set_value name="$x" exact="($target.width + this.ship.width + 100 + @$capship*500)  * cos($alpha * $myindex)" />
          <set_value name="$y" exact="($target.height + this.ship.height + 100 + @$capship*500) * sin($alpha * $myindex)" />
          <set_value name="$z" exact="($myindex/$nmax) * $separation - ($nships/$nmax * $separation*0.5)" />
        </do_if>

        <!-- Escort movement -->
        <move_to object="this.ship" destination="$target" flightbehaviour="flightbehaviour.follow" forcesteering="not @$capship" usehighways="not @$capship" forcerotation="true" >
          <position x="$x" y="$y" z="$z"/>
          <rotation yaw="0deg" pitch="0deg" />
          <interrupt_after_time time="0s" comment="interrupt the blocking action, but the move continues" />
        </move_to>

        <!-- Get the attack events -->
        <wait min="10s" max="20s" sinceversion="3">
          <interrupt>
            <conditions>
              <check_any>
                <check_all>
                  <event_object_signalled object="this.ship" param="'attack'" />
                  <check_value value="$target.isoperational and $target.pilot and event.param2.isoperational and $target.mayattack.{event.param2}" />
                </check_all>
                <check_all>
                  <check_any>
                    <event_object_attacked group="$target.pilot.$escortgroup" check="false" />
                    <event_object_attacked object="$target" />
                    <event_object_enemy_found object="this.ship"/>
                  </check_any>
                  <check_value value="$target.isoperational and $target.pilot" />
                  <check_value value="$target != event.param or not $defendtarget" comment="special check for attack (or not) the target" />
                  <check_value value="this.mayattack.{event.param} or $target.mayattack.{event.param}" />
                  <check_value value="($target.distanceto.{event.param} lt $pursuedistance) and (this.ship.distanceto.{event.param} lt $pursuedistance)" />
                </check_all>
                <event_object_changed_zone object="$target" />
                <event_object_destroyed object="$target" />
              </check_any>
            </conditions>
            <actions>
              <!-- Reset enemy -->
              <set_value name="$enemy" exact="null" />

              <!-- Commander signal this -->
              <do_if value="event.name == 'event_object_signalled'">
                <set_value name="$enemy" exact="event.param2" />
                <!-- Shoot while in formation-->
                <shoot_at object="this.ship" target="$enemy" slot="tag.primary_slot" tolerance="10.0deg" locktarget="true" weapontype="combat" />
                <!-- Escortee enemy relation-->
                <do_if value="not this.mayattack.{$enemy}">
                  <add_relation_boost object="this" otherobject="$enemy" value="-0.1" decay="1" delay="10min" silent="true" />
                </do_if>
              </do_if>
              <do_elseif value="(event.name == 'event_object_changed_zone') or (event.name == 'event_object_destroyed')">
                <resume label="start" />
              </do_elseif>
              <do_else>
                <!-- operational checks-->
                <do_if value="event.param.isoperational and @$target.pilot.$escortgroup">
                  <!-- Max range to attack an enemy: 5km -->
                  <!-- enemy-->
                  <set_value name="$enemy" exact="event.param" />
                  <!-- Send 25% of escort ships -->
                  <set_value name="$nsupportships" exact="$target.pilot.$escortgroup.count * 0.35" />

                  <do_if value="event.name" exact="'event_object_attacked'">
                    <!--  Me under attack, so attack him -->
                    <do_if value="event.param3" exact="this.ship">
                      <set_value name="this.$goattack" exact="true" />
                      <remove_from_group group="$target.pilot.$escortgroup" object="this.ship" />
                    </do_if>
                    <!-- Target under attack. Send 40% of ships -->
                    <do_if value="event.param3" exact="$target">
                      <set_value name="$nsupportships" exact="$target.pilot.$escortgroup.count * 0.45" />
                    </do_if>
                  </do_if>
                  <!-- Call support ships -->
                  <do_if value="$target.pilot.$escortgroup.count" min="1">
                    <do_all exact="[1, $nsupportships].max" counter="$i">
                      <set_value name="$target.pilot.$escortgroup.{$i}.pilot.$goattack" exact="true" />
                    </do_all>
                  </do_if>
                  <remove_value name="$nsupportships" />
                </do_if>
              </do_else>

            </actions>
          </interrupt>
        </wait>

        <do_if value="$timeout gt 0">
          <do_if value="player.age gt $starttime + $timeout">
            <resume label="finish" />
          </do_if>
        </do_if>

        <!-- Go into attack mode-->
        <do_if value="this.$goattack">
          <resume label="fight" />
        </do_if>

      </do_while>

      <label name="fight" />

      <do_if value="this.$goattack">
        <do_if value="$target.isoperational and @$target.pilot and $enemy.isoperational">
          <do_if value="not this.mayattack.{$enemy}">
            <add_relation_boost object="this" otherobject="$enemy" value="this.owner.relation.kill.max" decay="1" delay="10min" silent="true" />
          </do_if>

          <remove_from_group group="$target.pilot.$escortgroup" object="this.ship" />
          <debug_text text="' I will attack you. Index: ' +$myindex " chance="$debugoutputchance" />

          <run_script name="'fight.attack.object.vanilla40'" >
            <param name="target" value="$enemy" />
            <param name="escort" value="$target" />
            <param name="pursuedistance" value="$pursuedistance" comment="make sure to be the same distance as max attack range" />
            <param name="allowothertargets" value="false" />
            <param name="debugoutputchance" value="$debugoutputchance" />
          </run_script>

          <remove_value name="this.$goattack" />
        </do_if>
      </do_if>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <resume label="finish" />
      </do_if>

      <resume label="start" />

      <label name="finish" />

      <!-- not operational case -->
      <do_if value="not $target.isoperational">
        <do_if value="this.ship.commander.isoperational and (@this.ship.commander.isclass.ship_m or @this.ship.commander.isclass.ship_l or @this.ship.commander.isclass.ship_xl)" >
          <set_value name="$target" exact="this.ship.commander" />
          <resume label="start" />
        </do_if>
        <do_elseif value="this.ship.isplayerowned">
          <run_script name="'move.patrol.vanilla40'" sinceversion="4" >
            <param name="range" value="'zone'" />
          </run_script>
        </do_elseif>
      </do_if>
      <!-- operational, but no pilot -->
      <do_elseif value="not $target.pilot and this.ship.isplayerowned">
        <debug_text text="'%1 (%2) is operational, but there is no pilot, so wait for new pilot'.[$target.knownname, $target]" chance="$debugoutputchance" />
        <wait min="8s" max="15s" sinceversion="6"/>
        <resume label="start" />
      </do_elseif>

      <debug_text text="'leader dead or timeout'" chance="$debugoutputchance" />
      <run_script name="'move.die.vanilla40'">
        <param name="byhostile" value="true" />
      </run_script>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <wait min="1s" max="3s" />

      <label name="fight" />
      <label name="start" />

      <wait min="1s" max="5s" />

      <do_if value="not $target.isoperational">
        <debug_text text="'No valid escortee specified, and no commander found - exiting script'" chance="$debugoutputchance" />
        <resume label="finish" />
      </do_if>

      <!-- Fly there -->
      <do_if value="this.zone != $target.zone" >
        <run_script name="'move.generic.vanilla40'" sinceversion="2" >
          <param name="destination" value="$target" />
          <param name="endintargetzone" value="true" />
        </run_script>
      </do_if>

      <do_elseif value="this.ship.distanceto.{$target}" min="this.ship.size + $target.size + 1km">
        <move_to object="this.ship" destination="$target" sinceversion="1" >
          <position object="$target" min="this.ship.size" max="this.ship.size*2" />
        </move_to>
      </do_elseif>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <resume label="finish" />
      </do_if>

      <resume label="start" />

      <label name="finish" />

      <!-- Target destroyed, and no commander -->
      <do_if value="not $target.isoperational">
        <do_if value="this.ship.commander.isoperational and (@this.ship.commander.isclass.ship_m or @this.ship.commander.isclass.ship_l or @this.ship.commander.isclass.ship_xl)" >
          <set_value name="$target" exact="this.ship.commander" />
          <resume label="start" />
        </do_if>
        <do_elseif value="this.ship.isplayerowned">
          <run_script name="'move.patrol.vanilla40'" sinceversion="4" >
            <param name="range" value="'zone'" />
          </run_script>
        </do_elseif>
      </do_if>
      <!-- operational, but no pilot -->
      <do_elseif value="not $target.pilot and this.ship.isplayerowned">
        <debug_text text="'%1 (%2) is operational, but there is no pilot, so wait for new pilot'.[$target.knownname, $target]" chance="$debugoutputchance" />
        <wait min="8s" max="15s" sinceversion="6"/>
        <resume label="start" />
      </do_elseif>


      <!-- Auto destroy -->
      <run_script name="'move.die.vanilla40'" sinceversion="1" >
        <param name="byhostile" value="true" />
      </run_script>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.escort.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="9">
  <!--

  Escort small ship
  
  Movement of a ship escorting a small ship (xs, s).
  This will stay in a group with a formation (by parameter) while
  target to escort is operational.
    
  Movement:
	1 - Stay in formation
	2 - Break formation to attack enemy if:
		2.1 - Leader send a signal
		2.2 - Leader under attack
		2.3 - Escort group under attack

	Will return to this formation if:
	- enemy destroyed
	- far away from escortee (if exists)

  -->
  <params>
    <param name="target" comment="the escortee (mandatory). Either object or string 'commander'" />
    <param name="timeout" default="-1" />
    <param name="formation" default="formationshape.pointguard" comment="the formation to escort" />
    <param name="formationparam" default="null" comment="First parameter for formation. Default: max 300m and ship length" />
    <param name="formationparam2" default="null" comment="Second parameter for formation" />
    <param name="rollformation" default="false" comment="Whether the entire formation shape should roll with the leader (optional, defaults to false)" />
    <param name="rollmembers" default="true" comment="Whether individual members should mimic the roll orientation of the leader (optional, defaults to true)"/>
    <param name="defendtarget" default="true" comment="Always defend the target, even if he is attacking the escorting ships" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="ScannedHandler.vanilla40" />
    <handler ref="TargetInvalidHandler.vanilla40" />
  </interrupts>
  <init>
    <!-- From jobs -->
    <do_if value="$target == 'commander'">
      <set_value name="$target" exact="this.ship.commander"/>
    </do_if>
    <!-- Now is safe to set the command -->
    <set_command command="command.escort" param="$target" />
    <set_command_action commandaction="commandaction.flying" />
    <!-- distance to check and abort attacks -->
    <set_value name="$pursuedistance" exact="4km" />
  </init>
  <patch sinceversion="6">
    <do_if value="not $rollformation?">
      <set_value name="$rollformation" exact="false" />
    </do_if>
    <do_if value="not $rollmembers?">
      <set_value name="$rollmembers" exact="true" />
    </do_if>
  </patch>
  <patch sinceversion="8">
    <set_value name="$pursuedistance" exact="4km" />
  </patch>
  <attention min="visible">
    <actions>

      <do_if value="$target == this.ship">
        <debug_text text="'Ship is trying to escort itself.'" filter="error"/>
      </do_if>

      <run_script name="'move.undock.vanilla40'" sinceversion="4" />

      <label name="start" />

      <wait min="200ms" max="400ms" />
      <stop_moving object="this.ship" immediate="false" />
      <cease_fire object="this.ship" />
      <leave_formation object="this.ship" />

      <set_value name="$enemy" exact="null" />
      <do_if value="$target.isoperational and @$target.pilot" negate="true">
        <resume label="finish" />
      </do_if>
      <set_value name="$starttime" exact="player.age" />

      <!-- If far away/different zone -->
      <do_if value="this.zone != $target.zone">
        <debug_text text="'leader in different zone'" chance="$debugoutputchance" />
        <do_if value="this.ship.isclass.[class.ship_l, class.ship_xl]">
          <!-- big ships use the routine -->
          <run_script name="'move.generic.vanilla40'" >
            <param name="destination" value="$target" />
            <param name="endintargetzone" value="not $target.zone.isclass.highway" />
          </run_script>
        </do_if>
        <do_else>
          <!-- small ships with a simple move_to -->
          <move_to object="this.ship" destination="$target" usehighways="true" sinceversion="7" />
        </do_else>
        <!-- Retry just in case is not there yet -->
        <resume label="start" />
      </do_if>

      <do_if value="$target.isoperational">
        <!-- If CapShip -->
        <do_if value="$target.isclass.ship_l or $target.isclass.ship_xl">
          <debug_text text="'escort big ship'" chance="$debugoutputchance" />
          <run_script name="'move.escort.capital.vanilla40'">
            <param name="target" value="$target" />
            <param name="timeout" value="$timeout" />
            <param name="formationparam" value="$formationparam"/>
            <param name="formationparam2" value="$formationparam2"/>
            <param name="debugoutputchance" value="$debugoutputchance" />
          </run_script>
          <debug_text text="' end of escorting capship'" chance="$debugoutputchance" />
          <resume label="finish" />
        </do_if>
      </do_if>

      <debug_text text="'join formation. Visible. Ship: ' + this.ship + ' target: ' + $target" chance="$debugoutputchance" />

      <!-- Create / add to escort group -->
      <wait max="500ms" sinceversion="2" comment="delay to check leader, because there is no mutex" />
      <do_if value="$target.isoperational and @$target.pilot">
        <do_if value="not @$target.pilot.$escortgroup">
          <debug_text text="'creating escort list'" chance="$debugoutputchance" />
          <create_group groupname="$target.pilot.$escortgroup" />
        </do_if>
        <!-- Default separation -->
        <do_if value="not $formationparam">
          <set_value name="$formationparam" exact="[300m, this.ship.length].max" />
        </do_if>
        <create_formation object="$target" formation="$formation" param="$formationparam" param2="$formationparam2" rollformation="$rollformation" rollmembers="$rollmembers" />
        <add_to_group groupname="$target.pilot.$escortgroup" object="this.ship" />
        <join_formation leader="$target" object="this.ship" />
      </do_if>

      <!-- Attack flag -->
      <set_value name="this.$goattack" exact="false" />

      <!-- start Loop -->
      <do_while value="$target.isoperational and @$target.pilot">

        <wait>
          <interrupt>
            <conditions>
              <check_any>
                <check_all>
                  <event_object_signalled object="this.ship" param="'attack'" />
                  <check_value value="$target.isoperational and $target.pilot and event.param2.isoperational and $target.mayattack.{event.param2}" />
                </check_all>
                <check_all>
                  <check_any>
                    <event_object_attacked group="$target.pilot.$escortgroup" check="false" />
                    <event_object_attacked object="$target" />
                    <event_object_enemy_found object="this.ship"/>
                  </check_any>
                  <check_value value="$target.isoperational and $target.pilot" />
                  <check_value value="$target != event.param or not $defendtarget" comment="special check for attack (or not) the target" />
                  <check_value value="this.mayattack.{event.param} or $target.mayattack.{event.param}" />
                  <check_value value="($target.distanceto.{event.param} lt $pursuedistance) and (this.ship.distanceto.{event.param} lt $pursuedistance)" />
                </check_all>
                <event_object_changed_zone object="$target" />
                <event_object_destroyed object="$target" />
              </check_any>
            </conditions>
            <actions>
              <!-- Reset enemy -->
              <set_value name="$enemy" exact="null" />

              <!-- Commander signal this -->
              <do_if value="event.name == 'event_object_signalled'">
                <!-- enemy -->
                <set_value name="$enemy" exact="event.param2" />
                <!-- Shoot while in formation-->
                <shoot_at object="this.ship" target="$enemy" slot="tag.primary_slot" tolerance="12deg" locktarget="true" weapontype="combat" />
                <shoot_at object="this.ship" target="$enemy" slot="tag.secondary_slot" tolerance="5deg" locktarget="true" weapontype="combat" />
                <!-- Escortee enemy relation-->
                <do_if value="not this.mayattack.{$enemy}">
                  <add_relation_boost object="this" otherobject="$enemy" value="this.owner.relation.kill.max" decay="1" delay="10min" silent="true" />
                </do_if>
              </do_if>
              <do_elseif value="(event.name == 'event_object_changed_zone') or (event.name == 'event_object_destroyed')">
                <resume label="start" />
              </do_elseif>
              <do_else>
                <!-- operational checks-->
                <do_if value="event.param.isoperational and @$target.pilot.$escortgroup">
                  <!-- enemy -->
                  <set_value name="$enemy" exact="event.param" />
                  <!-- Default Send 20% of escort ships -->
                  <set_value name="$nsupportships" exact="$target.pilot.$escortgroup.count * 0.2" />

                  <do_if value="event.name" exact="'event_object_attacked'">
                    <!--  Me under attack, so attack him -->
                    <do_if value="event.param3" exact="this.ship">
                      <set_value name="this.ship.pilot.$goattack" exact="true" />
                      <remove_from_group group="$target.pilot.$escortgroup" object="this.ship" />
                      <set_value name="$nsupportships" exact="$target.pilot.$escortgroup.count * 0.3" />
                    </do_if>
                    <!-- Target under attack. Send 60% of ships -->
                    <do_if value="event.param3" exact="$target">
                      <set_value name="$nsupportships" exact="$target.pilot.$escortgroup.count * 0.6" />
                    </do_if>
                  </do_if>
                  <!-- Call support ships -->
                  <do_if value="$target.pilot.$escortgroup.count" min="1">
                    <do_all exact="[1, $nsupportships].max" counter="$i">
                      <set_value name="$target.pilot.$escortgroup.{$i}.pilot.$goattack" exact="true" />
                    </do_all>
                  </do_if>
                </do_if>
                <remove_value name="$nsupportships" />
              </do_else>
            </actions>
          </interrupt>
        </wait>

        <do_if value="$timeout gt 0">
          <do_if value="player.age gt $starttime + $timeout">
            <resume label="finish" />
          </do_if>
        </do_if>

        <!-- Go into attack mode-->
        <do_if value="this.$goattack">

          <do_if value="$target.isoperational and @$target.pilot and $enemy.isoperational">
            <do_if value="not this.mayattack.{$enemy}">
              <add_relation_boost object="this" otherobject="$enemy" value="this.owner.relation.kill.max" decay="1" delay="10min" silent="true" />
            </do_if>

            <leave_formation object="this.ship" />
            <remove_from_group group="$target.pilot.$escortgroup" object="this.ship" />

            <run_script name="'fight.attack.object.vanilla40'" >
              <param name="target" value="$enemy" />
              <param name="escort" value="$target" />
              <param name="pursuedistance" value="$pursuedistance" comment="make sure to be the same distance as max attack range" />
              <param name="allowothertargets" value="false" />
              <param name="debugoutputchance" value="$debugoutputchance" />
            </run_script>

            <remove_value name="this.$goattack" />

            <!-- restart -->
            <resume label="start" />

          </do_if>
        </do_if>

        <!-- check if this is a jobship at the end of its lifetime -->
        <do_if value="this.ship.jobexpired">
          <resume label="finish" />
        </do_if>

      </do_while>

      <label name="finish" />

      <debug_text text="'leader dead or timeout'" chance="$debugoutputchance" />

      <do_if value="not $target.isoperational">
        <do_if value="this.ship.commander.isoperational and @this.ship.commander.isclass.ship_s" >
          <set_value name="$target" exact="this.ship.commander" />
          <resume label="start" />
        </do_if>
        <do_elseif value="this.ship.isplayerowned">
          <run_script name="'move.patrol.vanilla40'" sinceversion="1" >
            <param name="range" value="'zone'" />
          </run_script>
        </do_elseif>
      </do_if>
      <!-- operational, but no pilot -->
      <do_elseif value="not $target.pilot and this.ship.isplayerowned">
        <debug_text text="'%1 (%2) is operational, but there is no pilot, so wait for new pilot'.[$target.knownname, $target]" chance="$debugoutputchance" />
        <wait min="8s" max="15s" sinceversion="9"/>
        <resume label="start" />
      </do_elseif>

      <!-- Auto destroy -->
      <run_script name="'move.die.vanilla40'" >
        <param name="byhostile" value="true" />
      </run_script>

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <do_if value="$target == this.ship">
        <debug_text text="'Ship is trying to escort itself.'" filter="error"/>
      </do_if>

      <run_script name="'move.undock.vanilla40'" sinceversion="4" />

      <do_if value="not $target.isoperational">
        <set_value name="$target" exact="this.ship.commander" />
      </do_if>
      <do_else>
        <!-- If CapShip -->
        <do_if value="$target.isclass.ship_l or $target.isclass.ship_xl">
          <debug_text text="'escort big ship'" chance="$debugoutputchance" />
          <run_script name="'move.escort.capital.vanilla40'" sinceversion="3">
            <param name="target" value="$target" />
            <param name="timeout" value="$timeout" />
            <param name="formationparam" value="$formationparam"/>
            <param name="formationparam2" value="$formationparam2"/>
            <param name="debugoutputchance" value="$debugoutputchance" />
          </run_script>
          <debug_text text="' end of escorting capship'" chance="$debugoutputchance" />
          <resume label="finish" />
        </do_if>
      </do_else>

      <label name="start" />

      <wait min="1s" max="3s" />

      <do_if value="not @$target.isoperational" comment="use @ to avoid errors if $target == 'commander'">
        <debug_text text="'No valid escortee specified, and no commander found - exiting script'" chance="$debugoutputchance" />
        <resume label="finish" />
      </do_if>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <resume label="finish" />
      </do_if>

      <!-- Fly there -->
      <do_if value="this.ship.distanceto.{$target}" min="this.ship.size + $target.size + 500m">
        <move_to object="this.ship" destination="$target.zone" sinceversion="3">
          <position object="$target" min="this.ship.size + $target.size"/>
        </move_to>
      </do_if>

      <resume label="start" />

      <label name="finish" />

      <!-- Target destroyed, and no commander -->
      <do_if value="not $target.isoperational">
        <do_if value="this.ship.commander.isoperational and @this.ship.commander.isclass.ship_s" >
          <set_value name="$target" exact="this.ship.commander" />
          <resume label="start" />
        </do_if>
        <do_elseif value="this.ship.isplayerowned">
          <run_script name="'move.patrol.vanilla40'" sinceversion="5" >
            <param name="range" value="'zone'" />
          </run_script>
        </do_elseif>
      </do_if>
      <!-- operational, but no pilot -->
      <do_elseif value="not $target.pilot and this.ship.isplayerowned">
        <debug_text text="'%1 (%2) is operational, but there is no pilot, so wait for new pilot'.[$target.knownname, $target]" chance="$debugoutputchance" />
        <wait min="8s" max="15s" sinceversion="9"/>
        <resume label="start" />
      </do_elseif>

      <!-- Auto destroy -->
      <run_script name="'move.die.vanilla40'" sinceversion="3" >
        <param name="byhostile" value="true" />
      </run_script>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.flee.boost.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" >
  <!--  
  
  Flee using boost. 
  Check if htere are any obstacles in front:
  - If not, fly quickly on straight line
  - if htere is something in the middle (XL, L or station) rotate to aim on the opposite direction and boost there
  
  -->
  <params>
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>
      <!-- Return false if it can't boost -->
      <do_if value="not this.ship.canboost">
        <debug_text text="'this ship cannot boost'" chance="$debugchance" />
        <return value="false" />
      </do_if>

      <!-- set them in spline if is on visile attention level -->
      <do_if value="this.attention ge attention.visible">
        <debug_text text="'only set spline on high attention'" chance="$debugchance" />
        <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.spline" />
      </do_if>

      <!-- Maximum distance to move -->
      <set_value name="$maxdistance" exact="30km" />

      <!-- Find the obstacles in front of this ship -->
      <find_gravidar_contact object="this.ship" class="[class.ship_l, class.ship_xl, class.station]" groupname="$obstacles" multiple="true" >
        <match_is_in_view_of vertical="25deg" horizontal="25deg" object="this.ship" />
        <match_distance max="$maxdistance" object="this.ship" />
      </find_gravidar_contact>

      <!--  Try to fly in the oposite direction of the average positions of the enemies -->
      <do_if value="$obstacles.count">
        <set_value name="$x" exact="0"  />
        <set_value name="$y" exact="0"/>
        <set_value name="$z" exact="0" />
        <!-- Add all positions -->
        <do_all exact="$obstacles.count" counter="$i">
          <create_position name="$enemypos" space="this.ship" object="$obstacles.{$i}" />
          <set_value name="$x" exact="$enemypos.x" operation="add" />
          <set_value name="$y" exact="$enemypos.y" operation="add" />
          <set_value name="$z" exact="$enemypos.z" operation="add" />
        </do_all>
        <!-- resultpos is the average position of all enemies -->
        <debug_text text="'x:%1, y:%2, z:%3'.[$x, $y, $z]" chance="$debugchance" />
        <create_position name="$resultpos" x="$x / ($obstacles.count * 1)" y="$y / ($obstacles.count * 1)" z="$z / ($obstacles.count * 1)" />
        <debug_text text="'resultpos %1'.[$resultpos]" chance="$debugchance" />

        <!-- Go in oposite direction of resultpos [x,y,z] -->
        <set_value name="$distfactor" exact="[$maxdistance / this.ship.distanceto.{$resultpos}, 0.1].max" />
        <debug_text text="'dist factor %1, dist %2'.[$distfactor, this.ship.distanceto.{$resultpos}]" chance="$debugchance" />
        <!-- Final position in the oposite direction -->
        <create_position name="$finalpos" x="$resultpos.x * -$distfactor"
                                          y="$resultpos.y * -$distfactor"
                                          z="$resultpos.z * -$distfactor" object="this.ship" space="this.zone"/>

        <debug_text text="'finalpos %1, distfactor %2, dist %3'.[$finalpos, $distfactor, this.ship.distanceto.{$resultpos}]" chance="$debugchance" />
        <debug_text text="'start move. this pos %1, final pos %2'.[this.ship.position, $finalpos]" chance="$debugchance" />

        <create_orientation name="$orientation" orientation="look_at" refposition="$finalpos">
          <position object="this.ship" />
        </create_orientation>
        <!-- Rotate to aim the final position -->
        <move_to object="this.ship" destination="this.zone" abortpath="true" forceposition="false" finishonapproach="false" forcerotation="true" avoid="false">
          <position object="this.ship" z="5m" />
          <rotation value="$orientation" />
        </move_to>
      </do_if>

      <!-- Move straigh forward, base on the previous rotation -->
      <move_to object="this.ship" destination="this.zone" abortpath="true" forceposition="false" finishonapproach="false" boost="true">
        <position object="this.ship" z="30km" />
        <interrupt_after_time time="30s" />
      </move_to>

      <return value="true" />

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.flee.dock.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--  
  
  Flee to dock. This script will find a nearby friendly station (in this zone) and if it has a free dock, this ship will boost there to dock
  
  Only allow for small ships (not l or xl size)
  
  -->
  <params>
    <param name="attacker" default="null" comment="the attacker we are fleeing from" />
    <param name="panic" default="false" />
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <do_if value="this.ship.isclass.[class.ship_xl, class.ship_l]">
        <return value="false"/>
      </do_if>

      <label name="search" />
      <find_station name="$stations" functional="true" space="this.zone" multiple="true" >
        <match_relation object="this" relation="neutral" comparison="ge" />
      </find_station>


      <do_if value="not $stations.count">
        <debug_text text="'no stations ' + $stations" chance="$debugchance" />
        <return value="false "/>
      </do_if>

      <debug_text text="'found '+ $stations.count + ' potential targets, finding closest one.'" chance="$debugchance" />
      <create_list name="$stationdists" exact="$stations.count" />
      <do_all exact="$stations.count" counter="$i">
        <set_value name="$stationdists.{$i}" exact="this.ship.distanceto.{$stations.{$i}}" />
      </do_all>
      <set_value name="$station" exact="$stations.{$stationdists.indexof.{$stationdists.min}}" />
      <remove_value name="$stations"/>
      <remove_value name="$stationdists"/>

      <!-- Dock the drones -->
      <run_script name="'lib.recall.drones.vanilla40'" />

      <find_dock_location name="$dockingslot" container="$station" size="this.ship.docksize" />
      <do_if value="$dockingslot">
        <request_docking ship="this.ship" dock="$dockingslot" queued="1" result="$success" />
        <do_if value="$success">
          <get_docking_approach_pos position="$approachpos" rotation="$approachrot" dock="$dockingslot" ship="this.ship" />

          <do_if value="this.attention ge attention.visible">
            <debug_text text="'only set spline on high attention'" chance="$debugchance" />
            <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.spline" />
          </do_if>

          <!-- boost to it -->
          <debug_text text="'move to approachpos'" chance="$debugchance" />
          <move_to object="this.ship" destination="$dockingslot.component" forcesteering="false" finishonapproach="true" forceposition="false" forcerotation="false" boost="true">
            <position value="$approachpos" />
            <rotation value="$approachrot" />
            <interrupt>
              <conditions>
                <event_object_destroyed object="$attacker" check="false"/>
              </conditions>
            </interrupt>
          </move_to>

        </do_if>
      </do_if>

      <label name="dock" />

      <do_if value="not $attacker.isoperational">
        <return value="true" />
      </do_if>

      <debug_text text="'dock at station %1'.[$station.knownname]" chance="$debugchance" />

      <run_script name="'move.dockat.vanilla40'" result="$dockresult">
        <param name="destination" value="$station" />
        <param name="dockingslot" value="$dockingslot" />
      </run_script>

      <do_if value="not $dockresult">
        <return value="false" />
      </do_if>


      <label name="checkifsafe" />
      <set_value name="$safechecks" exact="1"/>
      <do_while value="($safechecks le 3) and $attacker.isoperational and (this.ship.distanceto.{$attacker} lt 15km)">
        <set_value name="$safechecks" operation="add" exact="1"/>
        <!-- if we are still not sure if it is safe after 3 waits, just risk it -->
        <wait min="1min" max="2min">
          <interrupt>
            <conditions>
              <check_any>
                <event_object_destroyed object="$attacker" check="false"/>
                <event_object_changed_zone object="$attacker" check="false"/>
                <event_object_changed_zone object="this.ship" />
              </check_any>
            </conditions>
          </interrupt>
        </wait>
        <debug_text text="'wait for %1 to go away'.[$attacker.knownname]" chance="$debugchance" />
      </do_while>

      <label name="undock" />
      <run_script name="'move.undock.vanilla40'" />

      <debug_text text="'stop running/hiding'" chance="$debugchance" />
      <return value="true"/>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="utf-8" ?>
<aiscript name="move.flee.highway.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

 Flee using highways. This script will find a nearby highway and this ship will boost there to fly to the highway's destination
 
 Only allow for small ships (not l or xl size)

  -->
  <params>
    <param name="attacker" default="null" comment="the attacker we are fleeing from" />
    <param name="debugchance" default="0" />
  </params>

  <attention min="unknown">
    <actions>

      <do_if value="this.ship.isclass.[class.ship_xl, class.ship_l]">
        <return value="false"/>
      </do_if>

      <set_value name="$zones" exact="this.zone.adjacentzones" />
      <debug_text text="'zones %1'.[$zones]" chance="$debugchance"/>
      <do_all exact="$zones.count" counter="$i">
        <do_if value="$zones.{$i}.isclass.highway and (not $zones.{$i}.destination.isclass.highway) and ($zones.{$i}.destination != this.zone)">
          <set_value name="$highway" exact="$zones.{$i}" />
          <break/>
        </do_if>
      </do_all>

      <do_if value="$highway?">
        <debug_text text="'$highway %1, destination %2'.[$highway.knownname, $highway.destination.knownname]" chance="$debugchance"/>

        <!-- fly on spline -->
        <do_if value="this.attention ge attention.visible">
          <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.spline" />
        </do_if>

        <!-- fly to the highway if possible boosting -->
        <move_to object="this.ship" destination="$highway.destination" forcesteering="false" usehighways="true" boost="true" finishonapproach="true">
          <interrupt>
            <conditions>
              <check_any>
                <event_object_destroyed object="$attacker" check="false"/>
              </check_any>
            </conditions>
          </interrupt>
        </move_to>

        <return value="true"/>
      </do_if>

      <!-- no nearby highway -->
      <return value="false"/>

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="utf-8" ?>
<aiscript name="move.flee.jump.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--
  
  Flee using an emergency jump, if there is enough fuelcells to make a quick jump
  Only allowed for capital ships (L, XL)

  -->
  <params>
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <!-- Only for capital ship -->
      <do_if value="not this.ship.isclass.[class.ship_xl, class.ship_l]">
        <return value="false" />
      </do_if>

      <!-- Get the jumdrive -->
      <find_object_component name="$jumpdrive" object="this.ship" class="class.jumpdrive"/>
      <!-- valid jumpdrive -->
      <do_if value="$jumpdrive.exists and $jumpdrive.isoperational">
        <debug_text text="'$jumpdrive.cooldowntimeleft  %1'.[$jumpdrive.cooldowntimeleft ]" chance="$debugchance" />
        <!-- Find zone -->
        <find_sector name="$sectors" multiple="true" space="this.cluster"/>
        <!-- sectors on cluster -->
        <debug_text text="'$sectors %1'.[$sectors]" chance="$debugchance" />

        <!-- iterate through all sectors in the current cluster -->
        <do_all exact="$sectors.count" counter="$i">
          <!-- skip current sector -->
          <do_if value="$sectors.{$i}" exact="this.sector">
            <continue/>
          </do_if>
          <!-- get the jump path from this sector, to the end-sector -->
          <get_jump_path component="$path" multiple="true" start="this.sector" end="$sectors.{$i}"/>
          <!-- jump distance of 0 -->
          <do_if value="$path.count == 0">
            <get_closest_jumpbeacon name="$beacon" sector="this.sector"/>
            <debug_text text="'$beacon %1'.[$beacon]" chance="$debugchance" />
            <!-- skip this zone -->
            <do_if value="$beacon.zone == this.zone">
              <continue/>
            </do_if>
          </do_if>
          <do_else>
            <get_closest_jumpbeacon name="$beacon" sector="$path.{2}"/>
            <debug_text text="'$beacon %1'.[$beacon]" chance="$debugchance" />
          </do_else>
          <!-- Found one -->
          <do_if value="$beacon">
            <set_value name="$destination" exact="$beacon.zone" />
            <break/>
          </do_if>
        </do_all>

        <!-- Jump if enough fuel -->
        <do_if value="$destination? and (this.ship.cargo.{ware.fuelcells}.count ge this.ship.jumpcostto.{$destination})">
          <debug_text text="'go jump to %1 (%2)'.[$destination.knownname, $destination]" chance="$debugchance" />
          <!--jump-->
          <run_script name="'move.jump.vanilla40'" result="$jumpresult">
            <param name="destination" value="$destination" />
            <param name="autorefuel" value="false" />
            <param name="debugchance" value="$debugchance" />
          </run_script>

          <return value="$jumpresult" />
        </do_if>
      </do_if>

      <debug_text text="'Failed to flee jumping away'" chance="$debugchance"/>

      <return value="false"/>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.flee.maneuver.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" >
  <!--  
  
  Evade maneuvers for ships on steering (not for capital ships)  
  This only works on 'visible attention level (return false on other attention levels)
  
  -->
  <params>    
    <param name="debugchance" default="0" />
  </params>
  <attention min="visible">
    <actions>

      <!-- Only in high attention for non-capships -->
      <do_if value="this.ship.isclass.[class.ship_xl, class.ship_l]">
        <return value="false" />
      </do_if>

      <!-- Random evasive flight behaviours -->
      <set_value name="$doevade" exact="true" />
      <set_value name="$maxevadedelay" min="player.age + 15s" max="player.age + 25s" />
      <!-- try different moves -->
      <do_while value="$doevade and player.age le $maxevadedelay">
        <set_value name="$doevade" exact="false" />
        <set_value name="$minevadedelay" exact="player.age + 3s" />

        <select_flight_behaviour entity="this" evasive="true" result="$fb" />
        <debug_text text="this.knownname + ': EVADE using '+ $fb + ' behaviour!.' + 'time: ' + player.age" chance="$debugchance" />

        <move_to object="this.ship" destination="this.ship.zone" flightbehaviour="$fb" forcesteering="true">
          <position object="this.ship" min="500m" max="1km"/>
          <interrupt_after_time time="10s"/>
          <interrupt>
            <conditions>
              <check_all>
                <event_object_attacked object="this.ship" />
                <check_age min="$minevadedelay"/>
              </check_all>
            </conditions>
            <actions>
              <set_value name="$doevade" exact="true" />
            </actions>
          </interrupt>
        </move_to>

      </do_while>

      <!-- Restore the spline FCM -->
      <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.spline" />

      <return value="true" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <!-- No point of evasive maneuver OOZ -->
      <return value="false" />
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.flee.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--  
  
  Wrapper script to use Flee, Evade and Retreat maneuvers
  Allowed methods 'boost','maneuver','highway','dock','jump'
  
  -->
  <params>
    <param name="method" comment="Methods 'boost','maneuver','highway','dock','jump'" />
    <param name="attacker" default="null" comment="the attacker we are fleeing from" />
    <param name="debugchance" default="0" />
  </params>
  <init>
    <set_value name="$initpos" exact="[this.zone, this.ship.position]" />
    <set_value name="$attempt" exact="1" />
  </init>
  <attention min="unknown">
    <actions>

      <do_if value="$method" exact="'boost'">
        <resume label="boost" />
      </do_if>
      <do_elseif value="$method" exact="'maneuver'">
        <resume label="maneuver" />
      </do_elseif>
      <do_elseif value="$method" exact="'highway'">
        <resume label="highway" />
      </do_elseif>
      <do_elseif value="$method" exact="'dock'">
        <resume label="dock" />
      </do_elseif>
      <do_elseif value="$method" exact="'jump'">
        <resume label="jump" />
      </do_elseif>

      <debug_text text="'Flee using method %1 (attacker %2)'.[$method, $attacker.knownname]" chance="$debugchance" />

      <!-- #1 - Highway Flee -->
      <label name="highway" />
      <run_script name="'move.flee.highway.vanilla40'" result="$success">
        <param name="attacker" value="$attacker" />
      </run_script>
      <do_if value="$success">
        <resume label="return" />
      </do_if>

      <!-- #2 - Dock at a station -->
      <label name="dock" />
      <run_script name="'move.flee.dock.vanilla40'" result="$success">
        <param name="attacker" value="$attacker" />
      </run_script>
      <do_if value="$success">
        <resume label="return" />
      </do_if>

      <!-- #3 - Boost away -->
      <label name="boost" />
      <run_script name="'move.flee.boost.vanilla40'" result="$success"></run_script>
      <do_if value="$success">
        <resume label="return" />
      </do_if>

      <!-- #4 - Flying evasive maneuvers -->
      <label name="maneuver" />
      <run_script name="'move.flee.maneuver.vanilla40'" result="$success"></run_script>
      <do_if value="$success">
        <resume label="return" />
      </do_if>

      <!-- #5 - Emergency Jump -->
      <label name="jump" />
      <run_script name="'move.flee.jump.vanilla40'" result="$success" />
      <do_if value="$success">
        <resume label="return" />
      </do_if>

      <resume label="finish" />

      <!-- Go back to the inital position -->
      <label name="return" />

      <!-- Inform the player -->
      <do_if value="this.ship.isplayerowned and ($attempt == 1)">
        <!-- with or with out attacker -->
        <do_if value="$attacker.exists">
          <substitute_text text="$logtext" source="{1016,33}" comment="$SHIP$ was forced to flee after being attacked by $ATTACKER$ in $ORIGIN$. Your ship is at $LOCATION$ in $SPACE$.">
            <replace string="'$ATTACKER$'" with="$attacker.name" />
            <replace string="'$SHIP$'" with="this.ship.name" />
            <replace string="'$ORIGIN$'" with="$initpos.{1}.name" />
            <replace string="'$LOCATION$'" with="this.ship.parent.name" />
            <replace string="'$SPACE$'" with="this.ship.sector.name" />
          </substitute_text>
        </do_if>
        <do_else>
          <substitute_text text="$logtext" source="{1016,32}" comment="$SHIP$ was forced to flee after being attacked in $ORIGIN$. Your ship is at $LOCATION$ in $SPACE$.">
            <replace string="'$SHIP$'" with="this.ship.name" />
            <replace string="'$ORIGIN$'" with="$initpos.{1}.name" />
            <replace string="'$LOCATION$'" with="this.ship.parent.name" />
            <replace string="'$SPACE$'" with="this.ship.sector.name" />
          </substitute_text>
        </do_else>
        <!-- write to upkeep -->
        <write_to_logbook category="upkeep" text="$logtext" />
      </do_if>

      <!-- if we changed zone -->
      <do_if value="this.zone != $initpos.{1}">
        <debug_text text="'return to the initial position'" chance="$debugchance" />
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$initpos.{1}" />
          <param name="position" value="$initpos.{2}" />
        </run_script>
      </do_if>

      <!-- Finish the flee -->
      <label name="finish" />
      <debug_text text="'finish flee, success:%1'.[$success]" chance="$debugchance" />

      <!-- when an attempt fails -->
      <do_if value="not $success">
        <do_if value="$attempt ge 2">
          <!-- If there is one or more there is nothing else todo-->
          <debug_text text="'nothing I can do, Help! hull %1, shield %2'.[this.ship.hullpercentage, this.ship.shieldpercentage]" chance="$debugchance"/>
          <wait min="3s" max="10s" />
        </do_if>
        <do_else>
          <!-- not succesful flee, retry something else, starting from the first -->
          <debug_text text="'not succesful flee, retry something else'" chance="$debugchance"/>
          <set_value name="$attempt" exact="1" operation="add" />
          <resume label="highway" />
        </do_else>
      </do_if>

      <return value="$success" />

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.follow.formation.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

  Follow in formation
  by Adrian
  
  Generic routine for following one ship with other/s. Not for capital ships yet!
  Create a formation and join this shipt to it. 
  Is an alternative to move.escort, but in this case it does not manage smart attack reactions.

  -->
  <params>
    <param name="target" />
    <param name="formation" default="formationshape.pointguard" comment="the formation to escort" />
    <param name="formationparam" default="this.ship.size * 2" comment="First parameter for formation" />
    <param name="formationparam2" default="null" comment="Second parameter for formation" />
    <param name="debugoutputchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="AttackHandler.vanilla40"/>
    <handler ref="ScannedHandler.vanilla40" />
  </interrupts>
  <attention min="visible">
    <actions>

      <set_value name="$bigship" exact="this.ship.isclass.ship_xl or this.ship.isclass.ship_l" />

      <!-- Label to allow us to repeat indefinitely -->
      <label name="start" />

      <do_if value="not $target.exists">
        <return />
      </do_if>

      <run_script name="'move.undock.vanilla40'" />

      <!-- ...and go there! -->
      <do_if value="$bigship">
        <!--Big Ship case-->
        <debug_text text="'Target is a big ship. Not supported follow move in a formation. Should move.escort.capital do it?'" chance="$debugoutputchance" />
        <return />        
      </do_if>
      <do_else>
        <!-- Create formation -->
        <create_formation object="$target" formation="$formation" param="$formationparam" param2="$formationparam2" />
        <join_formation leader="$target" object="this.ship" />
        <!-- start Loop -->
        <do_if value="$target.exists">
          <wait>
            <interrupt>
              <conditions>
                <event_object_destroyed object="$target" />
              </conditions>
            </interrupt>
          </wait>
        </do_if>
      </do_else>

      <!-- Restart the script from the top -->
      <resume label="start" />
    </actions>
  </attention>
  <attention min="unknown">
    <actions>
      <!-- TODO: make a different behaviour for unknown-->
      <label name="start" />
      <wait></wait>
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.follow.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="4">
  <!--

  Following Script
  by Adrian
  
  Generic routine for following one ship with another.

  -->
  <params>
    <param name="target" />
    <param name="offset" default="null" comment="Optional offset [x,y,z] relative to the target. Default null means no offset" />
    <param name="debugchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler comment="resume to 'start' if zone changes (only in follow)">
      <conditions>
        <event_object_changed_zone object="$target"/>
        <check_value value="this.command.value" exact="command.follow" />
      </conditions>
      <actions>
        <abort_called_scripts resume="start" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.follow" param="$target" />
  </init>
  <patch sinceversion="3">
    <get_trade_from_shoppinglist object="this.ship" multiple="true" result="$shoppinglist" />
    <!-- Patch ships with shopping items in move.follow, 'abortmovefollow'is set when a shoppinglist item is added -->
    <do_if value="$shoppinglist.count">
      <debug_text text="'patch: has shopping list, set return to default variable'" chance="$debugchance" />
      <set_value name="this.$abortmovefollow" exact="true" />
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>

      <set_value name="$bigship" exact="this.ship.isclass.ship_xl or this.ship.isclass.ship_l" />

      <!-- Label to allow us to repeat indefinitely -->
      <label name="start" />

      <do_if value="not $target.exists">
        <return />
      </do_if>

      <run_script name="'move.undock.vanilla40'" />

      <do_if value="$target.zone.isclass.highway">
        <wait exact="3s" />
        <resume label="start" />
      </do_if>

      <!-- Warp to different zone -->
      <label name="warp" />

      <do_if value="not $target.exists">
        <return />
      </do_if>

      <do_if value="this.ship.zone != $target.zone">
        <!-- TODO @Owen add check if jumping is actually possible ! -->
        <wait exact="10s" />
        <do_if value="$target.zone.isclass.highway">
          <resume label="start" />
        </do_if>
        <!-- Hanlde highways/jumps/gates ... -->
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$target"/>
          <param name="endintargetzone" value="false" />
          <param name="debugchance" value="$debugchance"/>
          <param name="forcesteering" value="false" />
        </run_script>
        <wait exact="3s" />
      </do_if>

      <!-- Abort follow is set -->
      <do_if value="@this.$abortmovefollow">
        <remove_value name="this.$abortmovefollow" />
        <debug_text text="'abortmovefollow is true. It would have continued with shoppinglist in follow'" chance="$debugchance" />
        <return />
      </do_if>

      <!-- ...and go there! -->
      <label name="move" />
      <do_if value="not $target.exists">
        <return />
      </do_if>

      <!-- Get a safe position and the closest distance from target to it -->
      <do_if value="not @$offset">
        <get_safe_pos object="$target" zone="$target.zone" radius="this.ship.size/2" allowyaxis="false" result="$pos" ignored="this.ship"  />
      </do_if>
      <do_else>
        <get_safe_pos object="$target" zone="$target.zone" radius="this.ship.size/2" allowyaxis="false" result="$pos" value="$offset" ignored="this.ship" />
      </do_else>
      <!-- closet distance to pos -->
      <set_value name="$closestdist" exact="$target.distanceto.[$target.zone, $pos]" />

      <!-- Close enought to stop -->
      <do_if value="this.ship.distanceto.{$target}" max="$closestdist + 2km + this.ship.size*2">
        <!-- Is moving -->
        <do_if value="@$moving ">
          <set_value name="$moving" exact="false"/>
          <!-- Stop with a move action to rotate and align -->
          <wait chance="0" comment="compatibility" />
          <move_to object="this.ship" destination="null" sinceversion="0" comment="Compatibility: Necessary to use the do_all loop properly with a new move_to action" chance="0" />
          <!-- In a max of 4 tries -->
          <do_all exact="4" counter="$i">
            <!-- check this place is free -->
            <get_safe_pos zone="this.zone" radius="this.ship.size/2.0" result="$safepos" ignored="this.ship" object="this.ship" />
            <move_to object="this.ship" destination="this.ship.zone" forceposition="false" forcerotation="true" sinceversion="4" commandaction="false">
              <position value="$safepos" z="1m" />
              <rotation pitch="0deg" yaw="this.ship.rotation.yaw" roll="0deg" />
            </move_to>
            <!-- If is free, end -->
            <do_if value="this.ship.distanceto.{$safepos}" max="this.ship.size">
              <break />
            </do_if>
          </do_all>
          <stop_moving object="this.ship" />
        </do_if>
        <!-- If is not moving and close enought, do not do anything -->
      </do_if>
      <!-- Far away, so move -->
      <do_else>
        <!-- Already moving -->
        <do_if value="@$moving">
          <!-- Update target destination, because target moved from the last position -->
          <do_if value="$target.distanceto.[$target.zone, $destination]" min="$closestdist + 2km + this.ship.size*2">
            <set_value name="$moving" exact="false" comment="to restart the movement" />
          </do_if>
          <!-- Update target destination, because we arrive to destination -->
          <do_elseif value="this.ship.distanceto.[this.zone, $destination]" max="this.ship.size">
            <set_value name="$moving" exact="false" comment="to restart the movement" />
          </do_elseif>
        </do_if>
        <!-- Not moving, so move -->
        <do_else>
          <set_value name="$moving" exact="true"/>
          <set_value name="$destination" exact="$pos" />
          <!-- Move and interrupt, to continue with distance checks -->
          <move_to object="this.ship" destination="$target.zone" usehighways="not $bigship" forceposition="false" finishonapproach="true" commandaction="false" sinceversion="2" >
            <position value="$destination" max="1km"/>
            <interrupt_after_time time="0s"/>
          </move_to>
        </do_else>
      </do_else>

      <do_if value="@$moving">
        <set_command_action commandaction="commandaction.flyingto" param="$target" />
      </do_if>
      <do_else>
        <set_command_action commandaction="commandaction.standingby" />
      </do_else>

      <wait min="3s" max="15s" />
      <!-- Restart the script from the top -->
      <resume label="warp" />
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="utf-8" ?>
<aiscript name="move.generic.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="7" priority="1">
  <!--

  Move to Script
  by Michael
  
  Generic routine for moving to a specific location.

  -->
  <params>
    <param name="destination" comment="can be a space or an object in a zone. Providing Sector and Cluster will attempt to find the nearest zone"/>
    <param name="position" default="null" comment="position is treated as an offset to destination. Default: safe position on [0,0,0] of destination"/>
    <param name="rotation" default="null" comment="rotation the ship should have - overrides lookat"/>
    <param name="lookat" default="null" comment="position the ship should point to - overridden by rotation"/>
    <param name="nojump" default="false" comment="set true to prevent Big ships from using their jumpdrive (only use for insector movement - for review when we have capship in-sector boosters)"/>
    <param name="skipcharge" default="false" comment="skip the jump drive charge time (only to be used in special cases e.g. plot missions)"/>
    <param name="ignorefuel" default="false" comment="ignore jump fuel requirements (only to be used in special cases e.g. plot missions)"/>
    <param name="autorefuel" default="true" comment="automatically take steps to re-fuel if necessary"/>
    <param name="disablecollisionavoidance" default="false" comment="HACK - disable collisionavoidance for this ship"/>
    <param name="abortpath" default="true" comment="disable aborting existing path"/>
    <param name="forcesteering" default="false" comment="force steering flight control model"/>
    <param name="endintargetzone" default="false" comment="complete this script if we are in the correct zone, no matter where"/>
    <param name="debugchance" default="0"/>
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
  </interrupts>
  <attention min="unknown">
    <actions>
      <do_if value="$disablecollisionavoidance">
        <set_avoid_collisions object="this.ship" enabled="false"/>
      </do_if>
      <set_value name="$bigship" exact="this.ship.isclass.ship_xl or this.ship.isclass.ship_l" />

      <run_script name="'move.undock.vanilla40'" />

      <label name="check" />

      <do_if value="(not $destination.exists) or (not $destination.isoperational)">
        <debug_text text="'ERROR: destination does not exist!'" chance="$debugchance" comment="could be a valid case because if it's an object or a tempzone"/>
        <return />
      </do_if>

      <do_if value="$destination.isclass.zone">
        <do_if value="$bigship and $destination.isclass.highway">
          <debug_text text="'Error: %1(%2) has been told to fly into highway %3(%4).'.[this.ship.knownname, this.ship, $destination.knownname, $destination]"/>
          <return/>
        </do_if>
        <set_value name="$targetzone" exact="$destination"/>
      </do_if>
      <do_elseif value="$destination.isclass.sector or $destination.isclass.cluster">
        <!--Is the ship already there?-->
        <do_if value="this.ship.hascontext.{$destination}">
          <return/>
        </do_if>

        <debug_text text="'Attempting to find nearest zone within :' + $destination.knownname" chance="$debugchance"/>
        <find_zone name="$pathzone" priorityzone="true" tempzone="false" space="$destination">
          <match class="class.highway" negate="true"/>
        </find_zone>
        <do_if value="$pathzone">
          <get_global_path component="$pathcomponents" usehighways="false" multiple="true">
            <start object="this.ship"/>
            <end object="$pathzone"/>
          </get_global_path>
          <do_all exact="$pathcomponents.count" counter="$Counter">
            <do_if value="$pathcomponents.{$Counter}.hascontext.{$destination}">
              <do_if value="$pathcomponents.{$Counter}.isclass.zone and @$pathcomponents.{$Counter}.haspriority">
                <set_value name="$targetzone" exact="$pathcomponents.{$Counter}"/>
                <break/>
              </do_if>
              <do_elseif value="$pathcomponents.{$Counter}.isclass.object">
                <set_value name="$targetzone" exact="$pathcomponents.{$Counter}.zone"/>
                <break/>
              </do_elseif>
            </do_if>
          </do_all>
        </do_if>
        <do_if value="$targetzone?">
          <remove_value name="$pathzone"/>
          <remove_value name="$pathcomponents"/>
          <set_value name="$destination" exact="$targetzone"/>
          <debug_text text="'Setting destination to :' + $destination.knownname" chance="$debugchance"/>
        </do_if>
        <do_else>
          <debug_text text="'ERROR: No path found to ' + $destination.knownname"/>
          <return/>
        </do_else>
      </do_elseif>
      <do_else>
        <do_if value="$bigship and $destination.zone.isclass.highway">
          <!-- chance="$debugchance"-->
          <debug_text text="'%1(%2) has been told to follow %3(%4) which is in a highway. Waiting.'.[this.ship.knownname, this.ship, $destination.knownname, $destination]"/>
          <wait min="45s" max="60s" sinceversion="4">
            <interrupt>
              <conditions>
                <event_object_changed_zone object="$destination"/>
              </conditions>
            </interrupt>
          </wait>
          <resume label="check"/>
        </do_if>
        <set_value name="$targetzone" exact="$destination.zone"/>
      </do_else>

      <do_if value="$nojump and this.sector != $destination.sector">
        <set_value name="$nojump" exact="false"/>
        <debug_text text="'ERROR: Setting $nojump to false as the destination is in another sector. On ' + this.ship.knownname + ' in ' + this.zone.knownname"/>
      </do_if>

      <label name="move" />

      <do_if value="(not $destination.exists) or (not $destination.isoperational)">
        <debug_text text="'ERROR: destination does not exist!'" chance="$debugchance" comment="could be a valid case because if it's an object or a tempzone"/>
        <return />
      </do_if>

      <!-- command action calculating -->
      <set_command_action commandaction="commandaction.calculating" />

      <!-- check offset position. If there is not, set a safepos on a random direction -->
      <do_if value="not $position">
        <do_if value="$targetzone == $destination">
          <get_safe_pos result="$position" zone="$targetzone" object="$destination" radius="this.ship.size" max="this.ship.size * 3" ignored="this.ship" />
        </do_if>
        <do_else>
          <!-- we are going to something that is not a zone, default to no relative offset - we are creating a safepos in the short-distance section anyway -->
          <set_value name="$position" exact="position.[0, 0, 0]" />
        </do_else>
      </do_if>

      <do_if value="(this.zone != $targetzone) and (this.ship.distanceto.[$destination, $position] gt 20km)">
        <!-- long distance -->
        <do_if value="$bigship">
          <do_if value="(this.sector == $destination.sector) or ($nojump == true)">
            <debug_text text="'Long distance trip. Using engine booster...'" chance="$debugchance" />
            <run_script name="'move.nohighway.vanilla40'" result="$nohighwayresult">
              <param name="target" value="$destination" />
              <param name="position" value="$position" />
              <param name="debugchance" value="$debugchance" />
            </run_script>
            <run_script name="'move.nohighway.vanilla40'" chance="0" />
            <debug_text text="'boost complete. Moving into final position.'" chance="$debugchance" />
            <do_if value="@$nohighwayresult">
              <do_if value="$endintargetzone">
                <!-- no need to move to a safepos now, we're happy just being here -->
                <return />
              </do_if>
            </do_if>
            <do_else>
              <debug_text text="'long-distance boost move failed: distance to target pos: %1, current zone: %2, target zone: %3, target pos %4, relative to %5'.[this.ship.distanceto.[$destination, $position], this.zone.knownname, $targetzone.knownname, $position, $destination]" filter="error" chance="$debugchance" />
              <!-- Boost faild, go to check -->
              <wait min="1s" max="3s" />
              <resume label="check" />
            </do_else>
          </do_if>
          <do_else>
            <!--Move through gate  -->
            <get_jump_path start="this.sector" end="$targetzone.sector" component="$jumppath" multiple="true" />
            <do_if value="$jumppath.{1} == this.sector and $jumppath.{2}.isclass.gate">

              <run_script name="'move.jumpgate.vanilla40'" sinceversion="3">
                <param name="jumpgate" value="$jumppath.{2}" comment="the jumpgate" />
                <param name="debugchance" value="$debugchance" />
              </run_script>

              <!-- compatibility -->
              <move_to object="this.ship" destination="this.zone" usehighways="false" finishonapproach="true" abortpath="true" sinceversion="6" chance="0">
                <interrupt_after_time time="0s" />
              </move_to>
            </do_if>
            <do_else>
              <debug_text text="'Long distance trip. Using jump drive...'" chance="$debugchance" />
              <run_script name="'move.jump.vanilla40'" result="$jumpresult">
                <param name="destination" value="$destination" />
                <param name="position" value="$position" />
                <param name="skipcharge" value="$skipcharge" />
                <param name="ignorefuel" value="$ignorefuel" />
                <param name="autorefuel" value="$autorefuel" />
                <param name="debugchance" value="$debugchance" />
              </run_script>
              <do_if value="$jumpresult" exact="false">
                <debug_text text="'ERROR: Jump to %1(%2) failed'.[$destination.knownname, $position]" />
                <set_value name="$nojump" exact="true" />
                <wait min="10s" max="1min" />
              </do_if>
            </do_else>
            <debug_text text="'Jump/move gate complete. Moving into final position.'" chance="$debugchance" />
            <resume label="check" />
          </do_else>
        </do_if>
        <do_else>
          <debug_text text="'Long distance trip. Using highways...'" chance="$debugchance" />
          <move_to object="this.ship" destination="$destination" usehighways="true" abortpath="$abortpath" forcesteering="$forcesteering" forceposition="false">
            <position value="$position" />
            <interrupt>
              <conditions>
                <event_object_changed_zone object="this.ship" zone="$targetzone" />
              </conditions>
            </interrupt>
          </move_to>
          <debug_text text="'Arrived in zone %1. Moving to final position.'.[$targetzone.knownname]" chance="$debugchance" />
        </do_else>
      </do_if>

      <!-- short distance -->
      <!-- for compatibility interrupt the actions after 0s -->
      <move_to object="this.ship" destination="$entrygate" usehighways="not $bigship" finishonapproach="true" abortpath="$abortpath" chance="0">
        <interrupt_after_time time="0s" />
      </move_to>
      <move_gate object="this.ship" gate="$entrygate" abortpath="true" chance="0">
        <interrupt_after_time time="0s" />
      </move_gate>
      <wait sinceversion="1" exact="0" chance="0"/>
      <move_to object="this.ship" destination="this.zone" usehighways="false" finishonapproach="true" abortpath="true" sinceversion="6" chance="0">
        <interrupt_after_time time="0s" />
      </move_to>

      <do_if value="@$endintargetzone and this.ship.zone == $targetzone">
        <!-- no need to move to a safepos now, we're happy just being here -->
        <return />
      </do_if>

      <move_to object="this.ship" destination="null" comment="Compatibility: Necessary to use the do_all loop properly with a new move_to action" chance="0" />
      <move_to object="this.ship" destination="null" comment="Compatibility: Necessary to use the do_all loop properly with a new move_to action" chance="0" sinceversion="2" />

      <!-- check destination -->
      <do_if value="(not $destination.exists) or (not $destination.isoperational)">
        <debug_text text="'ERROR: destination does not exist!'" chance="$debugchance" comment="could be a valid case because if it's an object or a tempzone"/>
        <return />
      </do_if>

      <!-- Safety check if were are not in the correct targetzone yet. Valid case with moving ships  -->
      <do_if value="$destination.isclass.ship and ($destination.zone != $targetzone)">
        <debug_text text="'Destination is a ship, and it changed zone, so targetzone is outdated, resume to check again' " chance="$debugchance" />
        <resume label="check" />        
      </do_if>
      
      <!-- regular position in space -->
      <get_safe_pos result="$safepos" zone="$targetzone" radius="this.ship.size" object="$destination" value="$position" ignored="this.ship" />
      <do_if value="not @$rotation and @$lookat">
        <create_orientation name="$rotation" orientation="look_at" refposition="$lookat">
          <position value="$safepos" />
        </create_orientation>
      </do_if>
      <debug_text text="'Short distance trip to %1 in %2. D=%3, using highways: %4'.[$safepos, $targetzone.knownname, this.ship.distanceto.[$targetzone, $safepos], (not $bigship)]" chance="$debugchance" />
      <do_if value="not @$rotation">
        <move_to object="this.ship" destination="$targetzone" usehighways="not $bigship" abortpath="$abortpath" forcesteering="(not $bigship) and $forcesteering" forceposition="false" finishonapproach="true" sinceversion="5" >
          <position value="$safepos" max="this.ship.size" />
        </move_to>
      </do_if>
      <do_else>
        <move_to object="this.ship" destination="$targetzone" usehighways="not $bigship" abortpath="$abortpath" forcesteering="(not $bigship) and $forcesteering" forceposition="false" finishonapproach="true" sinceversion="5">
          <position value="$safepos" />
          <rotation value="$rotation" />
        </move_to>
      </do_else>

      <!-- If it's not yet close enough to the position -->
      <do_if value="not $destination.isclass.ship and this.ship.distanceto.[$targetzone, $safepos] gt 10km">
        <debug_text text="'Not successfuly reached the position in targetzone %1(%2)! %3(%4) is currently in %5(%6), %7m from the target destination (actual distance %8).'.[$targetzone.knownname, $targetzone, this.ship.knownname, this.ship, this.ship.zone.knownname, this.ship.zone, this.ship.distanceto.[$targetzone, $safepos], this.ship.distanceto.[$destination, $position]]" filter="error" chance="$debugchance" />
      </do_if>

      <move_to object="this.ship" destination="$targetzone" forceposition="false" forcerotation="true" sinceversion="5" chance="0"/>
      <move_to object="this.ship" destination="$targetzone" forceposition="false" forcerotation="false" sinceversion="5" chance="0"/>
      <wait exact="5s" sinceversion="3" chance="0"/>
      <set_to_default_flight_control_model object="this.ship" />
      <stop_boost object="this.ship" />
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.hack.station.storage.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" >
  <!--

  Move and hack a station to collect cargo
  by Owen
  -->
  <params>
    <param name="target" comment="The object to fight with" />
    <param name="basket" default="[]" comment="List of wares to find (empty means fill with what you can)"/>
    <param name="module" default="null" comment="Storage module to steal from"/>
    <param name="movetomodule" default="true" comment="Attempt to move to the best position for the collection. Bool incase caller already has moved to desired position"/>
    <param name="fleezone" default="null"/>
    <param name="debugoutputchance" default="0" />
  </params>
  <interrupts>
    <handler>
      <conditions>
        <event_object_attacked object="this.ship"/>
        <check_value value="@event.param.owner == $target.owner"/>
        <check_value value="not $fleeing?"/>
      </conditions>
      <actions>
        <do_if value="this.ship.shieldpercentage lt 75">
          <set_value name="$fleeing"/>
          <abort_called_scripts resume="flee"/>
        </do_if>
        <do_if value="not $lastattack?">
          <set_value name="$lastattack" exact="player.age"/>
          <set_value name="$shieldvalue" exact="this.ship.shieldpercentage"/>
        </do_if>
        <do_elseif value="player.age gt $lastattack + 10s">
          <do_if value="($shieldvalue - this.ship.shieldpercentage gt 0) and this.ship.shieldpercentage - ($shieldvalue - this.ship.shieldpercentage) lt 70">
            <set_value name="$fleeing"/>
            <abort_called_scripts resume="flee"/>
          </do_if>
          <do_else>
            <set_value name="$lastattack" exact="player.age"/>
            <set_value name="$shieldvalue" exact="this.ship.shieldpercentage"/>
          </do_else>
        </do_elseif>
      </actions>
    </handler>
  </interrupts>

  <attention min="unknown">
    <actions>
      <label name="start" />

      <set_value name="$matchingwares" exact="[]"/>
      <do_if value="$module">
        <set_value name="$targetcargo" exact="$module.cargo.list"/>
      </do_if>
      <do_else>
        <set_value name="$targetcargo" exact="$target.cargo.list"/>
      </do_else>

      <do_all exact="$targetcargo.count" counter="$i">
        <do_if value="$basket.count">
          <do_if value="$basket.indexof.{$targetcargo.{$i}} and this.ship.cargo.{$targetcargo.{$i}}.free">
            <append_to_list name="$matchingwares" exact="$targetcargo.{$i}"/>
          </do_if>
        </do_if>
        <do_elseif value="this.ship.cargo.{$targetcargo.{$i}}.free">
          <append_to_list name="$matchingwares" exact="$targetcargo.{$i}"/>
        </do_elseif>
      </do_all>

      <debug_text text="this.ship.knownname + ': attacking '+ $target.knownname +'! It contains: ' + $matchingwares" chance="$debugoutputchance" />

      <do_if value="not $module">
        <!--Find a storage module to steal from-->

        <find_object_component name="$module" object="$target" class="class.storage" required="true">
          <match_any_cargo wares="$matchingwares"/>
        </find_object_component>

        <do_if value="not $module">
          <debug_text text="'No module found which contains ' + $matchingwares"/>
          <wait min="1s" max="3s"/>
          <return value="false"/>
        </do_if>
      </do_if>

      <set_value name="$targetpos" exact="$target.position"/>
      <create_position name="$modulepos" object="$module" space="$target.zone"/>
      <do_if value="$movetomodule">
        <create_orientation name="$orientation" refposition="$modulepos" orientation="look_at">
          <position value="$targetpos"/>
        </create_orientation>
        <transform_position name="$parkposition" refposition="$targetpos" refrotation="$orientation">
          <position z="($target.size / 2) + (this.ship.size * 2.5)"/>
        </transform_position>

        <!--attempt to find the best alignment, left or right, to get to the flee zone-->

        <do_if value="$fleezone">
          <set_value name="$fleezones" exact="[$fleezone]"/>
        </do_if>
        <do_else>
          <find_zone name="$fleezones" space="this.sector" tempzone="false" priorityzone="true" multiple="true">
            <match class="class.highway" negate="true"/>
          </find_zone>
          <remove_value name="$fleezones.{$fleezones.indexof.{$target.zone}}"/>
        </do_else>

        <do_if value="$fleezones.count">
          <create_orientation name="$orientation" refposition="$modulepos" orientation="align_right">
            <position value="$parkposition"/>
          </create_orientation>
          <transform_position name="$rightposition" refposition="$parkposition" refrotation="$orientation">
            <position z="100km"/>
          </transform_position>
          <transform_position name="$leftposition" refposition="$parkposition" refrotation="$orientation">
            <position z="-100km"/>
          </transform_position>

          <set_value name="$alignright" exact="true"/>
          <set_value name="$checkposition" exact="$rightposition"/>
          <set_value name="$nearestzone" exact="null"/>
          <!--Loop twice, checking the right alignment position first, then left. Store the closest of all-->
          <do_all exact="2" counter="$k">
            <do_all exact="$fleezones.count" counter="$i">
              <do_if value="not $nearestzone or $fleezones.{$i}.distanceto.[$target.zone, $checkposition] lt $nearestzone.{2}">
                <set_value name="$nearestzone" exact="[$fleezones.{$i}, $fleezones.{$i}.distanceto.[$target.zone, $checkposition]]"/>
                <do_if value="$k == 2">
                  <set_value name="$alignright" exact="false"/>
                </do_if>
              </do_if>
            </do_all>
            <set_value name="$checkposition" exact="$leftposition"/>
          </do_all>
          <set_value name="$fleezone" exact="$nearestzone.{1}"/>
          <debug_text text="'fleezone is ' + $fleezone.knownname" chance="$debugoutputchance"/>
          <do_if value="$alignright">
            <set_value name="$parkorientation" exact="$orientation"/>
          </do_if>
          <do_else>
            <create_orientation name="$parkorientation" refposition="$modulepos" orientation="align_left">
              <position value="$parkposition"/>
            </create_orientation>
          </do_else>
          <remove_value name="$nearestzone"/>
        </do_if>
        <do_else>
          <set_value name="$fleezone" exact="$target.zone"/>
        </do_else>
      </do_if>
      <do_else>
        <!--Ship already in position-->
        <set_value name="$parkposition" exact="this.ship.position"/>
        <set_value name="$parkorientation" exact="this.ship.rotation"/>

        <!--Attempt to find $flee zone-->
        <do_if value="not $fleezone">
          <find_zone name="$fleezones" space="this.sector" tempzone="false" priorityzone="true" multiple="true">
            <match class="class.highway" negate="true"/>
          </find_zone>
          <remove_value name="$fleezones.{$fleezones.indexof.{$target.zone}}"/>

          <do_if value="$fleezones.count">
            <transform_position name="$forwardposition" refposition="$parkposition" refrotation="$parkorientation">
              <position z="100km"/>
            </transform_position>

            <set_value name="$nearestzone" exact="null"/>
            <do_all exact="$fleezones.count" counter="$i">
              <do_if value="not $nearestzone or $fleezones.{$i}.distanceto.[$target.zone, $forwardposition] lt $nearestzone.{2}">
                <set_value name="$nearestzone" exact="[$fleezones.{$i}, $fleezones.{$i}.distanceto.[$target.zone, $forwardposition]]"/>
              </do_if>
            </do_all>

            <set_value name="$fleezone" exact="$nearestzone.{1}"/>
          </do_if>
          <do_else>
            <set_value name="$fleezone" exact="$target.zone"/>
          </do_else>
        </do_if>
      </do_else>

      <do_if value="$movetomodule">
        <move_to object="this.ship" usehighways="false" destination="$target.zone">
          <position value="$parkposition"/>
          <rotation value="$parkorientation"/>
        </move_to>
      </do_if>

      <label name="collect" />

      <set_object_hacked object="$module" duration="3min" hacker="this.ship" dropresult="$drops"/>
      <sort_collectables_by_value name="$sortedlist" collectables="$drops" object="this.ship" />
      <add_to_group groupname="$dropgroup" list="$sortedlist"/>

      <wait min="5s" max="10s"/>
      <debug_text text="'Target was hacked. Checking for crates. wares: %1'.[$matchingwares]" chance="$debugoutputchance"/>
      <run_script name="'move.collect.ship.vanilla40'">
        <param name="targetgroup" value="$dropgroup"/>
        <param name="debugoutputchance" value="$debugoutputchance"/>
      </run_script>

      <label name="flee"/>

      <set_value name="$fleeing" exact="true"/>

      <set_value name="$subordinates" exact="this.ship.subordinates"/>
      <do_all exact="$subordinates.count" counter="$i">
        <do_if value="$subordinates.{$i}.isclass.ship_xs and $subordinates.{$i}.primarypurpose != objectpurpose.fight">
          <debug_text text="'Destructing ' + $subordinates.{$i} + ' ' + $subordinates.{$i}.knownname"/>
          <destroy_object object="$subordinates.{$i}" explosion="true"/>
        </do_if>
      </do_all>

      <run_script name="'move.generic.vanilla40'">
        <param name="destination" value="$fleezone"/>
        <param name="debugchance" value="$debugoutputchance"/>
      </run_script>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.hack.stations.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="range" default="this.sector" comment="space class (used with ships current space), or space component."/>
    <param name="returntobase" default="true" comment="After filling cargobay, return wares to base? Base can be any trade station of this faction within this cluster."/>
    <param name="checkrelation" default="false" comment="Check the maybeattackedby status of potential targets. Otherwise, find any which are not of your faction"/>
    <param name="basebasket" default="this.ship.warebasket.list" comment="Base warebasket. Default to that setup in jobs"/>
    <param name="debugoutputchance" default="0" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler ref="AttackHandler.vanilla40" />
    <handler ref="ScannedHandler.vanilla40" />
  </interrupts>
  <init>
    <!--TODO: Piracy?-->
    <set_command command="command.patrol"  />
    <set_command_action commandaction="commandaction.calculating" />
    <set_value name="$seektargets" exact="false"/>
  </init>
  <attention min="unknown">
    <actions>

      <label name="start" />
      <do_if value="not (this.ship.isclass.ship_l or this.ship.isclass.ship_xl)">
        <assert value="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" exact="'move.hack.stations not currently supporting non-capships'"/>
        <return value="false"/>
      </do_if>
      <set_value name="$capship" exact="true" />

      <set_value name="$startzone" exact="this.ship.zone" />
      <!-- Has a job main zone? -->
      <do_if value="this.ship.jobmainzone">
        <set_value name="$startzone" exact="this.ship.jobmainzone"/>
      </do_if>
      <set_value name="$targetzone" exact="this.ship.zone" />
      <set_value name="$searchendtime" exact="0"/>
      <set_value name="$pos" exact="this.ship.position"/>

      <do_if value="$basebasket.count">
        <!--Fuelcells are always good-->
        <set_value name="$basket" exact="$basebasket"/>
        <do_if value="not $basket.indexof.{ware.fuelcells}">
          <append_to_list name="$basket" exact="ware.fuelcells"/>
        </do_if>
      </do_if>
      <do_else>
        <set_value name="$basket" exact="[]"/>
      </do_else>
      <debug_text text="this.ship.knownname + ', ' + this.zone.knownname + 'Pirate basket is: ' + $basket" chance="$debugoutputchance"/>

      <do_if value="$checkrelation">
        <set_value name="$attacker" exact="this.ship"/>
      </do_if>
      <do_else>
        <set_value name="$attacker" exact="null"/>
      </do_else>

      <run_script name="'move.undock.vanilla40'" />

      <break_formation object="this.ship" />

      <do_if value="$capship">
        <set_value name="$search_duration" exact="20min" />
      </do_if>
      <do_else>
        <set_value name="$search_duration" exact="10min" />
        <create_formation formation="formationshape.vshape" object="this.ship" param="this.ship.size * 1.5" />
      </do_else>

      <do_if value="typeof $range == datatype.component">
        <set_value name="$space" exact="$range"/>
      </do_if>
      <do_elseif value="typeof $range == datatype.class">
        <do_if value="$range == class.zone">
          <set_value name="$space" exact="this.zone"/>
        </do_if>
        <do_elseif value="$range == class.sector">
          <set_value name="$space" exact="this.sector"/>
        </do_elseif>
        <do_elseif value="$range == class.cluster">
          <set_value name="$space" exact="this.cluster"/>
        </do_elseif>
      </do_elseif>

      <label name="find_destination" />

      <do_if value="$space.isclass.zone">
        <set_value name="$targetzone" exact="$space"/>
      </do_if>
      <do_else>
        <find_zone name="$targetzone" space="$space" tempzone="false" priorityzone="true">
          <match class="class.highway" negate="true"/>
        </find_zone>
      </do_else>

      <do_if value="$targetzone">
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$targetzone" />
          <param name="endintargetzone" value="true"/>
        </run_script>
      </do_if>

      <find_station name="$stations" space="this.zone" multiple="true">
        <match owner="this.trueowner" negate="true"/>
      </find_station>

      <set_value name="$suitablestations" exact="[]"/>
      <do_all exact="$stations.count" counter="$i">
        <set_value name="$stationcargo" exact="$stations.{$i}.cargo.list"/>
        <do_all exact="$stationcargo.count" counter="$i">
          <do_if value="$basket.count">
            <do_if value="$basket.indexof.{$stationcargo.{$i}} and this.ship.cargo.{$stationcargo.{$i}}.free">
              <append_to_list name="$suitablestations" exact="$stations.{$i}"/>
              <break/>
            </do_if>
          </do_if>
          <do_elseif value="this.ship.cargo.{$stationcargo.{$i}}.free">
            <append_to_list name="$suitablestations" exact="$stations.{$i}"/>
            <break/>
          </do_elseif>
        </do_all>
      </do_all>

      <do_if value="not $suitablestations.count">
        <get_safe_pos result="$safepos" allowyaxis="false" max="20km" radius="this.ship.size" zone="this.zone"/>
        <move_to object="this.ship" finishonapproach="true" destination="this.zone" usehighways="false">
          <position value="$safepos"/>
        </move_to>

        <wait min="1s" max="10s"/>
        <resume label="find_destination"/>
      </do_if>

      <!--Found some suitable stations to hack and steal from-->

      <set_value name="$target" exact="$suitablestations.random"/>

      <label name="hack" />

      <run_script name="'move.hack.station.storage.vanilla40'">
        <param name="target" value="$target "/>
        <param name="debugoutputchance" value="$debugoutputchance" />
      </run_script>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired or not this.ship.units.{unitcategory.transport}.count">
        <debug_text text="'%1 doing job %2 has expired or has no transport drones %3: die!'.[this.ship.knownname, this.ship.job, this.ship.units.{unitcategory.transport}.count]" chance="$debugoutputchance" />
        <run_script name="'move.die.vanilla40'">
          <param name="byjump" value="$capship" />
          <param name="byhostile" value="true" />
        </run_script>
      </do_if>

      <!--Calculate the free space in the ship, excluding fuel-->
      <set_value name="$freespace" exact="this.ship.cargo.free - this.ship.cargo.{ware.fuelcells}.free"/>
      <set_value name="$capacity" exact="this.ship.cargo.capacity - this.ship.cargo.{ware.fuelcells}.max"/>

      <!-- No capacity -->
      <do_if value="not $capacity">
        <debug_text text="'No capacity for some reason. Destroyed storage modules?'" chance="$debugoutputchance"/>
        <wait min="2min" max="3min" />
        <resume label="find_destination"/>
      </do_if>
      <!-- More than 5% of free space, so keep going -->
      <do_elseif value="(100.0f / $capacity) * $freespace" min="5">
        <do_if value="((100.0f / $capacity) * $freespace) != 100" chance="$debugoutputchance">
          <debug_text text="this.ship.knownname + ' has ' + ((100.0f / $capacity) * $freespace) + '% of cargo free, excluding fuel. Continuing to search.'"/>
        </do_if>
        <resume label="find_destination"/>
      </do_elseif>

      <label name="offload"/>
      <debug_text text="this.ship.knownname + ' has ' + ((100.0f / $capacity) * $freespace) + '% of cargo filled, excluding fuel. Looking to offload some.'" chance="$debugoutputchance"/>

      <!-- Enable dropping of wares at a station-->
      <do_if value="$returntobase">
        <!-- With commander, try to get sell to him, otherwise free trade in range -->
        <!-- 'trade.findtraderun' handles the case of commander with no offers -->
        <set_value name="$traderunscript" exact="if this.ship.commander.isoperational then 'trade.findtraderun.vanilla40' else 'trade.findfreetraderun.vanilla40'" />
        <!-- Find buy offer. Selloffer is not needed -->
        <run_script name="$traderunscript">
          <param name="warelist" value="this.ship.cargo.list" />
          <param name="range" value="$space" />
          <param name="debugchance" value="$debugoutputchance"/>
          <save_retval name="buyoffer" variable="$buyoffer" />
        </run_script>
        <!-- Execute the trade -->
        <run_script name="'trade.performtraderun.vanilla40'">
          <param name="selloffer" value="null" />
          <param name="buyoffer" value="$buyoffer" />
          <param name="debugchance" value="$debugoutputchance" />
          <save_retval name="success" variable="$success" />
        </run_script>

        <remove_value name="$buyoffer" />
        <remove_value name="$traderunscript" />

      </do_if>
      <do_else>
        <run_script name="'move.die.vanilla40'" >
          <param name="byhostile" value="true" />
        </run_script>
      </do_else>

      <resume label="find_destination"/>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.idle.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <!--

  Idle Random Movement Script
  by Adrian
  
  Generic routine for idle flying a ship around to random positions in its current zone.

  -->
  <params>
    <param name="TimeOut" default="null" comment="duration of the idle move"/>
    <!--Defaults have the ship flying around its original position-->
    <param name="Offset" default="this.ship.position" />
    <param name="MaxDistance" default="10km"/>
    <param name="debugchance" default="0"/>
  </params>
  <patch sinceversion="1">
    <!-- removed script param $Anchor, the caller needs to ensure the ship is in the correct zone before calling move.idle -->
    <do_if value="this.ship.zone.isclass.highway">
      <set_value name="$Anchor" exact="this.ship.zone.exit.zone" />
    </do_if>
    <do_else>
      <set_value name="$Anchor" exact="this.ship.zone" />
    </do_else>
  </patch>
  <attention min="unknown">
    <actions>

      <set_value name="$iscapship" exact="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" />

      <run_script name="'move.undock.vanilla40'" />

      <do_if value="$TimeOut">
        <do_if value="$TimeOut" min="1">
          <!--Timeout is now the end time-->
          <set_value name="$TimeOut" exact="player.age + $TimeOut"/>
        </do_if>
        <do_else>
          <debug_text text="'Timeout is : ' + $TimeOut + 'Setting to null. Movement will be infinite'" chance="$debugchance" />
          <set_value name="$TimeOut" exact="null"/>
        </do_else>
      </do_if>

      <!-- Label to allow us to repeat indefinitely -->
      <label name="start" />

      <do_while value="true" comment="infinite loop">

        <!-- If it has Time Out, set the remaining time-->
        <set_value name="$DoMove" exact="true"/>
        <do_if value="$TimeOut" min="1">
          <set_value name="$RemainingTime" exact="$TimeOut - player.age"/>
          <do_if value="$RemainingTime lt 0">
            <set_value name="$DoMove" exact="false"/>
          </do_if>
          <do_else>
            <debug_text text="'RemainingTime is:' + $RemainingTime" chance="$debugchance" />
          </do_else>
        </do_if>

        <do_if value="$DoMove">

          <!-- make sure this move_to won't cross zones -->
          <do_if value="this.ship.zone.isclass.highway">
            <set_value name="$Anchor" exact="this.ship.zone.exit.zone" />
          </do_if>
          <do_else>
            <set_value name="$Anchor" exact="this.ship.zone" />
          </do_else>

          <debug_text text="'moving ' + this.ship.knownname + ' to ' + $Anchor " chance="$debugchance" />

          <!-- Create safe random position -->
          <do_if value="$iscapship">
            <create_position name="$temp" object="this.ship" x="$MaxDistance/2" z="$MaxDistance" space="$Anchor"/>
            <get_safe_pos result="$randpos" x="$temp.x" y="this.ship.position.y" z="$temp.z" radius="this.ship.size" zone="$Anchor" angle="60deg" direction="quadrant.front" directionobject="this.ship"/>
          </do_if>
          <do_else>
            <create_position name="$temp" value="$Offset" min="this.ship.size*2" max="$MaxDistance" space="$Anchor" />
            <get_safe_pos result="$randpos" value="$temp" radius="this.ship.size" zone="$Anchor"/>
          </do_else>

          <!-- Make the random movement (with an interruption if necessary) -->
          <do_if value="@$RemainingTime">
            <move_to object="this.ship" destination="$Anchor" finishonapproach="true" forceposition="false" commandaction="false" usehighways="not $iscapship">
              <position value="$randpos"/>
              <interrupt_after_time time="$RemainingTime"/>
            </move_to>
          </do_if>
          <do_else>
            <!-- Infinite movevement -->
            <move_to object="this.ship" destination="$Anchor" finishonapproach="true" forceposition="false" commandaction="false" usehighways="not $iscapship">
              <position value="$randpos" />
            </move_to>
          </do_else>

          <debug_text text="'reached position' " chance="$debugchance"  />
        </do_if>

        <!-- If there is no more remain time (<0), finish -->
        <do_if value="@$RemainingTime" >
          <do_if value="$RemainingTime lt 0" >
            <debug_text text="'Finishing because RemainingTime:' + $RemainingTime" chance="$debugchance"  />
            <return/>
          </do_if>
        </do_if>

        <wait min="100ms" max="500ms" />

      </do_while>

    </actions>
  </attention>
</aiscript>

<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.jump.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="2">
  <!--TODO:
  - Orientation type able to be passed as an expression
  - allowyaxis able to be passed as an expression-->
  <params>
    <param name="destination" comment="can be a zone or an object in a zone"/>
    <param name="position" default="position.[0,0,0]" comment="position is treated as an offset to destination"/>
    <!--<param name="orientation" default="null" comment="TODO: Be able to pass orientation as expressions"/>-->
    <param name="rotation" default="null" comment="rotation used if orientation not passed (will not currently work as orientation is always passed)"/>
    <param name="safepos" default="true" comment="use safepos when jumping"/>
    <param name="skipcharge" default="false" comment="skip the jump drive charge time (only to be used in special cases e.g. plot missions)"/>
    <param name="ignorefuel" default="false" comment="ignore jump fuel requirements (only to be used in special cases e.g. plot missions)"/>
    <param name="autorefuel" default="true" comment="automatically take steps to re-fuel if necessary"/>
    <param name="forcejump" default="false" comment="force the ship to use the jumpdrive, even for in-sector destinations"/>
    <param name="nonstop" default="false" comment="force the ship to jump to destination directly in a single jump, even if it's across clusters (only to be used in special cases e.g. plot missions)"/>
    <param name="debugchance" default="0"/>
  </params>
  <attention min="unknown">
    <actions>

      <label name="initialization"/>

      <!-- command action jumping-->
      <set_command_action commandaction="commandaction.jumping" />

      <set_value name="$failreason" exact="''"/>

      <run_script name="'move.undock.vanilla40'" />

      <do_if value="$destination.isclass.zone">
        <set_value name="$targetzone" exact="$destination"/>
        <do_if value="$targetzone.isclass.highway">
          <set_value name="$failreason" exact="'ERR_ATTEMPT_TO_JUMP_TO_HIGHWAY'"/>
          <resume label="finish" />
        </do_if>
      </do_if>
      <do_else>
        <set_value name="$targetzone" exact="$destination.zone"/>
        <do_if value="$targetzone.isclass.highway">
          <wait min="10s" max="30s" />
          <resume label="initialization" />
        </do_if>
      </do_else>

      <do_if value="not $targetzone.sector.exists or not this.sector.exists">
        <set_value name="$failreason" exact="'ERR_JUMPSECTORS_INVALID'"/>
        <resume label="finish" />
      </do_if>

      <create_position name="$jumpposition" space="$targetzone" object="$destination" x="$position.x" y="$position.y" z="$position.z"/>
      <do_if value="not $rotation">
        <create_orientation name="$rotation" refobject="$destination" orientation="align_right_bbox">
          <position value="$jumpposition"/>
        </create_orientation>
      </do_if>


      <!--<debug_text text="'jumping to zone ' + $targetzone.knownname + ': ' + $safepos.x + ', ' + $safepos.y + ', ' + $safepos.z + ', Rot: '+ $rot.yaw + ', ' + $rot.pitch + ', ' + $rot.roll" />-->

      <stop_moving object="this.ship"/>

      <label name="fuelcheck"/>
      <set_value name="$result" exact="0"/>
      <find_object_component name="$jumpdrive" object="this.ship" class="class.jumpdrive"/>
      <do_if value="$jumpdrive.exists">
        <do_if value="$jumpdrive.isfunctional">

          <do_if value="$ignorefuel" exact="false">
            <do_if value="$autorefuel">
              <!-- refuel if fuelcells are below certain threshold -->
              <do_if value="this.ship.cargo.{ware.fuelcells}.count lt this.ship.cargo.{ware.fuelcells}.max * 0.2f">
                <!-- If is not player owned or has the configuration autorefuel -->
                <do_if value="(this.ship.owner != faction.player) or @this.$config_autorefuel">
                  <run_script name="'move.refuel.vanilla40'" />
                </do_if>
                <do_else>
                  <!-- ship is owned by the player and in squad, show an interactive event -->
                  <do_if value="this.sector">
                    <substitute_text text="$logtext" source="{1016,14}" comment="$SHIP$ in sector $SECTOR$ has not enough fuel to jump to the destination.">
                      <replace string="'$SHIP$'" with="this.ship.name" />
                      <replace string="'$SECTOR$'" with="this.sector.name" />
                    </substitute_text>
                    <do_if value="this.ship.commander == player.primaryship">
                      <write_to_logbook category="squad" text="$logtext" />
                    </do_if>
                    <do_else>
                      <write_to_logbook category="upkeep" text="$logtext" />
                    </do_else>
                    <remove_value name="$logtext" />
                  </do_if>
                  <do_if value="this.ship.commander == player.primaryship">
                    <run_script name="'player.interaction.vanilla40'" result="$result">
                      <param name="Line" value="1090" comment="We do not have enough fuel to jump to our destination." />
                      <param name="UIText" value="{1015,26}" comment="Info: insufficient fuel" />
                      <param name="ConversationParam" value="'g_jump_fail_fuel'" />
                    </run_script>
                    <debug_text text="'jump interaction $result: ' + $result"/>
                    <do_if value="$result == 'refuel' or $result == 'autorefuel'">
                      <!-- Tell the player that is going to get the money from him-->
                      <start_conversation actor="this" conversation="Speak" type="normal" convparam="4801" comment="Unless you tell me otherwise, Sir, I'll replenish my budget from your account" />
                      <!-- If set auto refuel, set the blackboard variable-->
                      <do_if value="$result" exact="'autorefuel'">
                        <set_value name="this.$config_autorefuel" exact="1" />
                      </do_if>
                      <run_script name="'move.refuel.vanilla40'"/>
                    </do_if>
                    <do_elseif value="$result" exact="'wait'">
                      <!-- Command action in case of wait -->
                      <set_command_action commandaction="commandaction.standingby" />
                      <wait/>
                    </do_elseif>
                    <!-- In the case of result = 'norefuel' it will continue to slow jump -->
                  </do_if>
                  <!-- If is not in the squad, just check the auto-refuel configuration -->
                  <do_elseif value="@this.$config_autorefuel">
                    <run_script name="'move.refuel.vanilla40'" sinceversion="1"/>
                  </do_elseif>
                </do_else>
              </do_if>
            </do_if>
            <do_if value="this.ship.cargo.{ware.fuelcells}.count lt this.ship.jumpcostto.[$targetzone, $jumpposition]">
              <!-- not enough fuel, don't use fuel and delay the jump -->
              <debug_text text="'%1 not enough fuel, delay jump...'.[player.age]" chance="$debugchance"/>
              <set_value name="$ignorefuel" exact="true"/>
              <do_if value="$skipcharge" exact="false">
                <wait min="590s" max="610s"/>
              </do_if>
            </do_if>
            <do_else>
              <debug_text text="'%1 using %2 fuel to jump...'.[player.age, this.ship.jumpcostto.[$targetzone, $jumpposition]]" chance="$debugchance"/>
            </do_else>
          </do_if>
        </do_if>
        <do_else>
          <set_value name="$failreason" exact="'ERR_JUMPDRIVE_BROKEN'"/>
          <resume label="finish"/>
        </do_else>
      </do_if>
      <do_else>
        <set_value name="$failreason" exact="'ERR_NO_JUMPDRIVE'"/>
        <resume label="finish"/>
      </do_else>

      <label name="checkpath" />
      <set_value name="$nextstep" exact="null" />
      <do_if value="$nonstop">
        <resume label="jump" />
      </do_if>
      <get_jump_path start="this.ship.sector" end="$targetzone.sector" component="$jumppath" multiple="true" />
      <do_if value="$jumppath.count gt 1">

        <!-- DEBUG INFO BEGIN -->
        <do_if value="$debugchance gt 0">
          <debug_text text="'Jump from %1(%2) to %3(%4) using %5 steps.'.[this.zone.knownname, this.sector.knownname, $targetzone.knownname, $targetzone.sector.knownname, $jumppath.count]" />
          <do_if value="$jumppath.count gt 1">
            <do_all exact="$jumppath.count" counter="$p">
              <do_if value="$p == 1">
                <debug_text text="'  from %1'.[$jumppath.{$p}.knownname]" />
              </do_if>
              <do_elseif value="$p == $jumppath.count">
                <debug_text text="'  to %1'.[$jumppath.{$p}.knownname]" />

              </do_elseif>
              <do_else>
                <debug_text text="'  via %1'.[$jumppath.{$p}.knownname]" />
              </do_else>
            </do_all>
          </do_if>
        </do_if>
        <!-- DEBUG INFO END -->

        <set_value name="$nextstep" exact="$jumppath.{2}" />
        <do_if value="$nextstep.isclass.sector or $forcejump">
          <resume label="jump" />
        </do_if>
        <do_elseif value="$nextstep.isclass.gate">
          <resume label="jumpgate" />
        </do_elseif>
        <do_else>
          <!-- something is wrong -->
          <assert value="false" text="'Next step in jump path is neither sector nor gate, ' + $nextstep" />
        </do_else>
      </do_if>
      <do_else>
        <do_if value="$forcejump">
          <resume label="jump" />
        </do_if>
        <do_if value="this.ship.sector == $targetzone.sector">
          <debug_text text="'we are already in the right sector'" chance="$debugchance" />
        </do_if>
        <do_else>
          <set_value name="$failreason" exact="'ERR_NO_JUMPPATH_FOUND'"/>
        </do_else>
        <resume label="finish"/>
      </do_else>

      <!-- JUMP GATE -->
      <label name="jumpgate"/>
      <!-- move through the gate -->
      <debug_text text="'move to %1 in %2 leading to %3'.[$nextstep.knownname, $nextstep.zone.knownname, $nextstep.destination.knownname]" chance="$debugchance" />
      <run_script name="'move.jumpgate.vanilla40'">
        <param name="jumpgate" value="$nextstep" />
        <param name="debugchance" value="$debugchance" />
      </run_script>
      <!-- we should have gone through the gate and be in the correct cluster now -->
      <do_if value="$nextstep.destination.cluster != this.cluster">
        <debug_text text="'failed going through gate!'" chance="$debugchance" />
        <!-- TODO: try again? -->
      </do_if>
      <resume label="checkpath" />

      <!-- JUMP -->
      <label name="jump"/>
      <do_if value="not $jumpdrive.isfunctional">
        <set_value name="$failreason" exact="'ERR_JUMPDRIVE_BROKEN'"/>
        <resume label="finish"/>
      </do_if>

      <do_if value="$jumpdrive.cooldowntimeleft == 0">

        <do_if value="(not $nonstop) and $nextstep.exists">
          <!-- find a jumpbeacon in that sector and go there -->
          <set_value name="$forcesafepos" exact="false" />
          <do_if value="$nextstep == $targetzone.sector">
            <debug_text text="'(final) jump to sector %1'.[$nextstep.knownname]" chance="$debugchance" />
            <get_closest_jumpbeacon name="$beacon" sector="$targetzone.sector">
              <position value="$jumpposition" space="$targetzone" />
            </get_closest_jumpbeacon>
          </do_if>
          <do_else>
            <!-- intermediate jump, we always use safepos here! -->
            <debug_text text="'(intermediate) jump to sector %1'.[$nextstep.knownname]" chance="$debugchance" />
            <get_closest_jumpbeacon name="$beacon" sector="$nextstep" />
            <set_value name="$forcesafepos" exact="true" />
          </do_else>

          <do_if value="$beacon.exists">
            <set_value name="$beaconpos" exact="$beacon.position" />
            <set_value name="$beaconzone" exact="$beacon.zone" />
            <create_orientation name="$rotation" orientation="look_at" refposition="$jumpposition">
              <position object="$beacon" space="$beaconzone" />
            </create_orientation>
          </do_if>
          <do_else>
            <!-- TEMP FALLBACK -->
            <set_value name="$forcesafepos" exact="true" />
            <set_value name="$beaconpos" exact="position.[0,0,0]" />
            <find_zone name="$beaconzone" space="$nextstep" priorityzone="true" tempzone="false">
              <match class="class.highway" negate="true" />
            </find_zone>
            <debug_text text="'could not find jump beacon in sector %1 using fall-back position %2 in zone %3'.[$nextstep.knownname, $beaconpos, $beaconzone.knownname]" chance="$debugchance" />
          </do_else>

          <!-- finally this is where we can trigger the actual jump -->
          <do_if value="$forcesafepos or $safepos">
            <jump object="this.ship" zone="$beaconzone" result="$result" skipcharge="$skipcharge" ignorefuel="$ignorefuel">
              <safepos value="$beaconpos" radius="this.ship.size * 0.6f" allowyaxis="false"/>
              <rotation value="$rotation"/>
            </jump>
          </do_if>
          <do_else>
            <jump object="this.ship" zone="$beaconzone" result="$result" skipcharge="$skipcharge" ignorefuel="$ignorefuel">
              <position value="$beaconpos"/>
              <rotation value="$rotation"/>
            </jump>
          </do_else>
          <do_if value="not $result">
            <set_value name="$failreason" exact="'ERR_JUMP_ABORTED'" />
            <resume label="finish" />
          </do_if>
        </do_if>
        <do_else>
          <!-- in-sector / non-stop jump:
          the default jump logic will not go in here because we don't do in-sector jumps (that's what boosting is for)
          but we still want the case to be handled properly in case mission code wants specific jump behaviour -->
          <debug_text text="'performing in-sector or non-stop jump! (NOTE: this should not happen outside of plot missions!), jumppath-length: ' + @$jumppath.count" chance="$debugchance" />
          <do_if value="$safepos">
            <jump object="this.ship" zone="$targetzone" result="$result" skipcharge="$skipcharge" ignorefuel="$ignorefuel">
              <safepos value="$jumpposition" radius="this.ship.size * 0.6f" allowyaxis="false"/>
              <rotation value="$rotation"/>
            </jump>
          </do_if>
          <do_else>
            <jump object="this.ship" zone="$targetzone" result="$result" skipcharge="$skipcharge" ignorefuel="$ignorefuel">
              <position value="$jumpposition"/>
              <rotation value="$rotation"/>
            </jump>
          </do_else>
          <do_if value="not $result">
            <set_value name="$failreason" exact="'ERR_JUMP_ABORTED'" />
            <resume label="finish" />
          </do_if>
        </do_else>

      </do_if>
      <do_else>
        <!-- jumpdrive still on cooldown, wait a bit and try again-->
        <wait min="($jumpdrive.cooldowntimeleft + 2)s" max="($jumpdrive.cooldowntimeleft + 4)s"/>
        <resume label="jump"/>
      </do_else>
      <do_if value="$forcejump and @$jumppath.count == 0">
        <!-- if we forced an in-sector jump, we can exit here, otherwise this would keep jumping and jumping and jumping... -->
        <resume label="finish"/>
      </do_if>
      <resume label="checkpath" />

      <label name="finish"/>
      <do_if value="$failreason == ''">
        <return value="true"/>
      </do_if>
      <do_else>
        <debug_text text="'jump failed with reason: ' + $failreason"/>
        <wait min="1s" max="3s" sinceversion="2" />
        <return value="false"/>
      </do_else>

    </actions>
  </attention>
  <on_abort>
    <do_if value="event.name != 'event_object_destroyed'">
      <abort_jump object="this.ship" />
    </do_if>
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="utf-8" ?>
<aiscript name="move.jumpgate.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <!--

  Move Jump gate
  by Adrian
  
  Generic routine for moving through specific jumpgate.

  -->
  <params>
    <param name="jumpgate" comment="Jumpgate to use"/>
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <label name="check" />

      <do_if value="not $jumpgate.isclass.gate">
        <debug_text text="'ERROR: jumpgate does not exist!'"/>
        <return />
      </do_if>

      <label name="move" />

      <!-- If is not in the same zone use the generic routine to get there -->
      <do_if value="(this.zone != $jumpgate.zone)">
        <run_script name="'move.generic.vanilla40'" >
          <param name="destination" value="$jumpgate" />
          <param name="endintargetzone" value="true" />
        </run_script>
      </do_if>

      <!-- Request queue -->
      <request_gate ship="this.ship" gate="$jumpgate" result="$success" />

      <!-- if it's not close enough, find a close point orientated to the gate -->
      <do_if value="not $success and (this.ship.distanceto.{$jumpgate} gt 10km)">
        <run_script name="'move.generic.vanilla40'" chance="0" >
          <param name="destination" value="$jumpgate" />
          <param name="position" value="position.[0,0,-5km]" />
          <param name="lookat" value="$jumpgate.position" />
        </run_script>
        <!-- Safe position -->
        <get_safe_pos zone="$jumpgate.zone" radius="this.ship.size" result="$pos" object="$jumpgate" ignored="this.ship" directionobject="$jumpgate" direction="quadrant.back" direction2="quadrant.back" value="position.[0,0,-5km]" allowyaxis="false" />
        <!-- Move to a closer position, if it's actually closer -->
        <do_if value="$jumpgate.distanceto.[$jumpgate.zone, $pos] lt this.ship.distanceto.[$jumpgate.zone, $jumpgate.position] or true">
          <!-- Orientation to the gate -->
          <create_orientation name="$rot" orientation="look_at"  refobject="$jumpgate">
            <position value="$pos" />
          </create_orientation>
          <!-- move infront of the gate  -->
          <move_to object="this.ship" destination="$jumpgate.zone" forceposition="false" forcerotation="true" sinceversion="1">
            <position value="$pos" />
            <rotation value="$rot" />
            <interrupt_after_time time="2s" />
          </move_to>
        </do_if>
      </do_if>

      <!-- if is not clear wait a=until it is (with a max timeout) -->
      <do_while value="not $success">
        <!-- request a conexion between this ship and the gate -->
        <request_gate ship="this.ship" gate="$jumpgate" result="$success" />
        <!-- not succesful -->
        <do_if value="not $success">
          <debug_text text="'Not success on requesting gate %1'.[$jumpgate]" chance="$debugchance" />
          <do_if value="not $queuestarttime?">
            <set_value name="$queuestarttime" exact="player.age" />
            <set_value name="$maxtime" min="2min" max="10min"/>
          </do_if>
          <do_if value="(player.age - $queuestarttime) gt $maxtime">
            <debug_text text="'been waiting for more than %1 to get jumpgate clearance, aborting'.[$maxtime]" chance="$debugchance" />
            <break/>
          </do_if>
          <!-- Wait for it to be free -->
          <wait min="30s" max="2min" />
        </do_if>
      </do_while>

      <!-- we need to go through a jumpgate -->
      <debug_text text="'move through gate \'%1\' in %2(%3)'.[$jumpgate.knownname, $jumpgate.zone.knownname, $jumpgate.sector.knownname]" chance="$debugchance" />
      <get_gate_approach_pos ship="this.ship" gate="$jumpgate" position="$approachpos" rotation="$approachrot" />

      <set_value name="$moveintogate" exact="true" />

      <move_to object="this.ship" destination="$jumpgate" usehighways="not this.ship.isclass.[class.ship_xl, class.ship_l]" finishonapproach="true" forceposition="false" forcerotation="true" >
        <position value="$approachpos" />
        <rotation value="$approachrot" />
        <interrupt>
          <conditions>
            <check_any>
              <event_object_changed_cluster object="this.ship" />
              <event_object_collided object="this.ship" otherobject="$jumpgate" />
            </check_any>
          </conditions>
          <actions>
            <!-- If changes cluster  -->
            <do_if value="event.name" exact="'event_object_changed_cluster'">
              <debug_text text="'just changed from cluster %1 to cluster %2 (early out)'.[event.param2.knownname, event.param.knownname]" chance="$debugchance" />
              <set_value name="$moveintogate" exact="false" />
            </do_if>
            <!-- If touches the jumpgate, make a shortcut and use directly move_gate -->
            <do_elseif value="event.name" exact="'event_object_collided'">
              <debug_text text="'collided with jumpgate, make a shortcut'" chance="$debugchance" />
              <stop_moving object="this.ship" />
            </do_elseif>
          </actions>
        </interrupt>
      </move_to>

      <!-- Clear the conexion to the jumpgate -->
      <request_gate ship="this.ship" gate="$jumpgate" unlock="true" result="$result"/>

      <!-- If it didn't cross yet, make a move_gate -->
      <do_if value="$moveintogate">
        <move_gate object="this.ship" gate="$jumpgate" abortpath="false" >
          <interrupt>
            <conditions>
              <event_object_changed_cluster object="this.ship" />
            </conditions>
            <actions>
              <debug_text text="'just changed from cluster %1 to cluster %2 (moved through gate)'.[event.param2.knownname, event.param.knownname]" chance="$debugchance" />
              <set_value name="$moveintogate" exact="false" />
            </actions>
          </interrupt>
        </move_gate>

        <!-- Wait for the transition if needed -->
        <do_if value="$moveintogate">
          <wait>
            <interrupt>
              <conditions>
                <event_object_changed_cluster object="this.ship" />
              </conditions>
              <actions>
                <debug_text text="'changed from cluster %1 to cluster %2 (wait)'.[$jumpgate.cluster.knownname, this.cluster.knownname]" chance="$debugchance" />
              </actions>
            </interrupt>
          </wait>
        </do_if>
      </do_if>

      <!-- we should have gone through the gate and be in the correct cluster now -->
      <do_if value="$jumpgate.destination.cluster != this.cluster">
        <debug_text text="'failed going through gate!'" chance="100" filter="error" />
      </do_if>

      <!-- small wait to make sure it's in the destination cluster -->
      <wait exact="200ms"/>

      <!-- move forward to a safepos to make sure the gate exit area is clear -->
      <get_safe_pos zone="this.zone" radius="this.ship.size" result="$safepos" object="this.ship" z="this.ship.length*5.0f" direction="quadrant.front" directionobject="this.ship" />

      <debug_text text="'%1 start safepos move, dist %2'.[player.age, this.ship.distanceto.{$safepos}]" chance="$debugchance" />
      <move_to object="this.ship" destination="this.zone" usehighways="false" finishonapproach="false" abortpath="true" forceposition="false">
        <position value="$safepos"/>
        <interrupt_after_time time="1min"/>
      </move_to>

      <debug_text text="'%1 end safepos move, dist %2'.[player.age, this.ship.distanceto.{$safepos}]" chance="$debugchance" />

    </actions>
  </attention>
  <on_abort>
    <request_gate ship="this.ship" gate="$jumpgate" unlock="true" result="$result"/>
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.nearby.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="destination" />
  </params>
  <attention min="unknown">
    <actions>
      <!-- debugging -->
      <set_value name="$debugchance" exact="0" />

      <label name="start" />

      <run_script name="'move.undock.vanilla40'" />

      <!-- only move if we're outside the tolerance distance-->
      <create_position name="$pos" object="this.ship" space="$destination" />
      <create_position_outside_boundingbox name="$pos" distance="this.ship.size" component="$destination">
        <position value="$pos" />
      </create_position_outside_boundingbox>
      <do_if value="this.ship.position != $pos">
        <move_to object="this.ship" destination="$destination" finishonapproach="true" forceposition="false">
          <position value="$pos" />
        </move_to>
      </do_if>
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.nohighway.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <params>
    <param name="target" />
    <param name="position" default="position.[0,0,0]" comment="position is treated as an offset to target"/>
    <param name="debugchance" default="0" />
  </params>
  <attention min="unknown">
    <actions>

      <run_script name="'move.undock.vanilla40'" />

      <stop_moving object="this.ship" />

      <label name="start"/>

      <do_if value="not $target.exists">
        <return />
      </do_if>
      <do_elseif value="$target.isclass.zone">
        <set_value name="$targetzone" exact="$target" />
      </do_elseif>
      <do_elseif value="$target.zone.isclass.highway">
        <!--Target is in a highway, wait for it to exit-->
        <wait min="45s" max="60s" sinceversion="2">
          <interrupt>
            <conditions>
              <event_object_changed_zone object="$target"/>
            </conditions>
          </interrupt>
        </wait>
        <resume label="start"/>
      </do_elseif>
      <do_else>
        <set_value name="$targetzone" exact="$target.zone" />
      </do_else>

      <debug_text text="'this.zone = %1, $target = %2, $targetzone = %3'.[this.zone.knownname, $target.knownname, $targetzone.knownname]" chance="$debugchance" />
      <do_if value="this.zone != $targetzone">
        <debug_text text="'current position in zone: ' + this.ship.position" chance="$debugchance" />
        <!-- safety check -->
        <find_object_component class="class.enginebooster" object="this.ship" name="$booster" />
        <do_if value="not $booster.exists">
          <debug_text text="'WARNING! \'%1\' has no engine booster. Flight from %2(%3) to %4(%5) will take a looong time!'.[this.ship.macro.name, this.zone.knownname, this.sector.knownname, $targetzone.knownname, $targetzone.sector.knownname]" />
        </do_if>

        <!-- figure out position to leave this zone at -->
        <get_zone_exit_pos zone="this.zone" destination="$target" position="$pos" rotation="$rot" radius="this.ship.size/2" >
          <position object="this.ship" />
        </get_zone_exit_pos>

        <debug_text text="'moving to zone exit pos: %1, %2m away'.[$pos, this.ship.distanceto.{$pos}]" chance="$debugchance" />
        <!-- If is too close, don't move, only rotate -->
        <do_if value="this.ship.distanceto.{$pos}" max="this.ship.size" >
          <set_value name="$pos" exact="this.ship.position" />
        </do_if>

        <!--  Rotate (with very litte offset, so the nagivation system handles that)  -->
        <move_to object="this.ship" destination="this.zone" usehighways="false" forceposition="false" forcerotation="true" avoid="false" >
          <position object="this.ship" z="5m"/>
          <rotation value="$rot" />
        </move_to>

        <!-- figure out an arrival position in the target zone -->
        <get_zone_exit_pos zone="$targetzone" destination="this.ship" position="$targetpos" radius="this.ship.size" >
          <position object="$target" value="$position" />
        </get_zone_exit_pos>

        <debug_text text="'%6 boost from %1 in %2 to %3 in %4 which is %5m away'.[this.ship.position, this.zone.knownname, $targetpos, $targetzone.knownname, this.ship.distanceto.[$targetzone,$targetpos], player.age]" chance="$debugchance" />

        <!-- fire up the boosters and go to the zone arrival position -->
        <set_value name="$booststart" exact="player.age" />
        <set_value name="$boostdistance" exact="this.ship.distanceto.[$targetzone, $targetpos]" />
        <debug_text text="player.age + ' BOOOOOOOOOOOST!'" chance="$debugchance" />
        <do_if value="player.ship == this.ship">
          <speak actor="this" line="1032" comment="Confirmed. Moving out."/>
        </do_if>
        <do_while value="player.age lt ($booststart + 1h)">
          <set_value name="$interrupted" exact="false"/>
          <move_to object="this.ship" destination="$targetzone" usehighways="false" finishonapproach="false" forceposition="false" boost="true">
            <position value="$targetpos" />
            <interrupt>
              <conditions>
                <event_boost_stopped object="this.ship" />
                <check_value value="player.age" min="$booststart + 500s" comment="only after the boost duration is over" />
              </conditions>
              <actions>
                <!-- interrupt the move_to because our boost stopped -->
                <set_value name="$interrupted" exact="true"/>
                <debug_text text="'boosting move_to interrupted! started at %1, stopped at %2. Remaining distance %3m (originally %4m)'.[$booststart, player.age, this.ship.distanceto.[$targetzone, $targetpos], $boostdistance]" chance="$debugchance"/>
              </actions>
            </interrupt>
          </move_to>
          <do_if value="@$interrupted">
            <!-- wait for the recharge, then restart it -->
            <remove_value name="$interrupted"/>
            <wait min="2s" max="5s" sinceversion="3" />
          </do_if>
          <do_else>
            <break />
          </do_else>
        </do_while>
        <stop_moving object="this.ship" />
        <set_value name="$boostend" exact="player.age" />
        <debug_text text="player.age + ' STOOOOOP!'" chance="$debugchance" />

        <!-- command action calculating-->
        <set_command_action commandaction="commandaction.calculating" />

        <debug_text text="'%3 now in zone %1 at %2'.[this.zone.knownname, this.ship.position, player.age]" chance="$debugchance" />
        <do_if value="this.ship.distanceto.[$targetzone, $targetpos] gt 10km">
          <debug_text text="player.age + ' waiting to arrive in zone ' + $targetzone.knownname" chance="$debugchance" />
          <wait exact="5s">
            <interrupt>
              <conditions>
                <event_object_changed_zone object="this.ship" />
              </conditions>
              <actions>
                <debug_text text="player.age + ' %1: %2, %3'.[event.name, event.param, event.param2]" chance="$debugchance" />
              </actions>
            </interrupt>
          </wait>
          <debug_text text="player.age + ' now in zone %1 at %2'.[this.zone.knownname, this.ship.position]" chance="$debugchance" />

          <do_if value="this.zone != $targetzone">
            <debug_text text="'%4 boost was unsuccessful! planned boost distance: %1m, time spent boosting: %2s, distance to target position remaining: %3m, current zone: %5(%6), target zone: %7(%8)'.[$boostdistance, $boostend-$booststart, this.ship.distanceto.[$targetzone, $targetpos], player.age, this.zone.knownname, this.zone, $targetzone.knownname, $targetzone]" />
            <!--
            <assert value="$targetzone == this.zone" text="'Ship %1 [%2] should now be in zone %3 [%4](%8) but is in %5 [%6](%9) at %7.'.[this.ship.knownname, this.ship, $targetzone.knownname, $targetzone, this.zone.knownname, this.zone, this.ship.position, $targetzone.attention, this.attention]" />
          -->
          </do_if>
          <do_all exact="3">
            <do_if value="this.ship.distanceto.[$targetzone, $targetpos] le 10km">
              <!-- safety check so we are not stuck here forever -->
              <return value="true" />
            </do_if>
            <move_to object="this.ship" destination="$targetzone" usehighways="false" finishonapproach="false" forceposition="false" sinceversion="1">
              <position value="$targetpos" />
            </move_to>
            <wait exact="5s" sinceversion="1">
              <interrupt>
                <conditions>
                  <event_object_changed_zone object="this.ship" />
                </conditions>
                <actions>
                  <debug_text text="player.age + ' %1: %2, %3'.[event.name, event.param, event.param2]" chance="$debugchance" />
                </actions>
              </interrupt>
            </wait>
          </do_all>

          <debug_text text="'We are not on the correct position'"  filter="error"/>
          <return value="false"/>
        </do_if>
      </do_if>
      
      <return value="true"/>
    </actions>
  </attention>
  <on_abort>
    <stop_boost object="this.ship" />
  </on_abort>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.park.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3" priority="11">
  <params>
    <param name="destination" />
    <param name="tradeoffer" default="null" />
    <param name="amount" default="null" comment="amount that was reserved for this entity when doing a trade, if you pass this in, make sure you handle this.$reevaluate_parking being set!" />
  </params>
  <interrupts>
    <handler>
      <conditions>
        <event_object_signalled object="this.ship" param="'V2_00__Patch_Parking_Offsets'" />
      </conditions>
      <actions>
        <stop_moving object="this.ship" />
        <abort_called_scripts resume="start" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.dockat" param="$destination" />
    <set_command_action commandaction="commandaction.waitingtodock" />
  </init>
  <patch sinceversion="3">
    <do_if value="$tradeoffer.available">
      <set_value name="$isbuyoffer" exact="$tradeoffer.buyer.exists" />
    </do_if>
    <do_elseif value="$tradeware">
      <do_if value="@$destination.resources.list.indexof.{$tradeware} gt 0 and @$destination.products.list.indexof.{$tradeware} == 0">
        <!-- if the tradeware is a resource and NOT a product, we can be certain that it originates from a buyoffer -->
        <set_value name="$isbuyoffer" exact="true" />
      </do_if>
      <do_elseif value="@$destination.products.list.indexof.{$tradeware} gt 0 and @$destination.resources.list.indexof.{$tradeware} == 0">
        <!-- if the tradeware is a product and NOT a resource, we can be certain that it originates from a selloffer -->
        <set_value name="$isbuyoffer" exact="false" />
      </do_elseif>
    </do_elseif>
  </patch>
  <attention min="unknown">
    <actions>
      <!-- debugging -->
      <set_value name="$debugchance" exact="0" />

      <label name="start" />

      <do_if value="not $destination.isoperational">
        <debug_text text="'destination station either does not exist or is not operational!'" chance="$debugchance" />
        <return value="false" />
      </do_if>

      <do_if value="$tradeoffer.exists">
        <set_value name="$tradeware" exact="$tradeoffer.ware" />
        <set_value name="$isbuyoffer" exact="$tradeoffer.buyer.exists" />
      </do_if>

      <!-- clean up parkingqueue to avoid stale entries -->
      <do_if value="$destination.tradenpc">
        <do_if value="$destination.tradenpc.$parkingqueue?">
          <set_value name="$parkingqueue" exact="$destination.tradenpc.$parkingqueue" />
          <do_all exact="$parkingqueue.count" counter="$i" reverse="true">
            <do_if value="@$parkingqueue.{$i}.zone != this.zone">
              <remove_value name="$destination.tradenpc.$parkingqueue.{$i}"/>
            </do_if>
          </do_all>
          <remove_value name="$parkingqueue" />
        </do_if>
      </do_if>

      <set_value name="$parked" exact="this.ship.parkedat" />
      <do_if value="$parked.exists">
        <set_value name="$parkedcontainer" exact="$parked" />
        <do_if value="not $parkedcontainer.isclass.container and $parked.container.exists">
          <set_value name="$parkedcontainer" exact="$parked.container" />
        </do_if>
        <do_if value="$parkedcontainer == $destination">
          <!-- we are already here and connected -->
          <debug_text text="'ship %1(%2) already parked at %3(%4)'.[this.ship.knownname, this.ship, $parkedcontainer.knownname, $parkedcontainer]" chance="$debugchance" />
          <set_value name="$myindex" exact="@$destination.tradenpc.$parkingqueue.indexof.{this.ship}" />
          <do_if value="$myindex">
            <remove_value name="$destination.tradenpc.$parkingqueue.{$myindex}" />
          </do_if>
          <return value="true" />
        </do_if>
        <do_else>
          <run_script name="'move.unpark.vanilla40'" sinceversion="2">
            <param name="quick" value="true" />
          </run_script>
          <do_if value="this.ship.parkedat.exists">
            <debug_text text="'ship %1(%2) is still connected to %3(%4), force-disconnecting!'.[this.ship.knownname, this.ship, $parkedcontainer.knownname, $parkedcontainer]" chance="$debugchance" />
            <disconnect_from_trade_location ship="this.ship" />
          </do_if>
        </do_else>
        <remove_value name="$parkedcontainer" />
      </do_if>

      <run_script name="'move.undock.vanilla40'" />

      <set_value name="$starttime" exact="player.age" />

      <find_tradeoffer_parking_slot name="$anyslot" object="$destination" includeoccupied="true" />
      <do_if value="$anyslot">
        <find_tradeoffer_parking_slot name="$freeslot" object="$destination" trade="$tradeoffer" refobject="this.ship" />
        <do_while value="not $freeslot">
          <do_if value="not $destination.isoperational">
            <set_value name="$myindex" exact="@$destination.tradenpc.$parkingqueue.indexof.{this.ship}" />
            <do_if value="$myindex">
              <remove_value name="$destination.tradenpc.$parkingqueue.{$myindex}" />
            </do_if>
            <return value="false" />
          </do_if>

          <!-- parkingqueue handling -->
          <do_if value="$destination.tradenpc.exists">
            <do_if value="$destination.tradenpc.$parkingqueue?">
              <set_value name="$parkingqueue" exact="$destination.tradenpc.$parkingqueue" />
              <set_value name="$myindex" exact="$parkingqueue.indexof.{this.ship}" />
              <do_if value="$myindex == 1">
                <!-- we are next, try to get a slot -->
                <find_tradeoffer_parking_slot name="$freeslot" object="$destination" trade="$tradeoffer" refobject="this.ship" />
                <do_if value="$freeslot">
                  <break />
                </do_if>
              </do_if>
              <do_elseif value="$myindex gt 1">
                <!-- someone else is ahead in the queue -->
                <debug_text text="'we are at index %3 for docking at %1(%2), wait some more'.[$destination.knownname, $destination, $myindex]" chance="$debugchance" />
              </do_elseif>
              <do_else>
                <!-- add to the queue -->
                <do_if value="this.ship.trueowner == faction.player">
                  <set_value name="$myindex" exact="1" />
                  <do_all exact="$parkingqueue.count" counter="$p" reverse="true">
                    <do_if value="$parkingqueue.{$p}.trueowner == faction.player">
                      <set_value name="$myindex" exact="$p + 1" />
                      <break />
                    </do_if>
                  </do_all>
                  <debug_text text="'add to queue of %1(%2) at index %3 (PRIORITY)'.[$destination.knownname, $destination, $myindex]" chance="$debugchance" />
                  <set_value name="$destination.tradenpc.$parkingqueue.{$myindex}" operation="insert" exact="this.ship" />
                </do_if>
                <do_else>
                  <debug_text text="'add to end of queue on %1(%2)'.[$destination.knownname, $destination]" chance="$debugchance" />
                  <append_to_list name="$destination.tradenpc.$parkingqueue" exact="this.ship" />
                </do_else>
              </do_else>
              <remove_value name="$myindex" />
              <remove_value name="$parkingqueue" />
            </do_if>
            <do_else>
              <!-- create queue -->
              <debug_text text="'create queue on %1(%2)'.[$destination.knownname, $destination]" chance="$debugchance" />
              <set_value name="$destination.tradenpc.$parkingqueue" exact="[this.ship]" />
            </do_else>
          </do_if>
          <do_else>
            <!-- fallback in case there is no tradenpc, e.g. pilot removed from deployed buildership -->
            <find_tradeoffer_parking_slot name="$freeslot" object="$destination" trade="$tradeoffer" refobject="this.ship" />
            <do_if value="$freeslot">
              <break />
            </do_if>
          </do_else>

          <do_if value="@$tradeware and @$amount">
            <do_if value="@$isbuyoffer">
              <get_ware_reservation object="$destination" type="sell" ware="$tradeware" entity="this" result="$reserved" />
            </do_if>
            <do_else>
              <get_ware_reservation object="$destination" type="buy" ware="$tradeware" entity="this" result="$reserved" />
            </do_else>
            <do_if value="$reserved lt $amount">
            <debug_text text="'we no longer have a reservation for %1 %2 at %3 [%4] (reserved: %5)'.[$amount, $tradeware, $destination.knownname, $destination, $reserved]" chance="$debugchance" />
              <set_value name="this.$reevaluate_parking" exact="true" />
            </do_if>
          </do_if>
          <do_if value="this.$reevaluate_parking?">
            <debug_text text="'%1 [%2] reason for parking at %3 [%4] may be invalid'.[this.ship.knownname, this.ship, $destination.knownname, $destination]"  chance="$debugchance" />
            <set_value name="$myindex" exact="@$destination.tradenpc.$parkingqueue.indexof.{this.ship}" />
            <do_if value="$myindex">
              <remove_value name="$destination.tradenpc.$parkingqueue.{$myindex}" />
            </do_if>
            <return value="false" />
          </do_if>

          <do_if value="this.ship.distanceto.{$destination} gt ($destination.size + this.ship.size) * 2.f">
            <!-- if we are still far away from our destination, move closer while waiting to get a parking spot -->
            <get_safe_pos result="$safepos" zone="$destination.zone" radius="this.ship.size * 2.f" value="$destination.position" ignored="this.ship" directionobject="this.ship" angle="60deg" />
            <!-- <create_orientation name="$saferot" orientation="look_at" refposition="$destination.position">
            <position value="$safepos" />
          </create_orientation> -->
            <move_to destination="$destination.zone" object="this.ship" sinceversion="1">
              <position value="$safepos" />
              <!-- <rotation value="$saferot" /> -->
              <interrupt_after_time time="2min" />
              <interrupt>
                <conditions>
                  <event_object_signalled object="$destination" param="'parkingqueue_next'" />
                </conditions>
                <actions>
                  <debug_text text="'we get signal!'" chance="$debugchance" />
                </actions>
              </interrupt>
            </move_to>
          </do_if>
          <do_else>
            <wait min="1min" max="3min">
              <interrupt>
                <conditions>
                  <event_object_signalled object="$destination" param="'parkingqueue_next'" />
                </conditions>
                <actions>
                  <debug_text text="'we get signal!'" chance="$debugchance" />
                </actions>
              </interrupt>
            </wait>
          </do_else>

          <!-- timeout -->
          <do_if value="not $timelimit?">
            <set_value name="$timelimit" exact="20min" />
          </do_if>
          <do_if value="(player.age - $starttime)s gt $timelimit">
            <!-- currently we want this output to show up for everyone -->
            <debug_text text="'%1(%2) has been waiting more than %5 minutes to get a parking position at %3(%4). Current position in queue: %6'.[this.ship.knownname, this.ship, $destination.knownname, $destination, $timelimit/60, @$destination.tradenpc.$parkingqueue.indexof.{this.ship}]" />
            <do_if value="$timelimit gt 90min">
              <debug_text text="'hard abort'" />
              <break />
            </do_if>
            <set_value name="$timelimit" exact="20min" operation="add"/>
          </do_if>
        </do_while>
        <remove_value name="$timelimit" />
      </do_if>
      <do_else>
        <debug_text text="'%1(%2) will never be able to park at %3(%4) because there are no tradeoffer locations!'.[this.ship.knownname, this.ship, $destination.knownname, $destination]" />
      </do_else>

      <do_if value="not $freeslot">
        <set_value name="$myindex" exact="@$destination.tradenpc.$parkingqueue.indexof.{this.ship}" />
        <do_if value="$myindex">
          <remove_value name="$destination.tradenpc.$parkingqueue.{$myindex}" />
        </do_if>
        <return value="false" />
      </do_if>
      <connect_to_trade_location ship="this.ship" tradedock="$freeslot" result="$success" />
      <do_if value="$success">

        <!-- free up our spot in the queue -->
        <set_value name="$myindex" exact="@$destination.tradenpc.$parkingqueue.indexof.{this.ship}" />
        <do_if value="$myindex">
          <debug_text text="'remove our queue index %3 on %1(%2), parking connection established'.[$destination.knownname, $destination, $myindex]" chance="$debugchance" />
          <remove_value name="$destination.tradenpc.$parkingqueue.{$myindex}" />
        </do_if>
        <remove_value name="$myindex" />

        <!-- parking approach position -->
        <get_trade_parking_pos ship="this.ship" tradedock="$freeslot" space="$destination" approach="true" position="$approachpos" />
        <wait exact="1s" />

        <do_if value="not $freeslot.component.isoperational">
          <resume label="start" />
        </do_if>

        <!-- <set_value name="$movestart" exact="player.age" /> -->

        <!-- move to parking approach position -->
        <move_to object="this.ship" usehighways="false" destination="$destination" finishonapproach="false">
          <!-- NOTE: finishonapproach currently causes problems with position jumping for the next move_to unless there is a <wait /> -->
          <position value="$approachpos" />
          <!-- <rotation value="$approachrot" /> -->
        </move_to>
        <!-- 
        <set_value name="$moveend" exact="player.age" />
        <debug_text text="this.ship + ' time needed for parking ' + ($moveend - $movestart)" chance="$debugchance" />
		    -->

        <do_if value="not $freeslot.component.isoperational">
          <resume label="start" />
        </do_if>

        <!-- final parking position -->
        <get_trade_parking_pos ship="this.ship" tradedock="$freeslot" space="$destination" approach="false" position="$parkpos" rotation="$parkrot" quadrant="$quadrant" />

        <!-- next step: get the link-up position and go there -->
        <set_avoid_collisions object="this.ship" enabled="false" />

        <!-- Blackboard variable to check if is in the middle of parking -->
        <set_value name="this.$ship_parking" exact="true" />

        <do_if value="($quadrant == quadrant.left) or ($quadrant == quadrant.right)">
          <move_strafe object="this.ship" destination="$destination" forcerotation="true">
            <position value="$parkpos" />
            <rotation value="$parkrot" />
          </move_strafe>
        </do_if>
        <do_elseif value="$quadrant == quadrant.back">
          <move_to object="this.ship" usehighways="false" destination="$destination" forcerotation="true" reverse="true">
            <position value="$parkpos" />
            <rotation value="$parkrot" />
          </move_to>
        </do_elseif>
        <do_else>
          <move_to object="this.ship" usehighways="false" destination="$destination" forcerotation="true">
            <position value="$parkpos" />
            <rotation value="$parkrot" />
          </move_to>
        </do_else>

        <do_if value="not $freeslot.component.isoperational">
          <resume label="start" />
        </do_if>

      </do_if>
      <do_else>
        <resume label="start" />
      </do_else>

      <set_value name="$myindex" exact="@$destination.tradenpc.$parkingqueue.indexof.{this.ship}" />
      <do_if value="$myindex">
        <remove_value name="$destination.tradenpc.$parkingqueue.{$myindex}" />
      </do_if>
      <return value="true" />

    </actions>
  </attention>
  <on_abort>
    <do_if value="$destination.isoperational">
      <set_value name="$myindex" exact="@$destination.tradenpc.$parkingqueue.indexof.{this.ship}" />
      <do_if value="$myindex">
        <debug_text text="'ABORT CLEANUP! Remove our queue index %3 on %1(%2)'.[$destination.knownname, $destination, $myindex]" chance="$debugchance" />
        <remove_value name="$destination.tradenpc.$parkingqueue.{$myindex}" />
      </do_if>
    </do_if>
    <disconnect_from_trade_location ship="this.ship" />
    <!-- Safety delete Blackboard variable -->
    <remove_value name="this.$ship_parking" />
    <remove_value name="this.$reevaluate_parking" />
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.patrol.route.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <!-- 
  Patrol route that will patrol over the defined spaces (optinally with positions)  
  The route can be defined as:  
  - [zoneA, zoneB, zoneC, ....]
  - [[zoneA, posA], [zoneB, posb], [zoneC], zoneD, ....]
  
  The ship will fly to each zone, either to the defined position if there is or to a random one by default.
  And it will randomize the position wiht 'range' value. If range is zero, it will fly exactly to that position (safe pos closest)
  
  -->
  <params>
    <param name="route" comment="List of [[space, pos], [space, pos]] or [space, space] where space can be either macro or space component. The first zone in the route has to be within the current cluster." />
    <param name="range" default="5km" comment="Distance limit to each position" />
    <param name="pursuedistance" default="this.ship.maxradarrange" comment="Distance to pursue enemies. Default: max radar range" />
    <param name="engageenemies" default="true" comment="When moving, scan for and engage enemies"/>
    <param name="onlyinrange" default="true" comment="Stay in the range of 'range'" />
    <param name="allowstations" default="true" comment="Acquire stations as targets? Passed to move.seekenemies." />
    <param name="debugoutputchance" default="0" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler ref="AttackHandler.vanilla40" />
    <handler ref="ScannedHandler.vanilla40" />
  </interrupts>
  <init>
    <set_command command="command.patrol"  />
    <set_command_action commandaction="commandaction.calculating" />
  </init>
  <patch sinceversion="3">
    <do_if value="not $allowstations?">
      <set_value name="$allowstations" exact="true"/>
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>

      <run_script name="'move.undock.vanilla40'" />

      <do_if value="not $route.count">
        <debug_text text="'Error: calling move.patrol.route without route'" filter="error" />
        <return/>
      </do_if>

      <!-- To iterate over the list -->
      <set_value name="$index" exact="1"/>

      <label name="find_destination" />

      <!-- Depending on the type -->
      <do_if value="typeof $route.{$index}" exact="datatype.list">
        <!-- [[zoneA, posA],[zoneB, posB]] -->
        <set_value name="$destination" exact="$route.{$index}.{1}"/>
      </do_if>
      <do_else>
        <!-- [zoneA, zoneB] -->
        <set_value name="$destination" exact="$route.{$index}"/>
      </do_else>

      <!-- Destination could be either space or a space's macro -->
      <do_if value="typeof $destination" exact="datatype.macro">
        <find_zone macro="$destination" name="$destination" />
      </do_if>

      <!-- There is a second element -->
      <do_if value="$route.{$index}.{2}?">
        <!-- If there is a defined position -->
        <do_if value="typeof $route.{$index}.{2}" exact="datatype.position">
          <create_position name="$pos" value="$route.{$index}.{2}" max="$range" />
        </do_if>
      </do_if>

      <!-- If there is no defined position, create a random one -->
      <do_if value="not $pos?">
        <create_random_position_in_boundingbox name="$pos" component="$destination" />
        <set_value name="$y" min="-5km" max="5km"/>
        <get_safe_pos result="$pos" radius="this.ship.size * 2" value="position.[$pos.x, $y, $pos.z]" zone="$destination" />
        <remove_value name="$y" />
      </do_if>

      <debug_text text="'New destination: %1 in %2'.[$pos, $destination.knownname]" chance="$debugoutputchance" />

      <label name="patrol" />

      <do_if value="$destination.sector != this.sector">
        <run_script name="'move.generic.vanilla40'" sinceversion="2">
          <param name="destination" value="$destination"/>
          <param name="endintargetzone" value="true"/>
        </run_script>
      </do_if>

      <!-- Move and seek enemeis -->
      <run_script name="'move.seekenemies.vanilla40'">
        <param name="destination" value="$destination"/>
        <param name="pos" value="$pos"/>
        <param name="engageenemies" value="$engageenemies"/>
        <param name="onlyinrange" value="$onlyinrange" />
        <param name="pursuedistance" value="$pursuedistance" />
        <param name="allowstations" value="$allowstations" />
        <param name="debugoutputchance" value="$debugoutputchance" />
      </run_script>

      <remove_value name="$pos" />

      <wait max="1s" />

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <debug_text text="'%1 doing job %2 has expired, die!'.[this.ship.knownname, this.ship.job]" chance="$debugoutputchance" />
        <run_script name="'move.die.vanilla40'" >
          <param name="byjump" value="$capship" />
          <param name="byhostile" value="true" />
        </run_script>
      </do_if>

      <!-- got to the next item on the route -->
      <do_if value="$index lt $route.count">
        <set_value name="$index" operation="add"/>
      </do_if>
      <do_else>
        <set_value name="$index" exact="1"/>
      </do_else>

      <resume label="find_destination"/>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.patrol.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="6">
  <params>
    <param name="range" default="'sector'" comment="'zone','station','sector'"/>
    <param name="range_min" default="5km" comment="currently only supported when range=station, or patrolobject"/>
    <param name="range_max" default="this.ship.maxradarrange" comment="currently only supported when range=station, or patrolobject. Default: max radar range"/>
    <param name="patrolobject" default="null" comment="Object to patrol around (ignore range, but use range_min and range_max)" />
    <param name="engageenemies" default="true" comment="When moving, scan for and engage enemies"/>
    <param name="onlyinrange" default="true" comment="Stay in the range of 'range' or 'patrolobject' within 'range_max'" />
    <param name="allowstations" default="true" comment="Acquire stations as targets? Passed to move.seekenemies." />
    <param name="debugoutputchance" default="0" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler ref="AttackHandler.vanilla40" />
    <handler ref="ScannedHandler.vanilla40" />
  </interrupts>
  <init>
    <set_command command="command.patrol"  />
    <set_command_action commandaction="commandaction.calculating" />
  </init>
  <patch sinceversion="6">
    <do_if value="not $allowstations?">
      <set_value name="$allowstations" exact="true"/>
    </do_if>
  </patch>
  <patch sinceversion="5">
    <!-- In case there is space cluster -->
    <do_if value="$range == 'cluster'">
      <set_value name="$range" exact="'sector'"/>
      <set_value name="$targetzone" exact="null" comment="this would make a restart to get new values"/>
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>

      <run_script name="'move.undock.vanilla40'" sinceversion="3" />

      <label name="start" />
      <set_value name="$capship" exact="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" />

      <set_value name="$startzone" exact="this.ship.zone" />
      <!-- Has a job main zone? -->
      <do_if value="this.ship.jobmainzone">
        <set_value name="$startzone" exact="this.ship.jobmainzone"/>
      </do_if>
      <set_value name="$targetzone" exact="this.ship.zone" />
      <set_value name="$patrolendtime" exact="0"/>
      <set_value name="$pos" exact="this.ship.position"/>

      <break_formation object="this.ship" />

      <do_if value="$capship">
        <set_value name="$patrol_duration" exact="20min" />
      </do_if>
      <do_else>
        <set_value name="$patrol_duration" exact="10min" />
        <create_formation formation="formationshape.vshape" object="this.ship" param="this.ship.size * 1.5" />
      </do_else>

      <do_if value="$range" exact="'zone'">
        <set_value name="$space" exact="null"/>
      </do_if>
      <do_elseif value="$range" exact="'station'">
        <set_value name="$space" exact="null"/>
      </do_elseif>
      <do_elseif value="$range" exact="'sector'">
        <set_value name="$space" exact="this.ship.sector" />
      </do_elseif>
      <do_else>
        <!-- Don't send capships to around the cluster until their move functionality allows them to handle jumpdrives-->
        <do_if value="$range != 'sector'">
          <debug_text text="'Range %1 not supported'.[$range]" filter="error" />
        </do_if>
        <set_value name="$space" exact="this.ship.sector" />
      </do_else>


      <label name="find_destination" />

      <!-- Safety checking for non-existing zones -->
      <do_if value="not $targetzone.exists or not $startzone.exists" >
        <wait min="1s" max="2s" sinceversion="4" />
        <resume label="start" />
      </do_if>

      <set_value name="$fly_around_zone" exact="true"/>

      <!-- Specal case for patrol around Object "patrolobject" -->
      <do_if value="@$patrolobject.exists">
        <set_value name="$space" exact="null" />
        <do_if value="$patrolobject.isclass.space">
          <do_if value="$patrolobject.isclass.zone">
            <set_value name="$targetzone" exact="$patrolobject" />
          </do_if>
          <do_else>
            <do_if value="true" chance="50">
              <!--normal map zones-->
              <find_zone name="$targetzone" space="$patrolobject" mapzone="true" tempzone="false"/>
            </do_if>
            <do_else>
              <!--normal map zones and those with a player station-->
              <do_if value="$patrolobject.isclass.sector">
                <find_zone name="$targetzone" space="$patrolobject" mapzone="true">
                  <match_distance object="$patrolobject" max="250km"/>
                </find_zone>
              </do_if>
              <do_else>
                <find_sector name="$tempsector" space="$patrolobject"/>
                <find_zone name="$targetzone" space="$tempsector" mapzone="true">
                  <match_distance object="$tempsector" max="250km"/>
                </find_zone>
                <remove_value name="$tempsector"/>
              </do_else>
            </do_else>
          </do_else>
          <create_position name="$patrolpos" min="$range_min" max="$range_max" />
        </do_if>
        <do_else>
          <set_value name="$targetzone" exact="$patrolobject.zone" />
          <create_position name="$patrolpos" object="$patrolobject" min="$range_min" max="$range_max" />
        </do_else>

        <do_if value="$capship">
          <set_value name="$Y" min="-500m" max="500m"/>
          <get_safe_pos result="$pos" radius="this.ship.size + 1000m" value="position.[$patrolpos.x, $Y, $patrolpos.z]" zone="$targetzone" allowyaxis="false"/>
        </do_if>
        <do_else>
          <get_safe_pos result="$pos" radius="this.ship.size + 200m" value="$patrolpos" zone="$targetzone" />
        </do_else>

        <resume label="patrol" />
      </do_if>


      <!--if $space is valid, the ship will patrol other zones-->
      <do_if value="$space">
        <set_value name="$fly_around_zone" exact="false"/>
        <do_if value="this.sector" exact="@$targetzone.sector">
          <!--Use same check distance here and in 'move.seekenemies' (this.ship.size * 2) -->
          <do_if value="this.ship.distanceto.[$targetzone, $pos]" max="this.ship.size * 2">
            <!--Ship is in the target zone but patrol time needs to be set-->
            <set_value name="$fly_around_zone" exact="true"/>
            <do_if value="$patrolendtime" exact="0">
              <set_value name="$patrolendtime" exact="player.age + $patrol_duration" />
            </do_if>

            <!--Patrol time has ended, so find a zone in this space-->
            <do_elseif value="player.age" min="$patrolendtime">
              <set_value name="$fly_around_zone" exact="false"/>
              <do_if value="true" chance="50">
                <!--normal map zones-->
                <find_zone name="$targetzone" space="$space" mapzone="true" tempzone="false"/>
              </do_if>
              <do_else>
                <!--normal map zones and those with a player station-->
                <do_if value="$space.isclass.sector">
                  <find_zone name="$targetzone" space="$space" mapzone="true">
                    <match_distance object="$space" max="250km"/>
                  </find_zone>
                </do_if>
                <do_else>
                  <find_sector name="$tempsector" space="$space"/>
                  <find_zone name="$targetzone" space="$tempsector" mapzone="true">
                    <match_distance object="$tempsector" max="250km"/>
                  </find_zone>
                  <remove_value name="$tempsector"/>
                </do_else>
                <do_if value="not $targetzone">
                  <find_zone name="$targetzone" space="$space" mapzone="true" tempzone="false"/>
                </do_if>
              </do_else>
              <create_random_position_in_boundingbox name="$pos" component="$targetzone" />
              <set_value name="$Y" min="-5000m" max="5000m"/>
              <get_safe_pos result="$pos" radius="this.ship.size + 1000m" value="position.[$pos.x, $Y, $pos.z]" zone="$targetzone" />
            </do_elseif>
          </do_if>
        </do_if>
      </do_if>

      <do_if value="$fly_around_zone">
        <!--Fly around the commanding station-->
        <do_if value="$range" exact="'station'">
          <set_value name="$targetzone" exact="null" />
          <do_if value="this.ship.commander.exists">
            <do_if value="this.ship.commander.isclass.station">
              <set_value name="$targetzone" exact="this.ship.commander.zone" />
              <create_position name="$pos" object="this.ship.commander" min="$range_min" max="$range_max"/>
              <do_if value="not $capship">
                <get_safe_pos result="$pos" radius="this.ship.size + 200m" value="$pos" zone="$targetzone" />
              </do_if>
              <do_else>
                <set_value name="$Y" min="-500m" max="500m"/>
                <get_safe_pos result="$pos" radius="this.ship.size + 1000m" value="position.[$pos.x, $Y, $pos.z]" zone="$targetzone" allowyaxis="false"/>
              </do_else>
            </do_if>
          </do_if>
          <do_if value="not $targetzone">
            <debug_text text="'No commanding station to anchor the patrolling object. Reverting to zone patrol.'" chance="$debugoutputchance" />
            <set_value name="$range" exact="'zone'"/>
            <resume label="find_destination"/>
          </do_if>
        </do_if>
        <!--Fly around the startzone-->
        <do_elseif value="$range" exact="'zone'">
          <set_value name="$targetzone" exact="$startzone" />
          <find_object space="$targetzone" name="$patrolobj" surfaceelement="false">
            <match_size min="500m" />
          </find_object>

          <do_if value="(not $capship) and ($patrolobj.exists)">
            <create_position name="$patrolpos" object="$patrolobj" min="500m" max="2km" />
            <get_safe_pos result="$pos" radius="this.ship.size + 200m" value="$patrolpos" zone="$targetzone" />
            <debug_text text="'fly to ' + $pos " chance="$debugoutputchance" />
          </do_if>
          <do_else>
            <create_random_position_in_boundingbox name="$pos" component="$targetzone" />
            <set_value name="$Y" min="-5000m" max="5000m"/>
            <get_safe_pos result="$pos" radius="this.ship.size + 1000m" value="position.[$pos.x, $Y, $pos.z]" zone="$targetzone" />
          </do_else>
        </do_elseif>
        <!--Fly around the current target zone-->
        <do_else>
          <create_random_position_in_boundingbox name="$pos" component="$targetzone" />
          <set_value name="$Y" min="-5000m" max="5000m"/>
          <get_safe_pos result="$pos" radius="this.ship.size + 1000m" value="position.[$pos.x, $Y, $pos.z]" zone="$targetzone" />
        </do_else>
      </do_if>
      <label name="patrol" />

      <!-- Safety checking for non-existing zones -->
      <do_if value="not $targetzone.exists or not $startzone.exists" >
        <wait min="1s" max="2s" sinceversion="1" />
        <resume label="start" />
      </do_if>

      <run_script name="'move.seekenemies.vanilla40'">
        <param name="destination" value="$targetzone"/>
        <param name="pos" value="$pos"/>
        <param name="engageenemies" value="$engageenemies"/>
        <param name="onlyinrange" value="@$onlyinrange" />
        <param name="escort" value="$patrolobject" />
        <param name="pursuedistance" value="$range_max" />
        <param name="allowstations" value="$allowstations" />
        <param name="debugoutputchance" value="$debugoutputchance" />
      </run_script>

      <wait min="1s" max="2s" />

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <debug_text text="'%1 doing job %2 has expired, die!'.[this.ship.knownname, this.ship.job]" chance="$debugoutputchance" />
        <run_script name="'move.die.vanilla40'" sinceversion="2">
          <param name="byjump" value="$capship" />
          <param name="byhostile" value="true" />
        </run_script>
      </do_if>

      <resume label="find_destination"/>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.plunder.object.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="4">
  <!--
  
  Move attack object capital
  by Adrian
  
  Movement of a capital ship (made by pilot), trying to stay close to the enemy target (3km) and at the same Y axis.
  If is small target (xs, s, m) wait while is in rage.
  If is big target, continuosly move to him with an update time (30s or 5min for stations).
  No fire (see fight.defendcapital)
  
  Requires a target object as a parameter.
  Optional parameter for an escort an object
  Optional parameter for pursue distance:
    - if escort: from escort to target
    - if pursuetargets: from this to target
  Optional parameter for pursue targets
  -->
  <params>
    <param name="target" comment="The object to fight with" />
    <param name="pursuelimit" default="class.sector" comment="Highest class of space where the pursuit can continue. Null == no limit" />
    <param name="checkrelation" default="false" comment="Check the maybeattackedby status of the target"/>
    <param name="basket" comment="List of wares to find"/>
    <param name="debugoutputchance" default="0" />
  </params>
  <interrupts>
    <handler>
      <conditions>
        <check_any>
          <check_all>
            <event_object_changed_cluster object="$target" check="false" />
            <check_value value="$pursuelimit" exact="class.cluster" />
            <check_value value="this.ship.cluster" exact="$target.cluster" negate="true"/>
          </check_all>
          <check_all>
            <event_object_changed_sector object="$target" check="false" />
            <check_value value="$pursuelimit" exact="class.sector" />
            <check_value value="@this.ship.sector" exact="@$target.sector" negate="true"/>
          </check_all>
          <check_all>
            <event_object_changed_zone object="$target" check="false" />
            <check_value value="$pursuelimit" exact="class.zone" />
            <check_value value="this.ship.zone" exact="$target.zone" negate="true"/>
          </check_all>
        </check_any>
      </conditions>
      <actions>
        <do_if value="$debugoutputchance">
          <debug_text text="'Abort: pursuelimit %1'.[@$pursuelimit]" />
          <debug_text text="'this zone %1, his zone %2'.[this.ship.zone.knownname, $target.zone.knownname]" />
          <debug_text text="'this sector %1, his sector %2'.[this.ship.sector.knownname, $target.sector.knownname]" />
          <debug_text text="'this cluster %1, his cluster %2'.[this.ship.cluster.knownname, $target.cluster.knownname]" />
        </do_if>
        <abort_called_scripts />
      </actions>
    </handler>
  </interrupts>

  <patch sinceversion="2">
    <set_value name="$pursuelimit" exact="class.sector"/>
  </patch>
  <patch sinceversion="4">
    <set_value name="$drops" exact="[]"/>
  </patch>

  <attention min="unknown">
    <actions>

      <label name="start" />

      <run_script name="null" chance="0" />
      <wait min="250ms" max="1s" chance="0" comment="compatibility" />

      <do_if value="true" chance="$debugoutputchance">
        <set_value name="$containedwares" exact="[]"/>
        <do_all exact="$basket.count" counter="$i">
          <do_if value="$target.cargo.{$basket.{$i}}.exists">
            <append_to_list name="$containedwares" exact="$basket.{$i}"/>
          </do_if>
        </do_all>
        <debug_text text="this.ship.knownname + ': attacking '+ $target.knownname +'! It contains: ' + $containedwares" chance="$debugoutputchance" />
        <remove_value name="$containedwares"/>
      </do_if>

      <label name="fight" />

      <run_script name="'fight.attack.object.vanilla40'" >
        <param name="target" value="$target" />
        <param name="pursuetargets" value="not $pursuelimit" />
        <param name="checkrelation" value="$checkrelation" />
        <param name="allowothertargets" value="false"/>
        <param name="debugoutputchance" value="$debugoutputchance" />
      </run_script>

      <move_to destination="null" object="this.ship" chance="0" comment="compatibility" />
      <wait chance="0" comment="compatibility"/>

      <do_if value="$target.isoperational">
        <!--target got away-->
        <return/>
      </do_if>

      <label name="collect" />

      <!-- The target is destroyed or disenganged: Find crates that match the basket -->
      <find_object name="$crates" class="class.collectable" space="this.ship.sector" multiple="true">
        <match_distance object="this.ship" max="[10km, this.ship.maxradarrange].min"/>
        <match_any_wares wares="$basket" />
      </find_object>

      <debug_text text="'Crates to collect %1, basket: %2'.[$crates, $basket]" chance="$debugoutputchance"/>

      <set_value name="$drops" exact="[]"/>
      <do_all exact="$crates.count" counter="$i">
        <set_value name="$cratewares" exact="$crates.{$i}.wares.list"/>
        <debug_text text="'target dropped crate with: ' + $cratewares" chance="$debugoutputchance"/>
        <do_all exact="$cratewares.count" counter="$o">
          <do_if value="this.ship.cargo.{$cratewares.{$o}}.free">
            <do_if value="$basket.indexof.{$cratewares.{$o}}">
              <debug_text text="$cratewares.{$o} + ' added to final crates'" chance="$debugoutputchance"/>
              <append_to_list name="$drops" exact="$crates.{$i}"/>
              <break/>
            </do_if>
          </do_if>
        </do_all>
      </do_all>

      <!-- Either if it was destroyed or disengaged, there might be some drops, if not end -->
      <do_if value="$drops.count">
        <!-- If is destroyed and capship -->
        <do_if value="not $target.isoperational and $target.isclass.[class.ship_l, class.ship_xl]">
          <!--Wait for the explosions to pass-->
          <wait min="15s" max="20s"/>
        </do_if>
        <!-- Collect -->
        <sort_collectables_by_value name="$sortedlist" collectables="$drops" object="this.ship" />
        <do_if value="$sortedlist.count">
          <add_to_group groupname="$sorteddrops" list="$sortedlist"/>
          <debug_text text="'Target was destroyed. Checking for crates. Basket %1, drops %2'.[$basket, $sorteddrops]" chance="$debugoutputchance"/>
          <run_script name="'move.collect.ship.vanilla40'">
            <param name="targetgroup" value="$sorteddrops"/>
            <param name="debugoutputchance" value="$debugoutputchance"/>
          </run_script>
        </do_if>
        <do_else>
          <debug_text text="'Target was destroyed. No crates are suitable to be collected by this ship. Basket %1, drops %2'.[$basket, $drops]" chance="$debugoutputchance"/>
        </do_else>
      </do_if>
      <do_else>
        <debug_text text="'no drops!! target: %1 (%2), distance %3'.[$target.knownname, $target.isoperational, @$target.distanceto.{this.ship}]" chance="$debugoutputchance"/>
      </do_else>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.plunder.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="4">
  <params>
    <param name="range" default="'sector'" comment="'zone','station','sector'"/>
    <param name="range_min" default="5km" comment="currently only supported when range=station"/>
    <param name="range_max" default="this.ship.maxradarrange" comment="currently only supported when range=station. Default: max radar range"/>
    <param name="returntobase" default="true" comment="After filling cargobay, return wares to base? Base can be any trade station of this faction within this cluster."/>
    <param name="checkrelation" default="false" comment="Check the maybeattackedby status of potential targets. Otherwise, find any which are not of your faction"/>
    <param name="basebasket" default="this.ship.warebasket.list" comment="Base warebasket. Default to that setup in jobs"/>
    <param name="debugoutputchance" default="0" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler ref="AttackHandler.vanilla40" />
    <handler ref="ScannedHandler.vanilla40" />

    <handler>
      <conditions>
        <check_all>
          <event_gravidar_has_scanned object="this.ship" />
          <check_value value="$seektargets and not this.zone.isclass.highway and not this.ship.isboostactive" />
          <!--interesting use of maybeattackedby="$attacker". Attacker may be null or this.ship. If null, it ignores the filter. Better than having to copy the set of conditions twice-->
          <check_any>
            <!-- Search for capital freighters to attack-->
            <count_gravidar_contacts result="$capitalfreighters" object="this.ship" class="[class.ship_l,class.ship_xl]" functional="true" maybeattackedby="$attacker" min="1">
              <match_any>
                <match primarypurpose="objectpurpose.trade"/>
                <match primarypurpose="objectpurpose.mine"/>
              </match_any>
              <match owner="this.owner" negate="true"/>
              <match_any_cargo wares="$currentbasket" comment="wares which can fit, exclude fuelcells"/>
              <match_distance object="this.ship" max="$range_max"/>
            </count_gravidar_contacts>
            <!-- Then search for small freighters to attack -->
            <count_gravidar_contacts result="$smallfreighters" object="this.ship" class="[class.ship_m, class.ship_s]" functional="true" maybeattackedby="$attacker" min="1">
              <match_parent>
                <match class="class.highway" negate="true"/>
              </match_parent>
              <match_any>
                <match primarypurpose="objectpurpose.trade"/>
                <match primarypurpose="objectpurpose.mine"/>
              </match_any>
              <match owner="this.owner" negate="true"/>
              <match_any_cargo wares="$currentbasket" comment="wares which can fit, exclude fuelcells"/>
              <match_distance object="this.ship" max="$range_max"/>
            </count_gravidar_contacts>
          </check_any>
        </check_all>
      </conditions>
      <actions>
        <debug_text text="'Gametime: ' + player.age + ' Moveto interrupted by: ' + event.name" chance="$debugoutputchance"/>

        <!-- Select enemey based on the count gravidar already triggered -->
        <do_if value="$capitalfreighters?">
          <!-- Select nearest capship -->
          <!--<debug_text text="'capitalfreighters: ' + $capitalfreighters" chance="$debugoutputchance"/>-->
          <set_value name="$enemy" exact="$capitalfreighters.{1}"/>
          <set_value name="$NearestDistance" exact="this.ship.distanceto.{$enemy}"/>
          <do_all exact="$capitalfreighters.count" counter="$DistanceCounter">
            <do_if value="$DistanceCounter" min="2">
              <set_value name="$tempdist" exact="this.ship.distanceto.{$capitalfreighters.{$DistanceCounter}}" />
              <do_if value="$tempdist" max="$NearestDistance">
                <set_value name="$enemy" exact="$capitalfreighters.{$DistanceCounter}"/>
                <set_value name="$NearestDistance" exact="$tempdist"/>
              </do_if>
            </do_if>
          </do_all>
        </do_if>
        <do_elseif value="$smallfreighters?">
          <!-- Select small random enemy -->
          <set_value name="$enemy" exact="$smallfreighters.random" />
        </do_elseif>

        <debug_text text="'enemy: ' + $enemy.knownname" chance="$debugoutputchance"/>

        <!-- remove temp vars -->
        <remove_value name="$NearestDistance"/>
        <remove_value name="$DistanceCounter"/>
        <remove_value name="$tempdist"/>
        <remove_value name="$smallfreighters"/>
        <remove_value name="$capitalfreighters"/>

        <abort_called_scripts resume="plunder"/>
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_object_changed_attention object="this.ship" />
        <check_value value="(event.param ge attention.visible) and (event.param2 lt attention.visible)" />
        <check_value value="$seektargets and not this.ship.isboostactive" />
      </conditions>
      <actions>
        <debug_text text="'Gametime: ' + player.age + ' Moveto interrupted by: ' + event.name" chance="$debugoutputchance"/>
        <abort_called_scripts resume="patrol"/>
      </actions>
    </handler>
  </interrupts>
  <init>
    <!--TODO: Piracy?-->
    <set_command command="command.patrol"  />
    <set_command_action commandaction="commandaction.calculating" />
    <set_value name="$seektargets" exact="false"/>
  </init>
  <patch sinceversion="2">
    <set_value name="$basebasket" exact="this.ship.warebasket.list"/>
  </patch>
  <patch sinceversion="4">
    <!-- In case there is space cluster -->
    <do_if value="$range == 'cluster'">
      <set_value name="$range" exact="'sector'"/>
      <set_value name="$targetzone" exact="null" comment="this would make a restart to get new values"/>
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>

      <label name="start" />
      <do_if value="not (this.ship.isclass.ship_l or this.ship.isclass.ship_xl)">
        <assert value="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" exact="'move.plunder not currently supporting non-capships'"/>
        <return value="false"/>
      </do_if>
      <set_value name="$capship" exact="true" />

      <set_value name="$startzone" exact="this.ship.zone" />
      <!-- Has a job main zone? -->
      <do_if value="this.ship.jobmainzone">
        <set_value name="$startzone" exact="this.ship.jobmainzone"/>
      </do_if>
      <set_value name="$targetzone" exact="this.ship.zone" />
      <set_value name="$searchendtime" exact="0"/>
      <set_value name="$pos" exact="this.ship.position"/>

      <do_if value="$basebasket">
        <!--Fuelcells are always good-->
        <set_value name="$basket" exact="$basebasket"/>
        <do_if value="not $basket.indexof.{ware.fuelcells}">
          <append_to_list name="$basket" exact="ware.fuelcells"/>
        </do_if>
      </do_if>
      <do_else>
        <set_value name="$basket" exact="[]"/>
        <debug_text text="'No $basebasket set'" filter="error" />
      </do_else>
      <debug_text text="this.ship.knownname + ', ' + this.zone.knownname + 'Pirate basket is: ' + $basket" chance="$debugoutputchance"/>

      <do_if value="$checkrelation">
        <set_value name="$attacker" exact="this.ship"/>
      </do_if>
      <do_else>
        <set_value name="$attacker" exact="null"/>
      </do_else>

      <run_script name="'move.undock.vanilla40'" />

      <break_formation object="this.ship" />

      <do_if value="$capship">
        <set_value name="$search_duration" exact="20min" />
      </do_if>
      <do_else>
        <set_value name="$search_duration" exact="10min" />
        <create_formation formation="formationshape.vshape" object="this.ship" param="this.ship.size * 1.5" />
      </do_else>

      <do_if value="$range" exact="'zone'">
        <set_value name="$space" exact="null"/>
        <set_value name="$pursuelimit" exact="class.zone"/>
      </do_if>
      <do_elseif value="$range" exact="'station'">
        <set_value name="$space" exact="null"/>
        <set_value name="$pursuelimit" exact="class.zone"/>
      </do_elseif>
      <do_elseif value="$range" exact="'sector'">
        <set_value name="$space" exact="this.ship.sector" />
        <set_value name="$pursuelimit" exact="class.sector"/>
      </do_elseif>
      <do_else>
        <!-- Don't send capships to around the cluster until their move functionality allows them to handle jumpdrives-->
        <do_if value="$range != 'sector'">
          <debug_text text="'Range %1 not supported'.[$range]" filter="error" />
        </do_if>
        <set_value name="$space" exact="this.ship.sector" />
        <set_value name="$pursuelimit" exact="class.sector"/>
      </do_else>

      <label name="find_destination" />
      <set_value name="$fly_around_zone" exact="true"/>

      <!--if $space is valid, the ship will patrol other zones-->
      <do_if value="$space">
        <set_value name="$fly_around_zone" exact="false"/>
        <do_if value="this.sector" exact="@$targetzone.sector">
          <!--Use same check distance here and in 'move.seekenemies' (this.ship.size * 2) -->
          <do_if value="this.ship.distanceto.[$targetzone, $pos]" max="this.ship.size * 2">
            <!--Ship is in the target zone but patrol time needs to be set-->
            <set_value name="$fly_around_zone" exact="true"/>
            <do_if value="$searchendtime" exact="0">
              <set_value name="$searchendtime" exact="player.age + $search_duration" />
            </do_if>

            <!--Patrol time has ended, so find a zone in this space-->
            <do_elseif value="player.age" min="$searchendtime">
              <set_value name="$fly_around_zone" exact="false"/>
              <find_zone name="$targetzone" space="$space" priorityzone="true" tempzone="false">
                <match class="class.highway" negate="true" />
              </find_zone>
              <create_random_position_in_boundingbox name="$pos" component="$targetzone" />
              <set_value name="$Y" min="-5000m" max="5000m"/>
              <get_safe_pos result="$pos" radius="this.ship.size + 1000m" value="position.[$pos.x, $Y, $pos.z]" zone="$targetzone" />
            </do_elseif>
          </do_if>
        </do_if>
      </do_if>

      <do_if value="$fly_around_zone">
        <!--Fly around the commanding station-->
        <do_if value="$range" exact="'station'">
          <set_value name="$targetzone" exact="null" />
          <do_if value="this.ship.commander.exists">
            <do_if value="this.ship.commander.isclass.station">
              <set_value name="$targetzone" exact="this.ship.commander.zone" />
              <create_position name="$pos" object="this.ship.commander" min="$range_min" max="$range_max"/>
              <do_if value="not $capship">
                <get_safe_pos result="$pos" radius="this.ship.size + 200m" value="$pos" zone="$targetzone" />
              </do_if>
              <do_else>
                <set_value name="$Y" min="-500m" max="500m"/>
                <get_safe_pos result="$pos" radius="this.ship.size + 1000m" value="position.[$pos.x, $Y, $pos.z]" zone="$targetzone" allowyaxis="false"/>
              </do_else>
            </do_if>
          </do_if>
          <do_if value="not $targetzone">
            <debug_text text="'No commanding station to anchor the patrolling object. Reverting to zone patrol.'" chance="$debugoutputchance" />
            <set_value name="$range" exact="'zone'"/>
            <resume label="find_destination"/>
          </do_if>
        </do_if>
        <!--Fly around the startzone-->
        <do_elseif value="$range" exact="'zone'">
          <set_value name="$targetzone" exact="$startzone" />
          <find_object space="$targetzone" name="$patrolobj" surfaceelement="false">
            <match_size min="500m" />
          </find_object>

          <do_if value="(not $capship) and ($patrolobj.exists)">
            <create_position name="$patrolpos" object="$patrolobj" min="500m" max="2km" />
            <get_safe_pos result="$pos" radius="this.ship.size + 200m" value="$patrolpos" zone="$targetzone" />
            <debug_text text="'fly to ' + $pos " chance="$debugoutputchance" />
          </do_if>
          <do_else>
            <create_random_position_in_boundingbox name="$pos" component="$targetzone" />
            <set_value name="$Y" min="-5000m" max="5000m"/>
            <get_safe_pos result="$pos" radius="this.ship.size + 1000m" value="position.[$pos.x, $Y, $pos.z]" zone="$targetzone" />
          </do_else>
        </do_elseif>
        <!--Fly around the current target zone-->
        <do_else>
          <create_random_position_in_boundingbox name="$pos" component="$targetzone" />
          <set_value name="$Y" min="-5000m" max="5000m"/>
          <get_safe_pos result="$pos" radius="this.ship.size + 1000m" value="position.[$pos.x, $Y, $pos.z]" zone="$targetzone" />
        </do_else>
      </do_if>
      <label name="patrol" />

      <!-- Safety checking for non-existing zones -->
      <do_if value="not $targetzone.exists or not $startzone.exists" >
        <wait min="1s" max="2s" />
        <resume label="start" />
      </do_if>

      <set_value name="$enemy" exact="null"/>

      <label name="seektargets"/>

      <!--See which wares can currently fit inside, excluding fuelcells-->
      <set_value name="$currentbasket" exact="[]"/>
      <do_all exact="$basket.count" counter="$i">
        <do_if value="this.ship.cargo.{$basket.{$i}}.free">
          <do_if value="$basket.{$i} != ware.fuelcells">
            <append_to_list name="$currentbasket" exact="$basket.{$i}"/>
          </do_if>
        </do_if>
      </do_all>
      <set_value name="$seektargets" exact="true"/>

      <do_if value="not $enemy">
        <do_if value="this.zone == $targetzone">
          <move_to object="this.ship" destination="$targetzone" finishonapproach="true" usehighways="not $capship" forceposition="false" forcesteering="not $capship">
            <position value="$pos" />
          </move_to>
        </do_if>
        <do_else>
          <run_script name="'move.generic.vanilla40'">
            <param name="destination" value="$targetzone" />
          </run_script>
        </do_else>
      </do_if>

      <wait min="1s" max="2s" />

      <label name="plunder" />
      <do_if value="$enemy.isoperational">
        <set_value name="$seektargets" exact="false"/>

        <run_script name="'move.plunder.object.vanilla40'">
          <param name="target" value="$enemy "/>
          <param name="pursuelimit" value="$pursuelimit"/>
          <param name="checkrelation" value="$checkrelation" />
          <param name="basket" value="$basket"/>
          <param name="debugoutputchance" value="$debugoutputchance" />
        </run_script>

      </do_if>

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired or not this.ship.units.{unitcategory.transport}.count">
        <debug_text text="'%1 doing job %2 has expired or has no transport drones %3: die!'.[this.ship.knownname, this.ship.job, this.ship.units.{unitcategory.transport}.count]" chance="$debugoutputchance" />
        <run_script name="'move.die.vanilla40'">
          <param name="byjump" value="$capship" />
          <param name="byhostile" value="true" />
        </run_script>
      </do_if>

      <!--Calculate the free space in the ship, excluding fuel-->
      <set_value name="$freespace" exact="this.ship.cargo.free - this.ship.cargo.{ware.fuelcells}.free"/>
      <set_value name="$capacity" exact="this.ship.cargo.capacity - this.ship.cargo.{ware.fuelcells}.max"/>

      <!-- No capacity -->
      <do_if value="not $capacity">
        <debug_text text="'No capacity for some reason. Destroyed storage modules?'" chance="$debugoutputchance"/>
        <wait min="2min" max="3min" sinceversion="2" />
        <resume label="find_destination"/>
      </do_if>
      <!-- More than 5% of free space, so keep going -->
      <do_elseif value="(100.0f / $capacity) * $freespace" min="5">
        <do_if value="((100.0f / $capacity) * $freespace) != 100" chance="$debugoutputchance">
          <debug_text text="this.ship.knownname + ' has ' + ((100.0f / $capacity) * $freespace) + '% of cargo free, excluding fuel. Continuing to search.'"/>
        </do_if>
        <resume label="find_destination"/>
      </do_elseif>

      <label name="offload"/>
      <debug_text text="this.ship.knownname + ' has ' + ((100.0f / $capacity) * $freespace) + '% of cargo filled, excluding fuel. Looking to offload some.'" chance="$debugoutputchance"/>

      <!-- Enable dropping of wares at a station-->
      <do_if value="$returntobase">
        <!-- With commander, try to get sell to him, otherwise free trade in range -->
        <!-- 'trade.findtraderun' handles the case of commander with no offers -->
        <set_value name="$traderunscript" exact="if this.ship.commander.isoperational then 'trade.findtraderun.vanilla40' else 'trade.findfreetraderun.vanilla40'" />
        <!-- Find buy offer. Selloffer is not needed -->
        <run_script name="$traderunscript" sinceversion="3">
          <param name="warelist" value="this.ship.cargo.list" />
          <param name="range" value="$space" />
          <param name="debugchance" value="$debugoutputchance"/>
          <save_retval name="buyoffer" variable="$buyoffer" />
        </run_script>
        <!-- Execute the trade -->
        <run_script name="'trade.performtraderun.vanilla40'" sinceversion="3">
          <param name="selloffer" value="null" />
          <param name="buyoffer" value="$buyoffer" />
          <param name="debugchance" value="$debugoutputchance" />
          <save_retval name="success" variable="$success" />
        </run_script>

        <remove_value name="$buyoffer" />
        <remove_value name="$traderunscript" />

      </do_if>
      <do_else>
        <run_script name="'move.die.vanilla40'" sinceversion="2">
          <param name="byhostile" value="true" />
        </run_script>
      </do_else>

      <resume label="find_destination"/>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.random.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

  Random Movement Script
  by Apoch
  
  Generic routine for flying a ship around to random positions.

  -->
  <params>
    <param name="TimeOut" default="null" comment="duration of the random move"/>
    <!--Defaults have the ship flying around its original position-->
    <param name="Anchor" default="this.zone"/>
    <param name="Offset" default="this.ship.position"/>
    <param name="MaxDistance" default="10km"/>
  </params>
  <attention min="unknown">
    <actions>

      <run_script name="'move.undock.vanilla40'" />

      <do_if value="$TimeOut">
        <do_if value="$TimeOut" min="0">
          <!--Timeout is now the end time-->
          <set_value name="$TimeOut" exact="player.age + $TimeOut"/>
        </do_if>
        <do_else>
          <assert value="false" text="'Timeout is : ' + $Timeout + 'It should not be less than 0. Setting to null.'"/>
          <set_value name="$TimeOut" exact="null"/>
        </do_else>
      </do_if>

      <!-- Label to allow us to repeat indefinitely -->
      <!-- Note that we need to do this AFTER $originalpos is cached so that we don't drift over time -->
      <label name="start" />

      <do_while value="$Anchor.exists">

        <do_if value="$TimeOut" min="0">
          <set_value name="$RemainingTime" exact="$TimeOut - player.age"/>
        </do_if>
        <do_else>
          <set_value name="$RemainingTime" exact="-1"/>
        </do_else>

        <do_any>
          <!-- 10% chance of calling AbortPath() -->
          
          <move_to object="this.ship" destination="$Anchor" finishonapproach="true" abortpath="false" weight="90" forceposition="false" commandaction="false">
            <position value="$Offset" max="$MaxDistance" />
            <interrupt_after_time time="$RemainingTime"/>
          </move_to>

          <move_to object="this.ship" destination="$Anchor" finishonapproach="true" abortpath="true" weight="10" forceposition="false" commandaction="false">
            <position value="$Offset" max="$MaxDistance" />
            <interrupt_after_time time="$RemainingTime"/>
          </move_to>
        </do_any>

        <do_if value="$TimeOut" min="0">
          <do_if value="player.age" min="$TimeOut">
            <return />
          </do_if>
        </do_if>
        <wait min="100ms" max="500ms" />

      </do_while>

    </actions>
  </attention>
</aiscript>

<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.refuel.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3" priority="9">
  <params>
    <param name="amount" default="0" comment="if not set, the ship will fully load its storage"/>
    <param name="debugchance" default="0" />
  </params>
  <init>
    <set_command command="command.refuel" />
  </init>
  <attention min="unknown">
    <actions>
      <label name="initialization"/>
      <set_value name="$failreason" exact="'success'"/>

      <find_object_component name="$jumpdrive" object="this.ship" class="class.jumpdrive" checkoperational="false"/>
      <do_if value="not $jumpdrive.exists">
        <set_value name="$failreason" exact="'ERR_NO_JUMPDRIVE'"/>
        <resume label="finish"/>
      </do_if>
      <do_if value="this.ship.cargo.{ware.fuelcells}.max == 0 or this.ship.cargo.{ware.fuelcells}.free == 0">
        <set_value name="$failreason" exact="'ERR_FUEL_STORAGE_MISSING'"/>
        <resume label="finish"/>
      </do_if>

      <label name="findfuel"/>
      <!-- subdivide find_sell_offer to minimize performance spikes -->
      <debug_text text="'%1 trying to find selloffers for \'%2\'...'.[player.age, ware.fuelcells]" chance="$debugchance"/>
      <find_sell_offer result="$selloffers" space="this.zone" wares="ware.fuelcells" tradepartner="this.ship" multiple="true" />

      <do_if value="$selloffers.count == 0">
        <wait min="20ms" max="80ms"/>
        <find_sell_offer result="$selloffers" space="this.sector" wares="ware.fuelcells" tradepartner="this.ship" multiple="true" />
        <do_if value="$selloffers.count == 0">
          <create_list name="$clusteroffers"/>
          <find_sector name="$sectors" space="this.cluster" multiple="true"/>
          <do_all exact="$sectors.count" counter="$s">
            <do_if value="$sectors.{$s} == this.sector" negate="true">
              <wait min="20ms" max="80ms"/>
              <find_sell_offer result="$selloffers" space="$sectors.{$s}" wares="ware.fuelcells" tradepartner="this.ship" multiple="true" />
              <do_all exact="$selloffers.count" counter="$j">
                <append_to_list name="$clusteroffers" exact="$selloffers.{$j}"/>
              </do_all>
            </do_if>
          </do_all>
          <set_value name="$selloffers" exact="$clusteroffers"/>
        </do_if>
      </do_if>
      <do_if value="$selloffers.count == 0">
        <set_value name="$failreason" exact="'ERR_FIND_FUEL_FAILED'"/>
        <resume label="finish"/>
      </do_if>
      <set_value name="$tradeoffer" exact="$selloffers.random"/>
      <debug_text text="'%1 found a \'%2\' in zone \'%3\' selling %4 units of \'%5\''.[player.age, $tradeoffer.seller.knownname, $tradeoffer.seller.zone.knownname, $tradeoffer.amount, ware.fuelcells]" chance="$debugchance"/>

      <!-- the next fuel station can be reached with the engine boosters -->
      <do_if value="this.sector" exact="$tradeoffer.seller.sector">
        <do_if value="this.zone" exact="$tradeoffer.seller.zone" negate="true">
          <debug_text text="'%1 target station is in the same sector, starting to move...'.[player.age]" chance="$debugchance"/>
          <jump object="this.ship" zone="this.zone" chance="0" />
          <run_script name="'move.nohighway.vanilla40'" sinceversion="1">
            <param name="target" value="$tradeoffer.seller"/>
            <param name="debugchance" value="$debugchance" />
          </run_script>
          <wait min="300ms" max="400ms"/>
        </do_if>
      </do_if>
      <!-- the next fuel station can be reached with the jump drive only -->
      <do_else>
        <do_if value="not $jumpdrive.isoperational">
          <set_value name="$failreason" exact="'ERR_JUMPDRIVE_BROKEN'"/>
          <resume label="finish"/>
        </do_if>
        <debug_text text="'%1 target station is not in the same sector, starting to jump...'.[player.age]" chance="$debugchance"/>
        <run_script name="'move.jump.vanilla40'" result="$jumpresult">
          <param name="autorefuel" value="false"/>
          <param name="destination" value="$tradeoffer.seller"/>
        </run_script>
        <do_if value="$jumpresult" exact="false">
          <set_value name="$failreason" exact="'ERR_JUMP_FAILED'"/>
          <resume label="finish"/>
        </do_if>
      </do_else>
      <!-- dock at the fuel station, if the tradeoffer is still available -->
      <do_if value="$tradeoffer.available">
        <debug_text text="'%1 target reached, trying to dock...'.[player.age]" chance="$debugchance"/>
        <do_if value="$amount gt 0">
          <!-- Reserve that ware (default for 1 hour) -->
          <add_ware_reservation object="$tradeoffer.seller" type="buy" entity="this" ware="ware.fuelcells" amount="$amount" />
        </do_if>
        <!-- dock at that station -->
        <run_script name="'move.dockat.vanilla40'" result="$dockresult">
          <param name="destination" value="$tradeoffer.seller"/>
        </run_script>
        <do_if value="$dockresult" exact="false">
          <set_value name="$failreason" exact="'ERR_DOCKING_FAILED'"/>
          <resume label="finish"/>
        </do_if>
      </do_if>
      <do_else>
        <debug_text text="'%1 trade offer vanished, trying to find fuel again...'.[player.age]" chance="$debugchance"/>
        <resume label="findfuel"/>
      </do_else>

      <label name="executetrade"/>

      <!-- evaluate trade amount and execute trade -->
      <do_if value="$tradeoffer.available and $amount gt 0">
        <!-- Remove the reservation -->
        <remove_ware_reservation object="$tradeoffer.seller" type="buy" entity="this" ware="ware.fuelcells" amount="$amount" comment="it is possible that the tradeoffer is removed as part of a forced offer-update triggered by removing the reservation!" />
      </do_if>
      <do_if value="$tradeoffer.available">
        <!-- Checkings -->
        <do_if value="$amount gt this.ship.cargo.{ware.fuelcells}.free or $amount == 0">
          <set_value name="$amount" exact="this.ship.cargo.{ware.fuelcells}.free"/>
        </do_if>
        <do_if value="$amount gt $tradeoffer.offeramount.{this}">
          <set_value name="$amount" exact="$tradeoffer.offeramount.{this}"/>
        </do_if>
        <!-- find out who has got the money -->
        <set_value name="$accountholder" exact="this" />
        <do_if value="this.ship.commander.exists">
          <do_if value="this.ship.commander == player.primaryship">
            <set_value name="$accountholder" exact="player.entity" />
          </do_if>
          <do_elseif value="this.ship.commanderentity.exists">
            <set_value name="$accountholder" exact="this.ship.commanderentity" />
          </do_elseif>
        </do_if>
        <do_elseif value="this.ship.isplayerowned">
          <set_value name="$accountholder" exact="player.entity" />
        </do_elseif>

        <!-- check if whoever needs to pay can afford all of this -->
        <do_if value="$tradeoffer.unitprice * $amount gt $accountholder.money">
          <set_value name="$amount" exact="$accountholder.money / $tradeoffer.unitprice"/>
        </do_if>
        <do_if value="$amount le 0">
          <set_value name="$failreason" exact="'ERR_MONEY'"/>
          <resume label="finish"/>
        </do_if>
        <debug_text text="'%1 trying to buy %2 units of \'%3\'...'.[player.age, $amount, ware.fuelcells]" chance="$debugchance"/>

        <do_if value="$accountholder == player.entity">
          <!-- send notification that money is being used for re-fueling -->
          <set_value name="$moneytext" exact="($tradeoffer.unitprice * $amount).formatted.default" />
          <show_notification caption="{1015,34}" comment="Transferring funds for refueling" sound="notification_generic"
                             details="[
                                        [ null, this.ship.name, this.sector.name ],
                                        [ ware.fuelcells.icon, ware.fuelcells.name, {1001,1202} + {1001,120}, null, null, $amount ],
                                        [ null, {1001,2000}, {1001,1202} + {1001,120}, null, null, $moneytext + ' ' + {1001,101} ]
                                      ]" />
          <substitute_text text="$logtext" source="{1016,15}" comment="Transferred $MONEY$ Cr to $ENTITY$ to buy $AMOUNT$ Fuel Cells.\nLocation: $SHIP$ in sector $SECTOR$">
            <replace string="'$MONEY$'" with="$moneytext" />
            <replace string="'$ENTITY$'" with="this.name" />
            <replace string="'$AMOUNT$'" with="$amount" />
            <replace string="'$SHIP$'" with="this.ship.name" />
            <replace string="'$SECTOR$'" with="this.sector.name" />
          </substitute_text>
          <write_to_logbook category="upkeep" text="$logtext" />
          <remove_value name="$logtext" />
          <remove_value name="$moneytext" />
        </do_if>

        <execute_trade tradeoffer="$tradeoffer" tradepartner="this.ship" amount="$amount" result="$traderesult" chance="0"/>
        <execute_custom_trade buyer="this.ship" seller="$tradeoffer.seller" ware="$tradeoffer.ware" amount="$amount" price="$tradeoffer.unitprice" usecommandermoney="true" result="$traderesult" sinceversion="3"/>
        <do_if value="$traderesult" negate="true">
          <set_value name="$failreason" exact="'ERR_EXECUTE_TRADE_FAILED'"/>
          <detach_from_masstraffic object="this.ship" wait="true" />
          <resume label="finish"/>
        </do_if>
        <detach_from_masstraffic object="this.ship" wait="true" />
      </do_if>
      <do_else>
        <!-- the station might still have enough fuel, try finding another sell offer -->
        <find_sell_offer result="$tradeoffer" space="this.zone" wares="ware.fuelcells" tradepartner="this.ship" seller="this.ship.container"/>
        <do_if value="$tradeoffer.available">
          <debug_text text="'%1 trade offer vanished, trying to find updated sell offer...'.[player.age]" chance="$debugchance"/>
          <resume label="executetrade"/>
        </do_if>
        <do_else>
          <debug_text text="'%1 trade offer vanished, undocking from target station...'.[player.age]" chance="$debugchance"/>
          <run_script name="'move.undock.vanilla40'"/>
          <resume label="findfuel"/>
        </do_else>
      </do_else>

      <!-- finish -->
      <label name="finish"/>

      <!-- undock -->
      <debug_text text="'%1 undocking from target station...'.[player.age]" chance="$debugchance"/>
      <run_script name="'move.undock.vanilla40'"/>
      <debug_text text="'%1 refueling finished!'.[player.age]" chance="$debugchance"/>

      <do_if value="$failreason != 'success'">
        <debug_text text="'refuel failed with reason: ' + $failreason" chance="$debugchance"/>
      </do_if>

      <!-- In fuel stations, is better move to a final safe position -->
      <get_safe_pos zone="this.ship.zone" radius="this.ship.size" result="$safepos" object="this.ship" ignored="this.ship" allowyaxis="false" />

      <move_to object="this.ship" destination="this.zone" finishonapproach="true" usehighways="false" forceposition="false" sinceversion="2" >
        <position value="$safepos" />
        <interrupt_after_time time="2min" />
      </move_to>

      <return value="$failreason"/>

    </actions>
  </attention>
  <on_abort>
    <do_if value="@$tradeoffer.seller.exists">
      <remove_ware_reservation object="$tradeoffer.seller" type="buy" entity="this" ware="ware.fuelcells" />
    </do_if>
  </on_abort>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.seekenemies.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <params>
    <param name="destination"/>
    <param name="pos"/>
    <param name="engageenemies" default="true" comment="When moving, scan for and engage enemies"/>
    <param name="idle" default="false" comment="When finished, idle around the area still seeking enemies"/>
    <param name="idledistance" default="this.ship.size + 5km" comment="distance from $pos to idle around"/>
    <param name="onlyinrange" default="true" />
    <param name="escort" default="null" comment="Objects to escort - stay at 'pursuedistance' and shoot enemies attacking this" />
    <param name="pursuedistance" default="this.ship.maxradarrange" comment="Distance to pursue/escort (if pursuetargets true or 'escort' provided). Default: max radar range" />
    <param name="allowstations" default="true" comment="Acquire stations as targets? Passed to move.seekenemies." />
    <param name="debugoutputchance" default="0" />
  </params>
  <interrupts>
    <handler ref="AttackHandler.vanilla40" />
    <handler ref="ScannedHandler.vanilla40" />
  </interrupts>
  <patch sinceversion="3">
    <do_if value="not $allowstations?">
      <set_value name="$allowstations" exact="true"/>
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>

      <!-- If is Capital ship or has a very long range (acts as capital ship) -->
      <set_value name="$capship" exact="this.ship.isclass.ship_l or this.ship.isclass.ship_xl or this.ship.maxcombatrange.all gt 5000km" />
      <set_value name="$enemy" exact="null" />

      <run_script name="'move.undock.vanilla40'" sinceversion="2" />

      <create_position name="$targetpos" value="$pos"/>

      <label name="start" />

      <do_if value="not $destination.exists">
        <!-- early out in case destination is a tempzone and got cleaned up -->
        <debug_text text="'No destination'" chance="$debugoutputchance"/>
        <return/>
      </do_if>

      <do_if value="not $idle">
        <do_if value="this.ship.distanceto.[$destination, $pos]" max="this.ship.size * 2" comment="use the same distance in 'move.patrol'">
          <debug_text text="'Not idle'" chance="$debugoutputchance"/>
          <return/>
        </do_if>
      </do_if>

      <!-- move to a random (safe) position, looking for enemies along the way -->
      <label name="moveto" />
      <debug_text text="'Gametime: ' + player.age + ' Starting moveto to ' + $destination.knownname + ' Position: ' + $pos" chance="$debugoutputchance" />

      <!-- Script Compatibility -->
      <move_to object="this.ship" destination="this.zone" chance="0" />
      <move_to object="this.ship" destination="this.zone" chance="0" />
      <move_to object="this.ship" destination="this.zone" chance="0" />
      
      <move_to object="this.ship" destination="$destination" finishonapproach="true" usehighways="not $capship" forceposition="false" forcesteering="not $capship">
        <position value="$targetpos" />
        <interrupt>
          <conditions>
            <check_any>
              <!-- Found enemy in gravidar (if $engageenemies true) -->
              <check_all>
                <event_gravidar_has_scanned object="this.ship" />
                <check_value value="$engageenemies" />
                <check_value value="not this.zone.isclass.highway" />
                <check_any>
                  <!-- If capital ship -->
                  <check_all>
                    <check_value value="$capship" />
                    <check_any>
                      <!-- First search for capitals -->
                      <count_gravidar_contacts result="$capitalenemies" object="this.ship" class="[class.ship_l,class.ship_xl]" functional="true" maybeattackedby="this.ship" min="1">
                        <match_distance object="this.ship" max="@$pursuedistance"/>
                      </count_gravidar_contacts>
                      <!-- Second search for Stations -->
                      <check_all>
                        <check_value value="$allowstations"/>
                        <count_gravidar_contacts result="$stationenemies" object="this.ship" class="class.station" functional="true" maybeattackedby="this.ship" min="1">
                          <match_distance object="this.ship" max="@$pursuedistance"/>
                        </count_gravidar_contacts>
                      </check_all>
                      <!-- Third search for rest (small, ..) -->
                      <count_gravidar_contacts result="$smallenemies" object="this.ship" class="[class.ship_m, class.ship_s]" functional="true" maybeattackedby="this.ship" min="1">
                        <match_parent>
                          <match class="class.highway" negate="true"/>
                        </match_parent>
                        <match_distance object="this.ship" max="@$pursuedistance"/>
                      </count_gravidar_contacts>
                    </check_any>
                  </check_all>
                  <!-- If NOT capital ship -->
                  <check_all>
                    <check_value value="not $capship" />
                    <check_any>
                      <!-- First search for small/medium -->
                      <count_gravidar_contacts result="$smallenemies" object="this.ship" class="[class.ship_m, class.ship_s]" functional="true" maybeattackedby="this.ship" min="1">
                        <match_parent>
                          <match class="class.highway" negate="true"/>
                        </match_parent>
                        <match_distance object="this.ship" max="@$pursuedistance"/>
                      </count_gravidar_contacts>
                      <!-- Second search for capitals -->
                      <count_gravidar_contacts result="$capitalenemies" object="this.ship" class="[class.ship_l,class.ship_xl]"  functional="true" maybeattackedby="this.ship" min="1">
                        <match_distance object="this.ship" max="@$pursuedistance"/>
                      </count_gravidar_contacts>
                      <!-- Rest of enemies -->
                      <count_gravidar_contacts result="$restenemies" object="this.ship" functional="true" maybeattackedby="this.ship" min="1">
                        <match class="if $allowstations then [class.station, class.ship] else class.ship"/>
                        <match_distance object="this.ship" max="@$pursuedistance"/>
                      </count_gravidar_contacts>
                    </check_any>
                  </check_all>
                </check_any>
              </check_all>
              <!-- Enemy reported by police -->
              <check_all>
                <event_object_signalled object="this.sector" param="'police'" check="false" comment="allow sector to be null if action is started/restarted in superhighway" />
                <check_value value="this.sector.exists" />
                <check_value value="$engageenemies" />
                <check_value value="event.param2.isoperational" />
                <check_value value="event.param2.zone.policefaction"/>
                <check_value value="not this.hasrelation.enemy.{event.param2.zone.policefaction}" comment="Check that the police faction is not an enemy"/>
                <check_value value="event.param2.distanceto.{this.ship}" max="this.ship.maxradarrange" />
                <check_value value="event.param2.owner != this.owner" />
              </check_all>
              <!-- On attention level change -->
              <check_all>
                <event_object_changed_attention object="this.ship" />
                <check_value value="(event.param ge attention.visible) and (event.param2 lt attention.visible)" />
              </check_all>
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'Gametime: ' + player.age + ' Moveto interrupted by: ' + event.name" chance="$debugoutputchance"/>
            <do_if value="event.name" exact="'event_gravidar_has_scanned'">
              <!-- Select enemey based on the count gravidar already triggered -->
              <do_if value="$smallenemies?">
                <!-- Select small random enemy -->
                <set_value name="$enemy" exact="$smallenemies.random" />
              </do_if>
              <do_elseif value="$capitalenemies?">
                <!-- Select nearest capship -->
                <debug_text text="'capitalenemies: ' + $capitalenemies" chance="$debugoutputchance"/>
                <set_value name="$enemy" exact="$capitalenemies.{1}"/>
                <set_value name="$NearestDistance" exact="this.ship.distanceto.{$enemy}"/>
                <do_all exact="$capitalenemies.count" counter="$DistanceCounter">
                  <do_if value="$DistanceCounter" min="2">
                    <set_value name="$tempdist" exact="this.ship.distanceto.{$capitalenemies.{$DistanceCounter}}" />
                    <do_if value="$tempdist" max="$NearestDistance">
                      <set_value name="$enemy" exact="$capitalenemies.{$DistanceCounter}"/>
                      <set_value name="$NearestDistance" exact="$tempdist"/>
                    </do_if>
                  </do_if>
                </do_all>
              </do_elseif>
              <do_elseif value="$stationenemies?">
                <!-- random station -->
                <set_value name="$enemy" exact="$stationenemies.random"/>
              </do_elseif>
              <do_elseif value="$restenemies?">
                <!-- random enemy (could be everything) -->
                <set_value name="$enemy" exact="$restenemies.random"/>
              </do_elseif>

              <debug_text text="'enemy: ' + $enemy.knownname" chance="$debugoutputchance"/>

              <!-- remove temp vars -->
              <remove_value name="$NearestDistance"/>
              <remove_value name="$DistanceCounter"/>
              <remove_value name="$tempdist"/>
              <remove_value name="$smallenemies"/>
              <remove_value name="$capitalenemies"/>
              <remove_value name="$stationenemies"/>
              <remove_value name="$restenemies"/>
            
            </do_if>
            <do_elseif value="event.name" exact="'event_object_signalled'">
              <set_value name="$enemy" exact="event.param2" />
              <add_relation_boost object="this" otherobject="$enemy" value="-0.1" decay="1" delay="10min" />
              <debug_text text="'reported by police. Enemy: ' + $enemy.knownname" chance="$debugoutputchance" />
            </do_elseif>
            <do_elseif value="event.name" exact="'event_object_changed_attention'">
              <resume label="start" />
            </do_elseif>
          </actions>
        </interrupt>
      </move_to>      
      
      <label name="attack" />
      <do_if value="$enemy.isoperational">

        <add_to_group groupname="$followers" list="this.ship.subordinates" />
        <signal_objects group="$followers" param="'attack'" param2="$enemy" />
        <run_script name="'fight.attack.object.vanilla40'">
          <param name="target" value="$enemy "/>
          <param name="escort" value="@$escort" />
          <param name="pursuedistance" value="@$pursuedistance" />
          <param name="pursuetargets" value="not @$onlyinrange" />
          <param name="debugoutputchance" value="$debugoutputchance" />
        </run_script>

      </do_if>
      <do_elseif value="$engageenemies">
        <debug_text text="'No enemy found, moving to a new position'" chance="$debugoutputchance" />
      </do_elseif>

      <do_if value="$idle">
        <create_position name="$targetpos" value="$pos" max="$idledistance"/>
        <resume label="moveto"/>
      </do_if>

      <!-- Script Compatibility -->
      <wait chance="0"/>
      <move_to object="this.ship" destination="this.zone" chance="0" />
      <wait chance="0"/>
      <run_script name="''" chance="0" />
      
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.tradeoffer.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <!--

  Make ship move to trade location
  by Michael
  
  Generic routine for flying a ship to an appropriate dock for trading.

  -->
  <params>
    <param name="tradeoffer" />
  </params>
  <attention min="visible">
    <actions>
      <do_if value="not $tradeoffer">
        <debug_text text="'TradeOffer is not valid, aborting script!'" />
        <return />
      </do_if>


      <debug_text text="'Start move.dockat script'" />
      <run_script name="'move.dockat.vanilla40'" >
        <param name="destination" value="$tradeoffer.owner" />
      </run_script>

      <execute_trade tradeoffer="$tradeoffer" tradepartner="this.ship" />
      <detach_from_masstraffic object="this.ship" wait="true" />

    </actions>
  </attention>
</aiscript>

<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.ufo.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" >
  <params>
    <param name="debugchance" default="0" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler>
      <conditions>
        <check_any>
          <event_object_changed_attention check="false" object="this.ship" attention="attention.nearby"/>
          <event_object_attacked object="this.ship" />
        </check_any>
      </conditions>
      <actions>
        <debug_text text="'new attention %1, flee'.[event.param]" chance="$debugchance" />
        <abort_called_scripts resume="flee" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_object_radar_visible object="this.ship" visible="true" chance="100" />
    <set_object_min_shield object="this.ship" min="100"/>
    <set_object_min_hull object="this.ship" min="100"/>
    <debug_text text="'start! in %1, %2, %3'.[this.zone.knownname, this.sector.knownname, this.cluster.knownname]" chance="$debugchance" />
  </init>
  <attention min="unknown">
    <actions>

      <label name="start" />

      <do_if value="this.ship.jobexpired">
        <debug_text text="'job expired %1'.[player.age]" chance="$debugchance" />
        <resume label="finish" />
      </do_if>

      <create_random_position_in_boundingbox name="$random" component="this.zone" />

      <get_safe_pos result="$pos" radius="10km" value="$random" zone="this.zone" includefiringrange="true" />

      <move_to object="this.ship" destination="this.zone" finishonapproach="true" forceposition="false" usehighways="false">
        <position value="$pos" />
      </move_to>

      <debug_text text="'after start move'" chance="$debugchance" />
      <wait exact="200ms"/>

      <resume label="start"/>


      <label name="flee" />

      <!-- set them in spline if is on visile attention level -->
      <do_if value="this.attention ge attention.visible">
        <set_flight_control_model object="this.ship" flightcontrolmodel="flightcontrolmodel.spline" />
      </do_if>

      <move_to object="this.ship" destination="this.zone" forcesteering="false" finishonapproach="true" forceposition="false" boost="true" usehighways="false">
        <position object="this.ship" z="100km" />
      </move_to>

      <debug_text text="'after flee move, vissible attention %1 (distance %2)'.[this.attention, this.ship.distanceto.{player.ship}]" chance="$debugchance" />

      <!-- Go and end if really far away -->
      <do_if value="this.ship.distanceto.{player.ship}" min="100km">
        <resume label="finish" />
      </do_if>

      <wait exact="500ms"/>

      <resume label="flee"/>


      <label name="finish"/>

      <debug_text text="'after finish'" chance="$debugchance"/>
      <wait exact="200ms"/>

      <!-- check if this is a jobship at the end of its lifetime -->
      <destroy_object object="this.ship" />
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1"?>
<!--

this script handles undocking from the current dock
Initial Author: Owen

Important: 
  Undock script will redirect to 'move.unpark' if necessary
  Do NOT use 'move.unpark' directly, instead use 'move.undock'

-->
<aiscript xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="move.undock.vanilla40" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <params>
    <param name="debugchance" default="0"/>
  </params>
  <init>
    <set_command_action commandaction="commandaction.undocking"/>
  </init>
  <attention min="unknown">
    <actions>
      <!-- debugging -->

      <label name="start"/>

      <wait min="100ms" max="500ms" sinceversion="3" chance="0"/>

      <do_if value="this.ship.parkedat">
        <!-- redirect to unparking script -->
        <do_if value="this.ship.docklink">
          <disconnect_from_trade_location ship="this.ship"/>
        </do_if>
        <do_else>
          <run_script name="'move.unpark.vanilla40'"/>
          <return/>
        </do_else>
      </do_if>
      <debug_text text="'undock start ' + this.ship.knownname + ' in ' + this.zone.knownname" chance="$debugchance"/>

      <!-- check if we are currently docked -->
      <do_if value="this.ship.dockslot != null">

        <debug_text text="this.ship.knownname + ' is docked, so undock'" chance="$debugchance"/>

        <!--TODO: Handle if the dock-->

        <set_value name="$olddockslot" exact="this.ship.dockslot"/>

        <!-- ok, everything checks out, now start the undocking procedure -->
        <request_undocking ship="this.ship" queued="1" result="$success"/>
        <do_while value="$success" exact="0">
          <wait min="2s" max="10s"/>
          <request_undocking ship="this.ship" queued="1" result="$success"/>
        </do_while>

        <debug_text text="'undock request passed'" chance="$debugchance"/>

        <!-- ok, got a clear departure path -->
        <request_undocking ship="this.ship" result="$success"/>
        <do_while value="$success" exact="0">
          <wait min="2s" max="10s"/>
          <request_undocking ship="this.ship" result="$success"/>
        </do_while>
        <disable_collisions_between object="this.ship" target="$olddockslot.component.container"/>

        <do_if value="this.ship.isclass.ship_l or this.ship.isclass.ship_xl">
          <detach_from_masstraffic object="this.ship" wait="true" sinceversion="1">
            <interrupt_after_time time="3min"/>
          </detach_from_masstraffic>
        </do_if>
        <do_else>
          <do_if value="not $olddockslot.component.external">
            <!-- wait for the doors to open! -->
            <wait exact="4s"/>
          </do_if>
        </do_else>

        <debug_text text="'now move to departurepos' + this.ship.knownname + ' in ' + this.zone.knownname" chance="$debugchance"/>
        <set_command_action commandaction="commandaction.undocking"/>
        <move_undocking object="this.ship" dock="$olddockslot" finishonapproach="true" forceposition="false" commandaction="false"/>

        <debug_text text="'undock! closing doors...'" chance="$debugchance"/>
        <undock ship="this.ship"/>
        <do_if value="not $olddockslot.component.external">
          <close_dockingbay_doors dock="$olddockslot"/>
        </do_if>
        <clear_collision_filter object="this.ship"/>

        <!-- Final movement to a safe pos, clearing the undock pos -->
        <get_safe_pos result="$safepos" zone="this.zone" object="this.ship" radius="this.ship.size" direction="quadrant.front" allowyaxis="false" comment="don't use ignore 'this.ship', to force a final move to a safe position"/>
        <move_to object="this.ship" destination="this.zone" commandaction="false" finishonapproach="true" sinceversion="2">
          <position value="$safepos"/>
        </move_to>

      </do_if>
      <do_elseif value="this.ship.docklink">
        <!--Ship may have been interrupted from docking and so has a docking connection but is not docked-->
        <undock ship="this.ship"/>
      </do_elseif>

    </actions>
  </attention>
  <on_abort>
    <do_if value="this.ship.docklink">
      <undock ship="this.ship"/>
    </do_if>
    <clear_collision_filter object="this.ship"/>
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.unpark.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <!--
  
  Make a ship leave its parking position and disconnect from the tradeoffer location.  
  
  Important: 
    Undock script will redirect to 'move.unpark' if necessary
    Do NOT use 'move.unpark' directly, instead use 'move.undock'
  
  -->
  <params>
    <param name="quick" default="false" />
  </params>
  <init>
    <set_command_action commandaction="commandaction.undocking" />
  </init>
  <attention min="unknown">
    <actions>
      <!-- debugging -->
      <set_value name="$debugchance" exact="0" />

      <label name="start" />

      <wait min="100ms" max="500ms" sinceversion="1" chance="0"/>

      <do_if value="this.ship.dockslot != null or this.ship.docklink">
        <run_script name="'move.undock.vanilla40'" chance="0" comment="do not redirect to undock again" />
        <assert value="this.ship.dockslot != null or this.ship.docklink" text="'Do not use move.unpark script directly. Instead use move.undock'" />
        <debug_text text="'Error: Do not use move.unpark script directly. Instead use move.undock'" />
      </do_if>
      <do_else>
        <set_value name="$parked" exact="this.ship.parkedat" />
        <do_if value="$parked.exists">
          <!-- HACK: this should find the nearest slot which *should* be the one that we are parked at -->
          <do_if value="$parked.isclass.container">
            <set_value name="$undockfrom" exact="$parked" />
          </do_if>
          <do_else>
            <set_value name="$undockfrom" exact="$parked.container" />
          </do_else>
          <find_tradeoffer_parking_slot name="$freeslot" object="$undockfrom" refobject="this.ship" includeoccupied="true" />
          <do_if value="$freeslot">
            <set_avoid_collisions object="this.ship" enabled="false" />
            <get_trade_parking_pos ship="this.ship" tradedock="$freeslot" space="$undockfrom" approach="true" position="$approachpos" quadrant="$quadrant" />
            <wait min="1s" max="3s" />
            <do_if value="($quadrant == quadrant.left) or ($quadrant == quadrant.right)">
              <move_strafe object="this.ship" destination="$undockfrom" commandaction="false">
                <position value="$approachpos" />
                <!-- <rotation value="$approachrot" /> -->
              </move_strafe>
              <set_value name="$unparkquadrants" exact="[$quadrant.inverse, quadrant.front]"/>
            </do_if>
            <do_elseif value="$quadrant == quadrant.front">
              <move_to object="this.ship" destination="$undockfrom" reverse="true" commandaction="false">
                <position value="$approachpos" />
                <!-- <rotation value="$approachrot" /> -->
              </move_to>
              <set_value name="$unparkquadrants" exact="[quadrant.back, quadrant.none]"/>
            </do_elseif>
            <do_else>
              <move_to object="this.ship" destination="$undockfrom" commandaction="false">
                <position value="$approachpos" />
                <!-- <rotation value="$approachrot" /> -->
              </move_to>
              <set_value name="$unparkquadrants" exact="[$quadrant.inverse, quadrant.none]"/>
            </do_else>
            <set_avoid_collisions object="this.ship" enabled="true" />
          </do_if>

          <!-- Blackboard variable to check if is in the middle of parking -->
          <remove_value name="this.$ship_parking" />

          <do_if value="@$quick">
            <disconnect_from_trade_location ship="this.ship" />
            <return />
          </do_if>

          <!-- just in case, move to a safepos -->
          <do_if value="$parked.exists">
            <do_if value="$undockfrom.exists">
              <set_value name="$directionangle" min="25deg" max="45deg"/>
              <!--Don't ignore this ship. Use it to avoid finding a safepos in the parking position.-->
              <get_safe_pos object="this.ship" radius="this.ship.size * 1.5" zone="this.zone" directionobject="this.ship" direction="$unparkquadrants.{1}" direction2="$unparkquadrants.{2}" angle="$directionangle" result="$safepos"/>
              <move_to destination="this.zone" object="this.ship" usehighways="false" forceposition="false" commandaction="false">
                <position value="$safepos"/>
                <interrupt_after_time time="1min" />
              </move_to>
            </do_if>
          </do_if>

          <disconnect_from_trade_location ship="this.ship" />

          <!-- let others know that we have successfully unparked and the next one in the queue may proceed -->
          <debug_text text="'send signal to %1(%2)'.[$undockfrom.knownname, $undockfrom]" chance="$debugchance" />
          <signal_objects object="$undockfrom" param="'parkingqueue_next'" />

          <!-- experimental code - in case the move_to action was interrupted before reaching the safepos, we wait for that to finish before returning -->
          <do_if value="$safepos?">
            <!-- check if the current position is safe enough to end the script -->
            <set_value name="$testsafepos" exact="$safepos" />
            <do_while value="(not $arrivedatend?) and (this.ship.distanceto.{$testsafepos} gt this.ship.size)">
              <wait min="30s" max="1min">
                <interrupt>
                  <conditions>
                    <check_any>
                      <event_object_arrived_at_waypoint object="this.ship" lastwaypoint="true" />
                      <event_object_approaching_waypoint object="this.ship" lastwaypoint="true" />
                    </check_any>
                  </conditions>
                  <actions>
                    <set_value name="$arrivedatend" exact="true" />
                    <break />
                  </actions>
                </interrupt>
              </wait>
              <get_safe_pos object="this.ship" radius="this.ship.size" ignored="this.ship" zone="this.zone" allowyaxis="false" result="$testsafepos"/>
            </do_while>
            <do_if value="not $arrivedatend?">
              <debug_text text="'The ship did not reach its original unpark safepos but it is now in a safe position. ' + this.ship.distanceto.{$safepos} + 'm away from orginal safepos. Station was : ' + $undockfrom.knownname" chance="$debugchance"/>
            </do_if>
            <remove_value name="$arrivedatend" />
            <remove_value name="$testsafepos" />
            <remove_value name="$safepos" />
          </do_if>
        </do_if>
        <!-- not parked, do nothing? -->
      </do_else>

      <!-- Safety delete Blackboard variable -->
      <remove_value name="this.$ship_parking" />
    </actions>
  </attention>
  <on_abort>
    <disconnect_from_trade_location ship="this.ship" />
    <!-- Safety delete Blackboard variable -->
    <remove_value name="this.$ship_parking" />
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="move.wareexchange.vanilla40" priority="80" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <!--  Interrupt handler to make sure the ship doesn't move while a ware exchange is in progress
        Author: Michael
  -->
  <params>
    <param name="tradeorder" />
    <param name="target" default="null" />
    <param name="debugchance" default="0" />
  </params>
  <interrupts>
    <handler>
      <conditions>
        <event_object_shoppinglist_trade_removed object="this.ship" />
      </conditions>
      <actions>
        <debug_text text="'event_object_shoppinglist_trade_removed: tradeorder: %1, exists %2'.[$tradeorder, $tradeorder.exists]" chance="$debugchance" />
        <do_if value="not $tradeorder.exists" comment="do not set this condition on the event conditions, because tradeorder still exists at that time">
          <debug_text text="'abort scripts and go to cleaup'" chance="$debugchance" />
          <abort_called_scripts resume="cleanup" />
        </do_if>
      </actions>
    </handler>
  </interrupts>
  <attention min="visible">
    <actions>

      <label name="init" />
      <do_if value="not $target">
        <set_value name="$target" exact="$tradeorder.owner" />
      </do_if>

      <label name="movetomeet" />
      <!-- Movement to target -->
      <do_if value="$tradeorder.ispassive.{$target}">
        <do_if value="this.ship.zone != $target.zone">
          <debug_text text="'%1 move to meet %2'.[this.ship, $target]" chance="$debugchance" />
          <run_script name="'move.generic.vanilla40'">
            <param name="destination" value="$target" />
          </run_script>
        </do_if>
      </do_if>

      <label name="ready" />
      <!-- Ware Exchange Case: Passive Partner -->
      <do_if value="$tradeorder.ispassive.{this.ship}">
        <!-- Fly to a safe position -->
        <get_safe_pos result="$pasivepos" object="this.ship" zone="this.zone" radius="this.size/2.0" ignored="this.ship" />
        <move_to object="this.ship" destination="this.zone" forceposition="false" forcerotation="false" forcesteering="not this.ship.isclass.ship_l and not this.ship.isclass.ship_xl" sinceversion="1">
          <position value="$pasivepos" />
          <rotation pitch="0deg" roll="0deg" />
        </move_to>
        <remove_value name="$pasivepos" />

        <debug_text text="'Me %1 (%2), target %3 (%4)'.[this, this.ship.knownname, $target.pilot, $target.knownname]" chance="$debugchance" />
        <signal_objects object="$target" param="'wareexchange ready'" param2="$tradeorder" />
        <set_value name="this.$readyexchange" exact="true" />
        <stop_moving object="this.ship" />
        <!-- command action -->
        <set_command_action commandaction="commandaction.standingby" />
        <wait max="1h" >
          <interrupt>
            <conditions>
              <event_object_signalled object="this.ship" param="'wareexchange ready'" param2="$tradeorder" />
            </conditions>
            <actions>
              <debug_text text="'active trader is ready! He finished the movement'" chance="$debugchance" />
            </actions>
          </interrupt>
        </wait>
        <remove_value name="this.$readyexchange" />

      </do_if>
      <!-- Ware Exchange Case: Active Partner -->
      <do_else>
        <!-- Wait the pasive trade to be ready  -->
        <do_if value="not @$target.pilot.$readyexchange">
          <debug_text text="'wait for passive trader to be ready %1 (pilot %2)'.[@$target.pilot.$readyexchange, $target.pilot]" chance="$debugchance" />
          <stop_moving object="this.ship" />
          <wait max="1h" >
            <interrupt>
              <conditions>
                <event_object_signalled object="this.ship" param="'wareexchange ready'" param2="$tradeorder" />
              </conditions>
              <actions>
                <debug_text text="'%1 passive trader is ready! He finished the movement.'.[player.age]" chance="$debugchance" />
              </actions>
            </interrupt>
          </wait>
        </do_if>
        <do_elseif value="$target.pilot.$readyexchange">
          <debug_text text="'passive trader is ready!'" chance="$debugchance" />
        </do_elseif>
        <!-- Final move to the target -->
        <get_safe_pos result="$safepos" zone="$target.zone" object="$target" radius="this.ship.size/2.0 + $target.size/2.0" ignored="this.ship" />
        <move_to object="this.ship" destination="$target.zone" forceposition="false" forcerotation="false" finishonapproach="false"  >
          <position value="$safepos" />
          <rotation pitch="0deg" roll="0deg" />
        </move_to>
        <signal_objects object="$target" param="'wareexchange ready'" param2="$tradeorder" />
      </do_else>
      <!-- Align -->
      <move_to object="this.ship" destination="this.zone" forcerotation="true"  >
        <position  object="this.ship"/>
        <rotation pitch="0deg" roll="0deg" />
        <interrupt_after_time time="1s" />
      </move_to>
      <!-- command action -->
      <set_command_action commandaction="commandaction.standingby" />

      <debug_text text="'%5 Trade order. Buyer %1, seller %2, ware %3, amount %4'.[@$tradeorder.buyer.knownname, @$tradeorder.seller.knownname, $tradeorder.ware, $tradeorder.amount, player.age]" chance="$debugchance"/>
      <!-- Go to collect (buyer) or drop (seller) -->
      <do_if value="(this.ship == @$tradeorder.buyer) or ($target == @$tradeorder.seller)">
        <debug_text text="'I collect and wait. this ship buyer %1, target seller %2'.[(this.ship == @$tradeorder.buyer), ($target == @$tradeorder.seller)]" chance="$debugchance" />
        <resume label="collect" />
      </do_if>

      <label name="drop" />
      <wait exact="3s"  />
      <drop_cargo object="this.ship" ware="$tradeorder.ware" exact="$tradeorder.amount" groupname="$drops" unbundle="$tradeorder.unbundle" rebundle="$tradeorder.rebundle" />
      <signal_objects object="$target" param="'collect cargo'" param2="$drops" param3="$tradeorder" />

      <debug_text text="'%4 This ship %1: drop %2 %3'.[this.ship.knownname, $tradeorder.amount, $tradeorder.ware, player.age]" chance="$debugchance" />
      <resume label="cleanup" />

      <label name="collect" />
      <debug_text text="'wait for collect'" chance="$debugchance" />
      <wait max="1h" sinceversion="1" >
        <interrupt>
          <conditions>
            <event_object_signalled object="this.ship" param="'collect cargo'" param3="$tradeorder" />
          </conditions>
          <actions>
            <debug_text text="'%2 target drops %1'.[event.param2,player.age]" chance="$debugchance" />
            <add_to_group groupname="$drops" group="event.param2" />
          </actions>
        </interrupt>
      </wait>

      <!-- Collect behaviours -->
      <run_script name="'move.collect.ship.vanilla40'"  >
        <param name="targetgroup" value="$drops" />
        <param name="debugoutputchance" value="$debugchance" />
      </run_script>

      <label name="cleanup" />
      <debug_text text="'cleanup'" chance="$debugchance" />

      <!-- Remove it if Im the one who drops -->
      <do_if value="$tradeorder.exists">
        <do_if value="(this.ship == @$tradeorder.buyer) or ($target == @$tradeorder.seller)">
          <debug_text text="'Success: remove trade. this ship buyer %1, target seller %2'.[(this.ship == @$tradeorder.buyer), ($target == @$tradeorder.seller)]" chance="$debugchance" />
          <remove_trade_order object="this.ship" trade="$tradeorder" />
        </do_if>
        <do_else>
          <set_command_action commandaction="commandaction.executingtrade" />
          <wait sinceversion="1" comment="wait for trade to be removed" />
        </do_else>
      </do_if>

      <!-- Align -->
      <get_safe_pos result="$safepos" zone="this.zone" object="this.ship" radius="this.ship.size/2.0" ignored="this.ship" />
      <move_to object="this.ship" destination="this.zone" forcerotation="false" forceposition="false" sinceversion="1" >
        <position value="$safepos"/>
        <rotation pitch="0deg" roll="0deg" />
      </move_to>

      <return value="true" />

    </actions>
  </attention>
  <attention min="unknown">
    <actions>

      <label name="init" />
      <do_if value="not $target">
        <set_value name="$target" exact="$tradeorder.owner" />
      </do_if>

      <label name="movetomeet" />
      <!-- Movement to target -->
      <do_if value="$tradeorder.ispassive.{$target}">
        <do_if value="this.ship.zone != $target.zone">
          <debug_text text="'%1 move to meet %2'.[this.ship, $target]" chance="$debugchance" />
          <run_script name="'move.generic.vanilla40'">
            <param name="destination" value="$target" />
          </run_script>
        </do_if>
      </do_if>

      <label name="ready" />
      <!-- Ware Exchange Case: Passive Partner -->
      <do_if value="$tradeorder.ispassive.{this.ship}">
        <!-- Fly to a safe position -->
        <get_safe_pos result="$pasivepos" object="this.ship" zone="this.zone" radius="this.size/2.0" ignored="this.ship" />
        <move_to object="this.ship" destination="this.zone" forceposition="false" forcerotation="false" sinceversion="1">
          <position value="$pasivepos" />
          <rotation pitch="0deg" roll="0deg" />
        </move_to>
        <remove_value name="$pasivepos" />

        <debug_text text="'Me %1 (%2), target %3 (%4)'.[this, this.ship.knownname, $target.pilot, $target.knownname]" chance="$debugchance" />
        <signal_objects object="$target" param="'wareexchange ready'" param2="$tradeorder" />
        <set_value name="this.$readyexchange" exact="true" />
        <stop_moving object="this.ship" />
        <!-- command action -->
        <set_command_action commandaction="commandaction.standingby" />
        <wait max="1h" sinceversion="1" >
          <interrupt>
            <conditions>
              <event_object_signalled object="this.ship" param="'wareexchange ready'" param2="$tradeorder" />
            </conditions>
            <actions>
              <debug_text text="'active trader is ready! He finished the movement'" chance="$debugchance" />
            </actions>
          </interrupt>
        </wait>
        <remove_value name="this.$readyexchange" />

      </do_if>
      <!-- Ware Exchange Case: Active Partner -->
      <do_else>
        <!-- Wait the pasive trade to be ready  -->
        <do_if value="not @$target.pilot.$readyexchange">
          <debug_text text="'wait for passive trader to be ready %1 (pilot %2)'.[@$target.pilot.$readyexchange, $target.pilot]" chance="$debugchance" />
          <stop_moving object="this.ship" />
          <wait max="1h" sinceversion="1" >
            <interrupt>
              <conditions>
                <event_object_signalled object="this.ship" param="'wareexchange ready'" param2="$tradeorder" />
              </conditions>
              <actions>
                <debug_text text="'%1 passive trader is ready! He finished the movement.'.[player.age]" chance="$debugchance" />
              </actions>
            </interrupt>
          </wait>
        </do_if>
        <do_elseif value="$target.pilot.$readyexchange">
          <debug_text text="'passive trader is ready!'" chance="$debugchance" />
        </do_elseif>
        <!-- Final move to the target -->
        <get_safe_pos result="$safepos" zone="$target.zone" object="$target" radius="this.ship.size/2.0 + $target.size/2.0" ignored="this.ship" />
        <move_to object="this.ship" destination="$target.zone" forceposition="false" forcerotation="false" finishonapproach="false" sinceversion="1" >
          <position value="$safepos" />
          <rotation pitch="0deg" roll="0deg" />
        </move_to>
        <signal_objects object="$target" param="'wareexchange ready'" param2="$tradeorder" />
      </do_else>
      <!-- Align -->
      <move_to object="this.ship" destination="this.zone" forcerotation="true" sinceversion="1" >
        <position  object="this.ship"/>
        <rotation pitch="0deg" roll="0deg" />
        <interrupt_after_time time="1s" />
      </move_to>
      <!-- command action -->
      <set_command_action commandaction="commandaction.standingby" />

      <debug_text text="'%5 Trade order. Buyer %1, seller %2, ware %3, amount %4'.[@$tradeorder.buyer.knownname, @$tradeorder.seller.knownname, $tradeorder.ware, $tradeorder.amount, player.age]" chance="$debugchance"/>
      <!-- Go to collect (buyer) or drop (seller) -->
      <do_if value="(this.ship == @$tradeorder.buyer) or ($target == @$tradeorder.seller)">
        <debug_text text="'I collect and wait'" chance="$debugchance" />
        <resume label="collect" />
      </do_if>

      <label name="drop" />
      <wait exact="3s" sinceversion="1" />
      <drop_cargo object="this.ship" ware="$tradeorder.ware" exact="$tradeorder.amount" groupname="$drops" unbundle="$tradeorder.unbundle" rebundle="$tradeorder.rebundle" />
      <signal_objects object="$target" param="'collect cargo'" param2="$drops" param3="$tradeorder" />

      <debug_text text="'%4 This ship %1: drop %2 %3'.[this.ship.knownname, $tradeorder.amount, $tradeorder.ware, player.age]" chance="$debugchance" />
      <resume label="cleanup" />

      <label name="collect" />
      <debug_text text="'wait for collect'" chance="$debugchance" />
      <wait max="1h" sinceversion="1" >
        <interrupt>
          <conditions>
            <event_object_signalled object="this.ship" param="'collect cargo'" param3="$tradeorder" />
          </conditions>
          <actions>
            <debug_text text="'%2 target drops %1'.[event.param2,player.age]" chance="$debugchance" />
            <add_to_group groupname="$drops" group="event.param2" />
          </actions>
        </interrupt>
      </wait>

      <!-- Collect behaviours -->
      <run_script name="'move.collect.ship.vanilla40'" sinceversion="1" >
        <param name="targetgroup" value="$drops" />
      </run_script>

      <label name="cleanup" />
      <debug_text text="'cleanup'" chance="$debugchance" />

      <!-- Remove it if Im the one who drops -->
      <do_if value="$tradeorder.exists">
        <do_if value="(this.ship == @$tradeorder.buyer) or ($target == @$tradeorder.seller)">
          <remove_trade_order object="this.ship" trade="$tradeorder" />
          <debug_text text="'Success: remove trade'" chance="$debugchance" />
        </do_if>
        <do_else>
          <set_command_action commandaction="commandaction.executingtrade" />
          <wait sinceversion="1" comment="wait for trade to be removed" />
        </do_else>
      </do_if>

      <!-- Align -->
      <get_safe_pos result="$safepos" zone="this.zone" object="this.ship" radius="this.ship.size/2.0" ignored="this.ship" />
      <move_to object="this.ship" destination="this.zone" forcerotation="false" forceposition="false" sinceversion="1" >
        <position value="$safepos"/>
        <rotation pitch="0deg" roll="0deg" />
      </move_to>

      <return value="true" />

    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="utf-8" ?>
<aiscript name="player.default.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="4">

  <!--
  if command == command_follow or command_wait
  - Trade added
  - Modes (only on command_follow):    
    - mining
    - collect tagged objects
  - Orders:
    - take me to
    - refuel
    - mining
    - hold position
    - fly to me
    - fly to
  - defend player under attack (if possible)
  - default to follow
  
  -->
  <params>
    <param name="debugchance" default="0"/>
  </params>
  <interrupts>
    <!-- Invalid Target position -->
    <handler ref="TargetInvalidHandler.vanilla40"/>
    <!-- AttackHandler -->
    <handler ref="AttackHandler.vanilla40"/>
    <!-- Player Attacked -->
    <handler>
      <conditions>
        <event_object_attacked object="player.primaryship" check="false" />
        <check_value value="this.command.value == command.follow" />
        <check_value value="this.ship.zone == player.primaryship.zone" />
      </conditions>
      <actions>

        <set_value name="$target" exact="event.param" />

        <do_if value="$target.isoperational">
          <!--Should there be an additional check for $target.mayattack.{this.ship}? Would mean freighters would not attack even if the attacker is red-->
          <do_if value="player.primaryship.mayattack.{$target}">

            <debug_text text="' player under attack by: %1 .command: %2'.[$target.knownname,this.command.value]" chance="$debugchance" />
            <debug_text text="' my dps: %1, target dps: %2 '.[this.ship.dps.all, $target.dps.all]" chance="$debugchance" />

            <!-- If is good to defend: start the wrapper -->
            <do_if value="this.ship.dps.all" min="$target.dps.all">
              <run_interrupt_script name="'command.fight.attack.vanilla40'" >
                <param name="target" value="event.param" />
                <param name="escort" value="player.primaryship" />
                <param name="speak" value="false" />
              </run_interrupt_script>
            </do_if>

          </do_if>
        </do_if>

      </actions>
    </handler>
    <!-- TRADES -->
    <handler>
      <!-- Add a shopping item, or Clear shopping list -->
      <conditions>
        <check_any>
          <event_object_shoppinglist_trade_added object="this.ship" />
          <event_object_signalled object="this.ship" param="'clear shoppinglist'" />
        </check_any>
      </conditions>
      <actions>
        <do_if value="event.name == 'event_object_shoppinglist_trade_added'">
          <get_trade_from_shoppinglist object="this.ship" multiple="true" result="$shoppinglist" />
          <!-- If wait/follow/refuel/null or ware exchange interrupt to make the trades -->
          <do_if value="($shoppinglist.count le 1) and ([command.follow, command.wait, command.refuel, command.patrol, null].indexof.{this.command.value} or event.param.iswareexchange)">
            <!-- ok, we're cleared to follow this order -->
            <debug_text text="'New trade order received: %1, ware exchange: %2, current command %3, shoppinglist %4'.[event.param,event.param.iswareexchange, this.command.value, $shoppinglist.count]" />
            <run_interrupt_script name="'trade.performplayertraderun.vanilla40'" abortscripts="true" resume="init">
              <param name="debugchance" value="$debugchance"/>
            </run_interrupt_script>
          </do_if>
          <do_else>
            <!-- Set a variable to tell move.follow to finish (will be removed internally) -->
            <set_value name="this.$abortmovefollow" exact="true" />
          </do_else>
        </do_if>
        <do_elseif value="event.name == 'event_object_signalled'">
          <!-- If player clear the shopping list -->
          <!-- Stop move if possible-->
          <do_if value="(not @this.$shiptrader_docking) and (not @this.$ship_parking) and (not this.ship.dockslot) and (not this.ship.docklink)">
            <!-- Save the actual command, to handle the cases in 'interrupt.stoporder' -->
            <set_value name="$command" exact="this.command.value" />
            <!-- To use blocking actions (move to a safe position), run this script -->
            <run_interrupt_script name="'interrupt.stoporder.vanilla40'" abortscripts="true">
              <param name="prevcommand" value="$command" />
            </run_interrupt_script>
          </do_if>
          <do_else>
            <debug_text text="'clearing shopping list'" chance="$debugchance" />
            <get_trade_from_shoppinglist object="this.ship" multiple="true" result="$shoppinglist" />

            <do_all exact="$shoppinglist.count" counter="$i" reverse="true">
              <do_if value="@$shoppinglist.{$i}.buyer.isoperational and @$shoppinglist.{$i}.seller.isoperational">
                <debug_text text="'skipping trade: ' + $shoppinglist.{$i} + ' as both buyer and seller are valid and the trade is in progress.'" chance="$debugchance" />
              </do_if>
              <do_else>
                <!-- we need to clean up our ware reservations -->
                <do_if value="@$shoppinglist.{$i}.buyer.isoperational">
                  <remove_ware_reservation object="$shoppinglist.{$i}.buyer" type="sell" entity="this" ware="$shoppinglist.{$i}.ware" amount="$shoppinglist.{$i}.amount" virtual="$shoppinglist.{$i}.unbundle" />
                </do_if>
                <do_elseif value="@$shoppinglist.{$i}.seller.isoperational">
                  <remove_ware_reservation object="$shoppinglist.{$i}.seller" type="buy" entity="this" ware="$shoppinglist.{$i}.ware" amount="$shoppinglist.{$i}.amount" virtual="$shoppinglist.{$i}.rebundle" />
                </do_elseif>
                <remove_trade_order object="this.ship" trade="$shoppinglist.{$i}" />
              </do_else>
            </do_all>
          </do_else>
        </do_elseif>
      </actions>
    </handler>
    <!-- ORDERS -->
    <handler>
      <!-- ALL Orders: dock at, take me to, refuel -->
      <conditions>
        <check_any>
          <event_object_signalled object="this.ship" param="'dock at'" />
          <event_object_signalled object="this.ship" param="'take me to'" />
          <event_object_signalled object="this.ship" param="'refuel'" />
          <event_object_signalled object="this.ship" param="'start mining'" />
          <event_object_signalled object="this.ship" param="'attack object'" />
          <event_object_signalled object="this.ship" param="'attack enemies'" />
          <event_object_signalled object="this.ship" param="'hold position'" />
          <event_object_signalled object="this.ship" param="'fly to me'" />
          <event_object_signalled object="this.ship" param="'fly to pos'" />
          <event_object_signalled object="this.ship" param="'withdraw battle'" />
        </check_any>
      </conditions>
      <actions>
        <!-- dock at -->
        <do_if value="event.param == 'dock at'">
          <debug_text text="'Received order to dock at ' + event.param2.name" />
          <run_interrupt_script name="'move.dockat.vanilla40'" abortscripts="true" resume="init">
            <param name="destination" value="event.param2" />
            <param name="dockingslot" value="event.param3" />
          </run_interrupt_script>
        </do_if>
        <!-- take me to -->
        <do_elseif value="event.param == 'take me to'">
          <debug_text text="'Take player to ' + event.param2.knownname + ' started'" />
          <run_interrupt_script name="'command.move.taxi.vanilla40'" abortscripts="true" resume="init">
            <param name="destination" value="event.param2" />
          </run_interrupt_script>
        </do_elseif>
        <!-- Re-fuel -->
        <do_elseif value="event.param == 'refuel'">
          <debug_text text="'Received order to refuel '" />
          <run_interrupt_script name="'command.move.refuel.vanilla40'" abortscripts="true" resume="init">
            <param name="budget" value="event.param2" />
          </run_interrupt_script>
        </do_elseif>
        <!-- Mining order -->
        <do_elseif value="event.param == 'start mining'">
          <debug_text text="'Received order to gather %1 in %2'.[event.param2.{1}.name, event.param2.{2}.knownname]" />
          <run_interrupt_script name="'command.mining.player.vanilla40'" abortscripts="true">
            <param name="ware" value="event.param2.{1}" />
            <param name="zone" value="event.param2.{2}" />
            <param name="debugchance" value="$debugchance"/>
          </run_interrupt_script>
        </do_elseif>
        <!-- Attack Object order. Can be Station, ship, component -->
        <do_elseif value="event.param == 'attack object'">
          <debug_text text="'Received order to attack to ' + event.param2.knownname" />
          <run_interrupt_script name="'command.fight.attack.vanilla40'" abortscripts="true" resume="init">
            <param name="target" value="event.param2" />
            <param name="checkrelation" value="false" />
          </run_interrupt_script>
        </do_elseif>
        <!-- Attack enemies in zone. -->
        <do_elseif value="event.param == 'attack enemies'">
          <debug_text text="'Received order to attack enemies in ' + event.param2.knownname" />
          <run_interrupt_script name="'command.fight.enemies.vanilla40'" abortscripts="true" resume="init">
            <param name="targetzone" value="event.param2" />
            <param name="endtime" value="event.param3" />
          </run_interrupt_script>
        </do_elseif>
        <!-- Advance Options -->
        <!-- Hold Position order hold position-->
        <do_elseif value="event.param == 'hold position'">
          <debug_text text="'Received order hold position '" />
          <run_interrupt_script name="'command.move.wait.vanilla40'" abortscripts="true" resume="init" />
        </do_elseif>
        <!--Fly to me and wait order-->
        <do_elseif value="event.param == 'fly to me'">
          <debug_text text="'Received order fly to player and wait'" />
          <run_interrupt_script name="'command.move.wait.vanilla40'" abortscripts="true" resume="init">
            <param name="destination" value="player.primaryship" />
          </run_interrupt_script>
        </do_elseif>
        <!--Fly to zone and wait order-->
        <do_elseif value="event.param == 'fly to pos'">
          <debug_text text="'Received order fly to %1 (%2) and wait '.[event.param2.knownname, event.param3]" />
          <run_interrupt_script name="'command.move.wait.vanilla40'" abortscripts="true" resume="init">
            <param name="destination" value="event.param2" />
            <param name="position" value="event.param3" />
          </run_interrupt_script>
        </do_elseif>
        <!-- Withdraw from Battle -->
        <do_elseif value="event.param == 'withdraw battle'">
          <debug_text text="'Received order withdraw battle and wait '" />
          <run_interrupt_script name="'command.move.wait.vanilla40'" abortscripts="true" resume="init">
            <param name="withdraw" value="true" />
          </run_interrupt_script>
        </do_elseif>
      </actions>
    </handler>
    <!-- MODES -->
    <handler>
      <conditions>
        <check_any>
          <event_object_signalled object="this.ship" param="'miningmode'" />
          <event_object_signalled object="this.ship" param="'collectcargo'" />
        </check_any>
        <check_value value="this.command.value == command.follow" />
      </conditions>
      <actions>
        <!-- miningmode activated and we should take part -->
        <do_if value="event.param == 'miningmode'">
          <debug_text text="'Start mining mode...'" />
          <run_interrupt_script name="'command.mining.player.vanilla40'">
            <param name="miningmode" value="true" />
            <param name="debugchance" value="$debugchance"/>
          </run_interrupt_script>
        </do_if>
        <!-- Collect cargo mode -->
        <do_if value="event.param == 'collectcargo'">
          <debug_text text="'Start collect cargo mode...'" />
          <run_interrupt_script name="'command.collect.cargo.vanilla40'">
            <param name="debugchance" value="$debugchance"/>
          </run_interrupt_script>
        </do_if>
      </actions>
    </handler>
    <!-- Stop ORDERS -->
    <handler >
      <conditions>
        <event_object_signalled object="this.ship" param="'stop order'" />
        <check_value value="this.command.value != command.follow" />
        <check_value value="(not @this.$shiptrader_docking) and (not @this.$ship_parking) and (not this.ship.dockslot) and (not this.ship.docklink)" />
      </conditions>
      <actions>
        <!-- Save the actual command, to handle the cases in 'interrupt.stoporder' -->
        <set_value name="$command" exact="this.command.value" />
        <!-- To use blocking actions (move to a safe position), run this script -->
        <run_interrupt_script name="'interrupt.stoporder.vanilla40'" abortscripts="true">
          <param name="prevcommand" value="$command" />
        </run_interrupt_script>

      </actions>
    </handler>
    <!-- Desactivate MODES-->
    <handler>
      <!-- any mode is deactivated, recall any drones and switch to follow mode IF we were supporting! -->
      <conditions>
        <event_object_signalled object="this.ship" param="'modeoff'" />
        <check_value value="this.command.value == command.support" />
      </conditions>
      <actions>
        <debug_text text="'Stop mode...'" />
        <cease_fire object="this.ship" weapontype="mining" />
        <!-- recall drones -->
        <run_interrupt_script name="'lib.recall.drones.vanilla40'" abortscripts="true" />
      </actions>
    </handler>
    <!-- Add/Remove from squad -->
    <handler>
      <conditions>
        <check_any>
          <check_all>
            <event_player_subordinate_added subordinate="this.ship" />
            <check_value value="not this.command.value" />
          </check_all>
          <check_all>
            <event_player_subordinate_removed subordinate="this.ship" />
            <check_value value="this.command.value == command.follow" />
          </check_all>
        </check_any>
      </conditions>
      <actions>
        <debug_text text="'%1: abort called scripts and resume to init'.[event.name]" chance="$debugchance" />
        <abort_called_scripts resume="init" />
      </actions>
    </handler>
  </interrupts>
  <attention min="unknown">
    <actions>

      <leave_formation object="this.ship" />

      <label name="init" />

      <do_if value="this.$shiptrader_docking?">
        <do_if value="this.$shiptrader_docking.component.isoperational">
          <do_if value="not this.ship.dockslot">
            <wait_for_prev_script action="$action" sinceversion="1" />
            <do_if value="$action == 'move_docking'">
              <dock ship="this.ship" />
            </do_if>
            <do_else>
              <run_script name="'move.dockat.vanilla40'" sinceversion="1">
                <param name="dockingslot" value="this.$shiptrader_docking" />
              </run_script>
              <return />
            </do_else>
          </do_if>
          <return />
        </do_if>
        <do_else>
          <remove_value name="this.$shiptrader_docking" />
        </do_else>
      </do_if>

      <detach_from_masstraffic object="this.ship" sinceversion="4" />

      <run_script name="'move.undock.vanilla40'" />

      <label name="loop" />

      <get_trade_from_shoppinglist object="this.ship" result="$shoppingtrade" />
      <do_if value="$shoppingtrade.exists">
        <run_script name="'trade.performplayertraderun.vanilla40'" sinceversion="2">
          <param name="debugchance" value="$debugchance"/>
        </run_script>
      </do_if>

      <!-- move.follow player. End if is not in squad -->
      <do_if value="player.primaryship.exists and this.ship.commander == player.primaryship">
        <run_script name="'move.follow.vanilla40'">
          <param name="target" value="player.primaryship" />
        </run_script>
      </do_if>
      <do_else>
        <set_command_action commandaction="commandaction.standingby" />
        <stop_moving object="this.ship" />
        <wait sinceversion="3"/>
      </do_else>

      <wait min="100ms" max="500ms" sinceversion="2" />

      <resume label="loop" />

      <label name="end" />
      <debug_text text="' End script'" chance="$debugchance" />

    </actions>
  </attention>
  <on_abort>
    <!-- This is script can be aborted by assigning the ship to a station/ship -->
    <debug_text text="'clearing shopping list on abort'" chance="$debugchance" />
    <get_trade_from_shoppinglist object="this.ship" multiple="true" result="$shoppinglist" />
    <do_all exact="$shoppinglist.count" counter="$i" reverse="true">
      <do_if value="@$shoppinglist.{$i}.buyer.isoperational and @$shoppinglist.{$i}.seller.isoperational">
        <debug_text text="'skipping trade: ' + $shoppinglist.{$i} + ' as both buyer and seller are valid and the trade is in progress.'" chance="$debugchance" />
      </do_if>
      <do_else>
        <!-- we need to clean up our ware reservations -->
        <do_if value="@$shoppinglist.{$i}.buyer.isoperational">
          <remove_ware_reservation object="$shoppinglist.{$i}.buyer" type="sell" entity="this" ware="$shoppinglist.{$i}.ware" amount="$shoppinglist.{$i}.amount" virtual="$shoppinglist.{$i}.unbundle" />
        </do_if>
        <do_elseif value="@$shoppinglist.{$i}.seller.isoperational">
          <remove_ware_reservation object="$shoppinglist.{$i}.seller" type="buy" entity="this" ware="$shoppinglist.{$i}.ware" amount="$shoppinglist.{$i}.amount" virtual="$shoppinglist.{$i}.rebundle" />
        </do_elseif>
        <remove_trade_order object="this.ship" trade="$shoppinglist.{$i}" />
      </do_else>
    </do_all>
  </on_abort>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="player.interaction.budget.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="10">

  <params>
    <param name="debugoutputchance" default="100"/>
  </params>

  <attention min="unknown">
    <actions>
      <!-- TODO: How to handle/prevent interruption by other scripts? -->

      <set_value name="$debugoutputchance" exact="0" />
      <substitute_text text="$logtext" source="{1016,41}" comment="The account of $STATION$ in $ZONE$ has dropped to $MONEY$ Credits.">
        <replace string="'$STATION$'" with="this.container.knownname" />
        <replace string="'$ZONE$'" with="this.zone.knownname" />
        <replace string="'$MONEY$'" with="this.money.formatted.default" />
      </substitute_text>
      <write_to_logbook category="upkeep" object="this.container" text="$logtext" />
      
      <run_script name="'player.interaction.vanilla40'" result="$result">
        <param name="Line" value="4800" comment="I'm experiencing a funding-shortage." />
        <param name="UIText" value="{1015,29}" comment="Info: insufficient money" />
        <param name="ConversationParam" value="'g_trade_money_low'" />
      </run_script>

      <debug_text text="'$result: ' + $result" chance="$debugoutputchance"/>
      <do_if value="$result" exact="'auto'">
        <debug_text text="'Automatic transfer!'" chance="$debugoutputchance"/>
        <do_if value="this.money lt this.minbudget">
          <set_value name="$Amount" exact="this.money"/>
          <transfer_money from="player.entity" to="this" amount="(this.minbudget + this.maxbudget) / 2 - this.money"/>
          <set_value name="$Amount" exact="this.money - $Amount"/>
          
          <substitute_text text="$logtext" source="{1016,42}" comment="$STATION$ in $ZONE$ has had $AMOUNT$ transfered to its account. New balance is $MONEY$.">
            <replace string="'$STATION$'" with="this.container.knownname" />
            <replace string="'$ZONE$'" with="this.zone.knownname" />
            <replace string="'$AMOUNT$'" with="$Amount.formatted.default" />
            <replace string="'$MONEY$'" with="this.money.formatted.default" />
          </substitute_text>
          <write_to_logbook category="upkeep" object="this.container" text="$logtext" />
        </do_if>
      </do_if>
    </actions>
  </attention>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="player.interaction.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="4">

  <params>
    <param name="Page" default="this.page" />
    <param name="Line" />
    <param name="UIText" />
    <param name="ConversationParam" />
    <param name="Duration" default="10s" />
    <param name="MaxQueueDelay" default="45s" />
    <param name="Cutscene" default="'ShowPilot'" />
  </params>

  <attention min="unknown">
    <actions>
      <set_value name="$debugoutputchance" exact="0" />

      <!-- Allow multiple interactive events to queue up. Reserve time for our own interaction and wait until previous interactions are over. -->
      <set_value name="$queuedelay" exact="@global.$NextPlayerInteraction - player.age" />
      <do_if value="$queuedelay gt $MaxQueueDelay">
        <debug_text text="'Required delay %1s exceeds max delay %2s, no interaction'.[$queuedelay, $MaxQueueDelay]" chance="$debugoutputchance" />
        <!-- Required delay too long, no interaction -->
        <return value="null" />
      </do_if>
      <do_if value="$queuedelay gt 0s">
        <debug_text text="'Another player interaction is in progress, wait %1 seconds'.[$queuedelay]" chance="$debugoutputchance" />
        <set_value name="global.$NextPlayerInteraction" exact="global.$NextPlayerInteraction + $Duration + 500ms" />
        <wait exact="$queuedelay" sinceversion="4" />
      </do_if>
      <do_elseif value="player.isinconversation">
        <debug_text text="'Conversation is running, wait in 5 seconds and try again'" chance="$debugoutputchance" />
        <do_if value="$MaxQueueDelay ge 5s">
          <set_value name="global.$NextPlayerInteraction" exact="player.age + 5s + $Duration + 500ms" />
          <wait exact="5s" sinceversion="4" />
        </do_if>
      </do_elseif>
      <do_else>
        <debug_text text="'No conversation and no other player interaction detected'" chance="$debugoutputchance" />
        <set_value name="global.$NextPlayerInteraction" exact="player.age + $Duration + 500ms" />
      </do_else>
      <!-- Conversation still running despite delay above, but we can't wait forever -->
      <do_if value="player.isinconversation">
        <debug_text text="'Conversation still running, no interaction'" chance="$debugoutputchance" />
        <return value="null" />
      </do_if>

      <debug_text text="'Playing cutscene ' + $Cutscene + ' with npcref=' + this" chance="$debugoutputchance" />
      <do_if value="this.container and this.isplayerowned">
        <set_value name="$caption" exact="this.container.name" />
      </do_if>
      <do_else>
        <set_value name="$caption" exact="''" comment="Not shown" />
      </do_else>
      <play_cutscene key="$Cutscene" eventmonitor="true" timeout="$Duration + 100ms" caption="$caption" sound="notification_conversationstart">
        <interaction text="$UIText" param="this" param2="$ConversationParam" />
        <param name="npcref" object="this" />
      </play_cutscene>

      <!-- TODO: Check if cutscene is actually started, handle error cases -->
      <wait exact="1ms" />
      <wait exact="1ms" sinceversion="3" comment="2nd wait to guarantee we wait at least 2 frames for the character information to be loaded" />
      <speak actor="this" page="$Page" line="$Line" priority="99" />

      <debug_text text="'Waiting ' + $Duration + ' seconds for events'" chance="$debugoutputchance" />
      <wait exact="$Duration">
        <interrupt>
          <conditions>
            <check_any>
              <event_player_interaction param="this" />
              <event_cutscene_stopped key="$Cutscene" />
            </check_any>
          </conditions>
          <actions>
            <debug_text text="'Got event ' + event.name" chance="$debugoutputchance" />
            <do_if value="event.name == 'event_cutscene_stopped'">
              <set_value name="$result" exact="'abort'" />
            </do_if>
            <do_else>
              <set_value name="$result" exact="null" />
            </do_else>
          </actions>
        </interrupt>
      </wait>

      <debug_text text="'Finished waiting, $result=' + @$result" chance="$debugoutputchance" />
      <do_if value="@$result == 'abort'">
        <!-- NPC cutscene has been stopped -->
        <return value="null" />
      </do_if>
      <stop_cutscene key="$Cutscene" />

      <do_if value="$result?">
        <!-- player is interacting -->
        <start_conversation actor="this" conversation="InteractiveEventContinued" convparam="$ConversationParam" />
        <wait sinceversion="2">
          <interrupt>
            <conditions>
              <check_any>
                <event_conversation_next_section actor="this" section="g_interactionresult" />
                <event_conversation_finished actor="this"/>
              </check_any>
            </conditions>
            <actions>
              <do_if value="event.name == 'event_conversation_next_section'">
                <set_value name="$result" exact="event.param2" />
              </do_if>
              <do_else>
                <set_value name="$result" exact="null" />
              </do_else>
            </actions>
          </interrupt>
        </wait>
        
        <wait exact="0s" chance="0"/>
      </do_if>

      <!-- Return value is the result provided by the conversation (implemented in MD), or null if there was no interaction -->
      <debug_text text="'Returning result: ' + @$result" chance="$debugoutputchance" />
      <return value="@$result" />
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.findfreetraderun.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <params>
    <param name="warelist" />
    <param name="range" comment="space to base the search on. $rangeparams use this as the start point"/>
    <param name="sellrange" default="null" comment="list: [$mingates, $maxgates] amount of jumpgates from $range the ship can sell wares (null == only sell in $range)"/>
    <param name="buyrange" default="null" comment="list: [$mingates, $maxgates] amount of jumpgates from $range the ship can buy wares (null == only buy in $range)"/>
    <param name="lasttrade" default="null" comment="list: [$buyoffer, $ware, $tradepartner]"/>
    <param name="debugchance" default="0" />
    <param name="debugchance2" default="0" comment="more spammy" />
  </params>
  <init>
    <set_command_action commandaction="commandaction.searchingtrades" />
  </init>
  <attention min="unknown">
    <actions>
      <!-- set up initial state for trade runs -->
      <set_value name="$reservetrades" exact="false" />
      <set_value name="$minvolume" exact="1" />
      <set_value name="$capship" exact="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" />
      <do_if value="$capship" >
        <set_value name="$reservetrades" exact="true" />
        <set_value name="$minvolume" exact="this.ship.cargo.capacity / 20" />
      </do_if>
      <debug_text text="'min trade volume for ' + this.ship.knownname + ': ' + $minvolume" chance="$debugchance" />

      <label name="start" />
      <set_value name="$currentcargo" exact="this.ship.cargo.list" />
      <set_value name="$fuelindex" exact="$currentcargo.indexof.{ware.fuelcells}" />
      <do_if value="$fuelindex gt 0">
        <remove_value name="$currentcargo.{$fuelindex}" />
      </do_if>
      <set_value name="$buyoffer" exact="null" />
      <set_value name="$selloffer" exact="null" />
      <set_value name="$buildership_check" exact="true" />
      <debug_text text="player.age + ' current cargo: ' + $currentcargo" chance="$debugchance" />

      <set_value name="$checkrange" exact="this.ship.zone" />

      <!--If there is a $sellrange, find all clusters within the sell range-->
      <do_if value="@$sellrange">
        <debug_text text="'sellrange is min: ' + $sellrange.{1} + ' max: ' + $sellrange.{2}" chance="$debugchance2"/>
        <!--TODO: Library call to get these lists?-->
        <set_value name="$sellclusters" exact="[]"/>
        <set_value name="$sellclustersdistances" exact="[]"/>

        <set_value name="$findclusters" exact="false"/>
        <do_if value="@this.$traderange_nexttime le player.age">
          <set_value name="$findclusters" exact="true"/>
        </do_if>

        <!--Get all clusters in range. Store on the blackboard so we don't have to recalculate every time.-->
        <!--However, recalculate every now and again incase a new gate has opened-->
        <do_if value="not this.$traderange_sellclusters? or $findclusters">
          <debug_text text="'using find_cluster to populate the blackboards list of clusters to sell to'" chance="$debugchance2"/>
          <find_cluster name="this.$traderange_sellclusters" multiple="true" presentation="false">
            <match_gate_distance object="$range" min="$sellrange.{1}" max="$sellrange.{2}"/>
          </find_cluster>
        </do_if>
        <set_value name="$sellclusters" exact="this.$traderange_sellclusters.clone" comment="Copy the list from the blackboard. We will work with this."/>
        <!--Go over them again to sort them. But check the distance from the ships current cluster so that nearer clusters are prefered-->
        <do_all exact="$sellclusters.count" counter="$Counter">
          <append_to_list name="$sellclustersdistances" exact="$sellclusters.{$Counter}.gatedistance.{this.ship.cluster}"/>
          <debug_text text="'sellcluster found: ' + $sellclusters.{$Counter}.name + ' at distance of ' + $sellclustersdistances.{$Counter}" chance="$debugchance2"/>
        </do_all>

        <!--Check if the current $checkrange (the ships current zone) is within the sell range. If so, look for offers, otherwise -->
        <set_value name="$GateDistance" exact="$checkrange.gatedistance.{$range}"/>
        <debug_text text="'Checking if $checkrange ' + $checkrange.knownname + ' is within sell range. GateDistance from $range is: ' + $GateDistance" chance="$debugchance2"/>
        <set_value name="$ValidDistance" exact="true"/>
        <do_if value="$sellrange.{1} ge 0">
          <do_if value="$GateDistance lt $sellrange.{1}">
            <set_value name="$ValidDistance" exact="false"/>
          </do_if>
        </do_if>
        <do_if value="$sellrange.{2} ge 0">
          <do_if value="$GateDistance gt $sellrange.{2}">
            <set_value name="$ValidDistance" exact="false"/>
          </do_if>
        </do_if>
        <do_if value="not $ValidDistance">
          <debug_text text="player.age + ' The zone ' + $checkrange.knownname + ' is not within the ships range to sell things. Finding new sell area.'" chance="$debugchance" />
          <set_value name="$checkrange" exact="null" />
        </do_if>
      </do_if>

      <label name="check sell range" />

      <do_if value="@$sellrange">
        <do_if value="not $checkrange.exists">
          <do_if value="$sellclusters.count">
            <set_value name="$Index" exact="$sellclustersdistances.indexof.{$sellclustersdistances.min}"/>
            <set_value name="$checkrange" exact="$sellclusters.{$Index}"/>
            <debug_text text="'range to sell wares is now ' + $checkrange.knownname" chance="$debugchance"/>
            <remove_value name="$sellclusters.{$Index}"/>
            <remove_value name="$sellclustersdistances.{$Index}"/>
          </do_if>
        </do_if>
      </do_if>

      <label name="find trade run" />

      <do_if value="$checkrange.exists">
        <!-- try to find a buy offer for wares in our cargo first -->
        <do_if value="$currentcargo.count gt 0">

          <do_if value="@this.$trade_failedfindruns" min="10">
            <!-- if we are still failing to sell our cargo after 10 failed attemps, dump some of it -->
            <set_value name="$dropware" exact="$currentcargo.random" />
            <drop_cargo object="this.ship" ware="$dropware" min="(this.ship.cargo.{$dropware}.count * 0.4f)i" max="(this.ship.cargo.{$dropware}.count * 0.8f)i" amounts="$droppedamounts" wares="$droppedwares" />
            <do_all exact="$droppedwares.count" counter="$d">
              <debug_text text="'try to free up some cargo space by dropping %1 %2'.[$droppedamounts.{$d}, $droppedwares.{$d}]" chance="$debugchance" />
            </do_all>
          </do_if>

          <!-- step 1, check if we can sell to build platforms -->
          <debug_text text="player.age + ' checking if we can sell cargo to builder ships in ' + $checkrange.knownname" chance="$debugchance" />
          <find_buy_offer tradepartner="this.ship" space="$checkrange" result="$buyoffer" wares="$currentcargo">
            <match_buyer class="class.ship_xl" />
          </find_buy_offer>
          <!--OPTIONAL TODO: Filter the found trades. Pick the best one based on price or cargo space to be gained (we don't want the ships to be too smart, or they will all go for the same "best" offer)-->
          <do_if value="$buyoffer.exists">
            <debug_text text="player.age + ' buy offer on builder ship found: %1 in %2 needs %3 %4'.[$buyoffer.buyer.name, $buyoffer.buyer.zone.knownname, $buyoffer.offeramount.{this}, $buyoffer.ware.name]" chance="$debugchance"/>
            <resume label="finish" />
          </do_if>

          <!-- step 2, check if we can sell to stations -->
          <find_buy_offer tradepartner="this.ship" space="$checkrange" result="$buyoffers" wares="$currentcargo" multiple="true">
            <match_buyer>
              <match negate="true" class="class.ship_xl" />
            </match_buyer>
          </find_buy_offer>
          <debug_text text="player.age + ' found ' + $buyoffers.count + ' buyoffers for selling cargo in ' + $checkrange.knownname" chance="$debugchance" />
          <do_if value="$buyoffers.count gt 0">
            <set_value name="$good_offers" exact="[]" />
            <!-- sort trades by ware, so our little optimisation to access this.ship.cargo only as much as needed works -->
            <sort_trades sorter="name" tradelist="$buyoffers" name="$sorted_offers" />
            <set_value name="$currentware" exact="null" />
            <set_value name="$currentamount" exact="0" />
            <do_all exact="$sorted_offers.count" counter="$b">
              <set_value name="$offer" exact="$sorted_offers.{$b}"/>
              <do_if value="$currentware != $offer.ware">
                <!-- only update currentamount when needed to reduce accesses to this.ship.cargo -->
                <set_value name="$currentware" exact="$offer.ware" />
                <set_value name="$currentamount" exact="this.ship.cargo.{$currentware}.count" />
              </do_if>
              <do_if value="@$lasttrade and (not $lasttrade.{1}) and $lasttrade.{2} == $currentware and $lasttrade.{3} == $offer.buyer">
                <!-- the last thing we did was buy this ware from the buyer, don't sell it back immediately! -->
                <debug_text text="'we just bought %1 from %2 (%3), don\'t try to sell it right back!'.[$lasttrade.{2}, $lasttrade.{3}.knownname, $lasttrade.{3}]" chance="$debugchance2"/>
                <continue />
              </do_if>
              <set_value name="$minamount" exact="$currentamount" />
              <do_if value="@this.$trade_failedfindruns" min="2">
                <!-- if we have not found a good trade run after 2 attempts, relax the rules -->
                <set_value name="$minamount" exact="($minamount / this.$trade_failedfindruns) + 1" comment="add 1 to make sure we don't end up with minamount == 0" />
                <debug_text text="'reducing minamount from %1 to %2 for %3'.[$currentamount, $minamount, $currentware]" chance="$debugchance" />
              </do_if>
              <do_elseif value="this.ship.cargo.free" max="this.ship.cargo.capacity/2">
                <!-- if we have <= 50% free cargospace, also accept buyoffers for less to increase the chance of selling off cargo -->
                <set_value name="$minamount" exact="$minamount / 2" />
              </do_elseif>

              <do_if value="$offer.offeramount.{this} ge $minamount">
                <append_to_list name="$good_offers" exact="$offer" />
              </do_if>

            </do_all>
            <do_if value="$good_offers.count gt 0">
              <set_value name="$buyoffer" exact="$good_offers.random" />
            </do_if>
            <remove_value name="$minamount" />
            <remove_value name="$good_offers" />
          </do_if>
          <!--OPTIONAL TODO: Filter the found trades. Pick the best one based on price or cargo space to be gained (we don't want the ships to be too smart, or they will all go for the same "best" offer)-->
          <do_if value="$buyoffer.exists">
            <debug_text text="player.age + ' buy offer found!'" chance="$debugchance" />
            <resume label="finish" />
          </do_if>
        </do_if>
        <!--No trade offer. If a $sellrange is defined, check to see if there is another area to search-->
        <do_if value="@$sellrange">
          <set_value name="$checkrange" exact="null"/>
          <resume label="check sell range"/>
        </do_if>
      </do_if>

      <!--If there is a $buyrange, find all clusters within the buy range-->
      <do_if value="@$buyrange">
        <debug_text text="'buyrange is min: ' + $buyrange.{1} + ' max: ' + $buyrange.{2}" chance="$debugchance2"/>

        <set_value name="$buyclusters" exact="[]"/>
        <set_value name="$buyclustersdistances" exact="[]"/>

        <set_value name="$findclusters" exact="false"/>
        <do_if value="@this.$traderange_nexttime le player.age">
          <set_value name="$findclusters" exact="true"/>
        </do_if>

        <!--Get all clusters in range. Store on the blackboard so we don't have to recalculate every time.-->
        <!--However, recalculate every now and again incase a new gate has opened-->
        <do_if value="not this.$traderange_buyclusters? or $findclusters">
          <debug_text text="'using find_cluster to populate the blackboards list of clusters to buy to'" chance="$debugchance2"/>
          <find_cluster name="this.$traderange_buyclusters" multiple="true" presentation="false">
            <match_gate_distance object="$range" min="$buyrange.{1}" max="$buyrange.{2}"/>
          </find_cluster>
        </do_if>
        <set_value name="$buyclusters" exact="this.$traderange_buyclusters.clone" comment="Copy the list from the blackboard. We will work with this."/>

        <!--Go over them again to sort them. But check the distance from the ships current cluster so that nearer clusters are prefered-->
        <do_all exact="$buyclusters.count" counter="$Counter">
          <append_to_list name="$buyclustersdistances" exact="$buyclusters.{$Counter}.gatedistance.{this.ship.zone}"/>
        </do_all>

        <debug_text text="'check if $checkrange is in buy range ' + $checkrange" chance="$debugchance2" comment="temp"/>
        <do_if value="not $checkrange.exists">
          <set_value name="$checkrange" exact="this.ship.zone"/>

          <!--Check if the current $checkrange (the ships current zone) is within the buy range. If so, look for offers, otherwise it will check again from $range-->
          <debug_text text="'$range is ' + $range.knownname" chance="$debugchance2" comment="temp"/>
          <set_value name="$GateDistance" exact="$checkrange.gatedistance.{$range}"/>
          <debug_text text="'buy range $GateDistance ' + $GateDistance" chance="$debugchance2" comment="temp"/>
          <set_value name="$ValidDistance" exact="true"/>
          <do_if value="$buyrange.{1} ge 0">
            <do_if value="$GateDistance lt $buyrange.{1}">
              <debug_text text="'outside min buy range'" chance="$debugchance2" />
              <set_value name="$ValidDistance" exact="false"/>
            </do_if>
          </do_if>
          <do_if value="$buyrange.{2} ge 0">
            <do_if value="$GateDistance gt $buyrange.{2}">
              <debug_text text="'outside max buy range'" chance="$debugchance2" />
              <set_value name="$ValidDistance" exact="false"/>
            </do_if>
          </do_if>
          <do_if value="not $ValidDistance">
            <debug_text text="player.age + ' The zone ' + $checkrange.knownname + ' is not within the ships range to buy things. Finding new buy area.'" chance="$debugchance" />
            <set_value name="$checkrange" exact="null" />
          </do_if>
        </do_if>
      </do_if>

      <label name="check buy range" />

      <do_if value="@$buyrange">
        <do_if value="not $checkrange.exists">
          <do_if value="$buyclusters.count">
            <set_value name="$Index" exact="$buyclustersdistances.indexof.{$buyclustersdistances.min}"/>
            <set_value name="$checkrange" exact="$buyclusters.{$Index}"/>
            <debug_text text="'range to buy wares is now ' + $checkrange.knownname" chance="$debugchance"/>
            <remove_value name="$buyclusters.{$Index}"/>
            <remove_value name="$buyclustersdistances.{$Index}"/>
          </do_if>
          <do_else>
            <resume label="finish" />
          </do_else>
        </do_if>
      </do_if>

      <label name="find sell offers" />

      <wait min="5s" max="15s" sinceversion="1" />

      <!-- if checkrange was a tempzone and no longer exists, better start clean -->
      <do_if value="not $checkrange.exists">
        <resume label="start" />
      </do_if>

      <do_if value="this.ship.cargo.free ge $minvolume">

        <do_if value="@this.$trade_failedfindruns" min="3">
          <!-- if we have not found a good trade run after 3 attempts, relax the rules -->
          <set_value name="$minvolume" exact="($minvolume / 2) + 1" comment="add 1 to make sure we don't end up with minamount == 0" />
          <debug_text text="'reducing minvolume to ' + $minvolume" chance="$debugchance" />
        </do_if>

        <!-- experimental: find builder ships in need and prefer buying what they need -->
        <do_if value="@$buildership_check">
          <find_buy_offer tradepartner="this.ship" space="$checkrange" result="$buildoffers" multiple="true">
            <match_buyer class="class.ship_xl" />
          </find_buy_offer>
          <do_if value="$buildoffers.count gt 0">
            <create_list name="$buildwarelist" />
            <do_all exact="$buildoffers.count" counter="$b">
              <do_if value="this.ship.cargo.{$buildoffers.{$b}.ware}.free ge $buildoffers.{$b}.minamount">
                <append_to_list name="$buildwarelist" exact="$buildoffers.{$b}.ware" />
              </do_if>
            </do_all>
            <do_if value="$buildwarelist.count gt 0">
              <set_value name="$warelist_backup" exact="$warelist" />
              <set_value name="$warelist" exact="$buildwarelist" />
              <set_value name="$selltobuildership" exact="true" />
              <remove_value name="$buildwarelist" />
              <debug_text text="'builder ship resource preference selects ware(s) to buy: ' + $warelist" chance="$debugchance" />
            </do_if>
          </do_if>
        </do_if>

        <!--Prefilter wares there are no space for-->
        <set_value name="$filteredwarelist" exact="[]"/>
        <do_all exact="$warelist.count" counter="$Counter">
          <do_if value="this.ship.cargo.{$warelist.{$Counter}}.free" min="this.ship.cargo.{$warelist.{$Counter}}.max / 10">
            <append_to_list name="$filteredwarelist" exact="$warelist.{$Counter}"/>
            <debug_text text="'has space for ' + $warelist.{$Counter}.name + '. can buy more'" chance="$debugchance"/>
          </do_if>
          <do_else>
            <debug_text text="'has too much ' + $warelist.{$Counter}.name + '. do not look to buy more'" chance="$debugchance"/>
          </do_else>
        </do_all>
        <!-- now check for good sell offers (if we still have space to buy stuff) -->
        <debug_text text="player.age + ' checking if we can buy cargo in ' + $checkrange.knownname" chance="$debugchance" />
        <set_value name="$selloffers" exact="[]"/>

        <!--If no $warelist was provided then just search with $filteredwarelist as an empty list to find all possible wares-->
        <do_if value="not $warelist.count or $filteredwarelist.count">
          <do_if value="$selltobuildership?">
            <find_sell_offer tradepartner="this.ship" space="$checkrange" result="$selloffers" wares="$filteredwarelist" multiple="true">
              <totalvolume min="$minvolume" comment="we check minvolume even for the buildership trades to give smaller (faster) ships an advantage" />
            </find_sell_offer>
            <debug_text text="player.age + ' found %1 selloffers for buildership check'.[$selloffers.count]" chance="$debugchance" />
          </do_if>
          <do_else>
            <find_sell_offer tradepartner="this.ship" space="$checkrange" result="$selloffers" wares="$filteredwarelist" multiple="true">
              <totalvolume min="$minvolume" />
              <relativeprice max="0.999999f" comment="this effectively means the price must be below the average price to be considered" />
            </find_sell_offer>
            <debug_text text="player.age + ' found %1 selloffers for regular check'.[$selloffers.count]" chance="$debugchance" />
          </do_else>
        </do_if>

        <do_if value="$selloffers.count">
          <!--List all wares of the found trades so we can search for buy offers in our sell range. This prevents the ship buying wares it can't sell-->
          <set_value name="$soldwares" exact="[]"/>
          <set_value name="$tradablewares" exact="[]"/>
          <set_value name="$bestbuyoffers" exact="[]"/>
          <do_all exact="$selloffers.count" counter="$Counter" reverse="true">
            <do_if value="@$lasttrade and $lasttrade.{1} and $lasttrade.{2} == $selloffers.{$Counter}.ware and $lasttrade.{3} == $selloffers.{$Counter}.seller">
              <!-- the last thing we did was sell this ware to the seller, don't buy it back immediately! -->
              <debug_text text="'we just sold %1 to %2 (%3), don\'t try to buy it right back!'.[$lasttrade.{2}, $lasttrade.{3}.knownname, $lasttrade.{3}]" chance="$debugchance2"/>
              <remove_value name="$selloffers.{$Counter}"/>
              <continue />
            </do_if>
            <do_if value="not $soldwares.indexof.{$selloffers.{$Counter}.ware}">
              <append_to_list name="$soldwares" exact="$selloffers.{$Counter}.ware"/>
            </do_if>
          </do_all>
          <!--Check for buy offers of clusters within the $sellrange-->
          <do_if value="@$sellrange">
            <set_value name="$sellclusters" exact="this.$traderange_sellclusters.clone" comment="Copy the list from the blackboard. We will work with this."/>

            <do_all exact="$sellclusters.count" counter="$Counter">
              <find_buy_offer tradepartner="this.ship" wares="$soldwares" space="$sellclusters.{$Counter}" result="$buyoffers" multiple="true">
                <totalvolume min="$minvolume" />
              </find_buy_offer>
              <sort_trades name="$buyoffers" tradelist="$buyoffers" sorter="relativeprice"/>
              <do_all exact="$buyoffers.count" counter="$Counter2" reverse="true">
                <do_if value="@$lasttrade and (not $lasttrade.{1}) and $lasttrade.{2} == $buyoffers.{$Counter2}.ware and $lasttrade.{3} == $buyoffers.{$Counter2}.buyer">
                  <!-- the last thing we did was buy this ware from the buyer, don't sell it back immediately! -->
                  <debug_text text="'we just bought %1 from %2 (%3), don\'t try to sell it right back!'.[$lasttrade.{2}, $lasttrade.{3}.knownname, $lasttrade.{3}]" chance="$debugchance2"/>
                  <continue />
                </do_if>
                <do_if value="not $tradablewares.indexof.{$buyoffers.{$Counter2}.ware}">
                  <append_to_list name="$tradablewares" exact="$buyoffers.{$Counter2}.ware"/>
                  <append_to_list name="$bestbuyoffers" exact="$buyoffers.{$Counter2}"/>
                  <do_if value="$soldwares.count == $tradablewares.count">
                    <break/>
                  </do_if>
                </do_if>
              </do_all>
              <do_if value="$soldwares.count == $tradablewares.count">
                <break/>
              </do_if>
            </do_all>
          </do_if>
          <!--Check for buy offers within $range-->
          <do_else>
            <debug_text text="'soldwares: %1, range: %2, class: %3, minvolume: %4, tradeablewares: %5'.[$soldwares, $range.knownname, $range.class, $minvolume, $tradablewares]" chance="$debugchance2" />
            <find_buy_offer tradepartner="this.ship" wares="$soldwares" space="$range" result="$buyoffers" multiple="true">
              <totalvolume min="$minvolume" />
            </find_buy_offer>
            <!-- we prefer to use offers where selling above agerage price is possible, try those first but use a random one -->
            <create_list name="$preferredoffers" />
            <do_all exact="$buyoffers.count" counter="$Counter" reverse="true">
              <do_if value="$buyoffers.{$Counter}.relativeprice gt 1.0f">
                <append_to_list name="$preferredoffers" exact="$buyoffers.{$Counter}" />
              </do_if>
              <do_else>
                <break />
              </do_else>
            </do_all>
            <do_if value="$preferredoffers.count == 0">
              <set_value name="$preferredoffers" exact="$buyoffers" />
            </do_if>
            <do_all exact="$preferredoffers.count">
              <set_value name="$Counter" min="1" max="$preferredoffers.count" />
              <do_if value="@$lasttrade and (not $lasttrade.{1}) and $lasttrade.{2} == $preferredoffers.{$Counter}.ware and $lasttrade.{3} == $preferredoffers.{$Counter}.buyer">
                <!-- the last thing we did was buy this ware from the buyer, don't sell it back immediately! -->
                <debug_text text="'we just bought %1 from %2 (%3), don\'t try to sell it right back!'.[$lasttrade.{2}, $lasttrade.{3}.knownname, $lasttrade.{3}]" chance="$debugchance2"/>
                <continue />
              </do_if>
              <debug_text text="'%1(%2) is buying %3 %4'.[$preferredoffers.{$Counter}.buyer.knownname, $preferredoffers.{$Counter}.buyer, $preferredoffers.{$Counter}.offeramount.{this}, $preferredoffers.{$Counter}.ware]" chance="$debugchance2" />
              <do_if value="not $tradablewares.indexof.{$preferredoffers.{$Counter}.ware}">
                <debug_text text="'adding to list of tradeablewares'" chance="$debugchance2" />
                <append_to_list name="$tradablewares" exact="$preferredoffers.{$Counter}.ware"/>
                <append_to_list name="$bestbuyoffers" exact="$preferredoffers.{$Counter}"/>
                <do_if value="$soldwares.count == $tradablewares.count">
                  <break/>
                </do_if>
              </do_if>
              <remove_value name="$preferredoffers.{$Counter}" />
            </do_all>
          </do_else>
          <!--<do_all exact="$bestbuyoffers.count" counter="$Counter">
            <debug_text text="$bestbuyoffers.{$Counter} + ' adjustment:' + $bestbuyoffers.{$Counter}.relativeprice + ' - ' + $bestbuyoffers.{$Counter}.ware + ' ' + $bestbuyoffers.{$Counter}.offeramount.{this} + ' ' + $bestbuyoffers.{$Counter}.buyer.macro + ' ' + $bestbuyoffers.{$Counter}.buyer.zone.macro"/>
          </do_all>-->
          <debug_text text="'wares which can be bought and sold in range are: ' + $tradablewares" chance="$debugchance2"/>

          <do_all exact="$selloffers.count">
            <set_value name="$currentoffer" exact="null"/>
            <do_if value="@$tradablewares.count" min="3">
              <!--Iterate a few times to see if there is a sell offer for one of the most needed wares-->
              <do_all exact="$tradablewares.count" counter="$Counter">
                <set_value name="$tradablewares_index" min="1" max="$tradablewares.count" profile="decreasing" scale="3"/>
                <set_value name="$randomselloffer" exact="null"/>
                <do_all exact="$selloffers.count">
                  <do_if value="not $selloffers.count">
                    <break />
                  </do_if>
                  <set_value name="$randomselloffer" exact="$selloffers.random"/>
                  <do_if value="not $randomselloffer.available">
                    <!-- during the <wait /> in the outer <do_all /> the offer may have become invalid -->
                    <remove_value name="$selloffers.{$selloffers.indexof.{$randomselloffer}}" />
                    <continue />
                  </do_if>
                  <do_if value="$randomselloffer.ware" exact="$tradablewares.{$tradablewares_index}">
                    <set_value name="$currentoffer" exact="$randomselloffer" />
                    <remove_value name="$selloffers.{$selloffers.indexof.{$currentoffer}}" />
                    <debug_text text="$tradablewares.{$tradablewares_index} + ' may be a well needed resource.'" chance="$debugchance2"/>
                    <break/>
                  </do_if>
                </do_all>
                <remove_value name="$randomselloffer"/>
                <do_if value="$currentoffer">
                  <break/>
                </do_if>
                <do_elseif value="$Counter" min="3">
                  <break/>
                </do_elseif>
              </do_all>
            </do_if>

            <do_if value="(not $currentoffer) and $selloffers.count">
              <set_value name="$currentoffer" exact="$selloffers.random" />
              <remove_value name="$selloffers.{$selloffers.indexof.{$currentoffer}}" />
            </do_if>

            <do_if value="$tradablewares? and $currentoffer.available">
              <do_if value="not $tradablewares.indexof.{$currentoffer.ware}">
                <debug_text text="'There is nowhere to currently sell ' + $currentoffer.ware.name + ' in our sell range. Skipping'" chance="$debugchance2"/>
                <continue/>
              </do_if>
            </do_if>

            <do_if value="$currentoffer.available">
              <!-- do not reserve certain wares (otherwise they can't be dispatched fast enough) -->
              <set_value name="$reservableware" exact="true" />
              <do_if value="$currentoffer.ware == ware.bofu or $currentoffer.ware == ware.energycells or $currentoffer.ware == ware.foodrations or $currentoffer.ware == ware.water">
                <debug_text text="$currentoffer.ware + ' must not be reserved'" chance="$debugchance" />
                <set_value name="$reservableware" exact="false" />
              </do_if>
              <!-- check the trade owner's blackboard for whether someone already expressed interest in this trade offer -->
              <do_if value="$reservetrades and $reservableware">
                <debug_text text="'checking if trade ' + $currentoffer + ' is reserved'" chance="$debugchance" />
                <set_value name="$reserved" exact="false" />
                <do_if value="$currentoffer.seller.tradenpc.$reservedtrades?">
                  <debug_text text="$currentoffer.seller.tradenpc.$reservedtrades.count + ' trades reserved already'" chance="$debugchance" />
                  <do_all exact="$currentoffer.seller.tradenpc.$reservedtrades.count" counter="$j" reverse="true">
                    <do_if value="not $currentoffer.seller.tradenpc.$reservedtrades.{$j}.available">
                      <!-- garbage collect unavailable reserved trades -->
                      <debug_text text="'purging unavailable reserved trade at index ' + $j" chance="$debugchance" />
                      <remove_value name="$currentoffer.seller.tradenpc.$reservedtrades.{$j}" />
                      <continue />
                    </do_if>
                    <debug_text text="'checking against trade ' + $currentoffer.seller.tradenpc.$reservedtrades.{$j}" chance="$debugchance" />
                    <do_if value="$currentoffer.seller.tradenpc.$reservedtrades.{$j} == $currentoffer">
                      <set_value name="$reserved" exact="true" />
                      <debug_text text="'trade ' + $currentoffer + ' is reserved'" chance="$debugchance" />
                    </do_if>
                  </do_all>
                </do_if>
                <do_if value="not $reserved">
                  <debug_text text="'reserving trade ' + $currentoffer" chance="$debugchance" />
                  <do_if value="$currentoffer.seller.tradenpc.$reservedtrades?">
                    <append_to_list name="$currentoffer.seller.tradenpc.$reservedtrades" exact="$currentoffer" />
                  </do_if>
                  <do_else>
                    <set_value name="$currentoffer.seller.tradenpc.$reservedtrades" exact="[$currentoffer]" />
                  </do_else>
                  <set_value name="$selloffer" exact="$currentoffer" />
                  <break />
                </do_if>
              </do_if>
              <do_else>
                <set_value name="$selloffer" exact="$currentoffer" />
                <break />
              </do_else>
            </do_if>
            <wait min="500ms" max="3s" sinceversion="1" />
            <!-- if we saved in this part, clean up i and the previously tried entries -->
            <do_if value="$i?">
              <do_all exact="$i" counter="$j" reverse="true">
                <remove_value name="$selloffers.{$j}" />
              </do_all>
              <remove_value name="$i" />
            </do_if>
            <do_if value="$selloffers.count == 0">
              <break />
            </do_if>
          </do_all>
        </do_if>

        <do_if value="$selloffer.exists">
          <do_if value="$bestbuyoffers?">
            <do_all exact="$bestbuyoffers.count" counter="$Counter">
              <set_value name="$checkoffer" exact="$bestbuyoffers.{$Counter}" />
              <do_if value="$checkoffer.available">
                <do_if value="$checkoffer.ware" exact="$selloffer.ware">
                  <do_if value="$checkoffer.buyer == $selloffer.seller">
                    <!-- skip offers where buyer and seller are the same! -->
                    <debug_text text="'skipping self-trade of %1 with %2'.[$checkoffer.ware, $checkoffer.buyer]" chance="$debugchance" />
                    <continue />
                  </do_if>
                  <do_if value="not $selltobuildership?">
                    <do_if value="$checkoffer.buyer.zone == $selloffer.seller.zone" chance="75">
                      <!-- chance to skip offers where buyer and seller are in the same zone, because station<->station trade is already taking care of mose of the transport here -->
                      <continue />
                    </do_if>
                    <!-- check if there is profit in this trip at all -->
                    <set_value name="$checkamount" exact="$selloffer.offeramount.{this}" />
                    <do_if value="$checkamount gt this.ship.cargo.{$selloffer.ware}.free">
                      <set_value name="$checkamount" exact="this.ship.cargo.{$selloffer.ware}.free" />
                    </do_if>
                    <do_if value="$checkamount gt $checkoffer.offeramount.{this}">
                      <set_value name="$checkamount" exact="$checkoffer.offeramount.{this}" />
                    </do_if>
                    <!-- jump cost for ships without jumpdrive will be 0 -->
                    <get_jump_cost ship="this.ship" start="this.sector" end="$selloffer.seller.sector" result="$trip1" />
                    <get_jump_cost ship="this.ship" start="$selloffer.seller.sector" end="$checkoffer.buyer.sector" result="$trip2" />
                    <set_value name="$fuelcost" exact="($trip1 + $trip2) * ware.fuelcells.averageprice" />
                    <set_value name="$profit" exact="($checkoffer.unitprice - $selloffer.unitprice) * $checkamount" />
                    <debug_text text="'trip to buy %1 %2 at %3(%4) and sell to %5(%6) has potential profit of %7 Cr and costs %8 Cr. real profit: %9 Cr.'.[$checkamount, $checkoffer.ware, $selloffer.seller.knownname, $selloffer.seller, $checkoffer.buyer.knownname, $checkoffer.buyer, $profit/1Cr, $fuelcost/1Cr, ($profit - $fuelcost)/1Cr]" chance="$debugchance" />
                    <do_if value="$fuelcost ge ($profit - ($selloffer.unitprice * $checkamount * 0.02f))">
                      <!-- if we don't make at least 2% of the ware price after expenses, this isn't worth our time -->
                      <debug_text text="'skip buy offer, reason: %1, %2, %3, %4 => %5'.[$fuelcost, $profit, $selloffer.unitprice, $checkamount, ($profit - ($selloffer.unitprice * $checkamount * 0.02f))]" chance="$debugchance" />
                      <continue />
                    </do_if>
                  </do_if>
                  <set_value name="$buyoffer" exact="$checkoffer"/>
                  <break/>
                </do_if>
              </do_if>
            </do_all>
          </do_if>
          <remove_value name="$checkoffer" />

          <debug_text text="player.age + ' sell offer found!'" chance="$debugchance" />
          <resume label="finish" />
        </do_if>
      </do_if>

      <do_if value="@$sellrange">
        <set_value name="$checkrange" exact="null" />
        <resume label="check buy range"/>
      </do_if>

      <do_if value="$checkrange == this.ship.zone and $checkrange != $range">
        <!-- check again, but this time in the full range -->
        <set_value name="$checkrange" exact="$range" />
        <set_value name="$idletime" min="20s" max="60s"/>
        <run_script name="'move.idle.vanilla40'" sinceversion="1">
          <param name="TimeOut" value="$idletime" />
        </run_script>
        <resume label="find trade run" />
      </do_if>

      <do_if value="$selltobuildership? or @$buildership_check">
        <set_value name="$buildership_check" exact="false" />
        <do_if value="@$warelist_backup">
          <set_value name="$warelist" exact="$warelist_backup" />
        </do_if>
        <remove_value name="$selltobuildership" />
        <resume label="find sell offers" />
      </do_if>

      <!-- can't find anything good at the moment... wait a while, then check again -->
      <debug_text text="player.age + ' no good trade offer found, waiting for a while before checking again'" chance="$debugchance" />
      <debug_text text="player.age + ' no good trade offer found. \'%1\'(job: \'%5\'), looking for offers in \'%2\', warelist: \'%3\', cargo: \'%4\''.[this.ship.knownname, $checkrange.knownname, $warelist, this.ship.cargo.list, this.ship.job]" chance="$debugchance2" />
      <set_value name="this.$trade_failedfindruns" operation="add"/>
      <set_value name="$idletime" min="30s" max="90s"/>
      <run_script name="'move.idle.vanilla40'" sinceversion="1">
        <param name="TimeOut" value="$idletime" />
      </run_script>
      <resume label="start" />

      <label name="finish" />
      <do_if value="$buyoffer.exists and $selloffer.exists">
        <debug_text text="player.age + ' Traderun found for [' + this.ship + '] ' + this.ship.knownname + ' in ' + this.ship.sector.knownname" chance="$debugchance"/>
        <debug_text text="player.age + ' SELLOFFER INFO:\'%1\' sells %2 units of %3 for %4 Cr each; total price of %5 Cr.'.[$selloffer.seller.knownname, $selloffer.offeramount.{this}, $selloffer.ware.name, $selloffer.unitprice / 1Cr, $selloffer.price / 1Cr]" chance="$debugchance" />
        <debug_text text="player.age + ' BUYOFFER INFO:\'%1\' wants %2 units of %3 for %4 Cr each; total price of %5 Cr.'.[$buyoffer.buyer.knownname, $buyoffer.offeramount.{this}, $buyoffer.ware.name, $buyoffer.unitprice / 1Cr, $buyoffer.price / 1Cr]" chance="$debugchance" />
      </do_if>
      <do_else>
        <do_if value="$buyoffer.exists">
          <debug_text text="player.age + ' BUYOFFER INFO:\'%1\' wants %2 units of %3 for %4 Cr each; total price of %5 Cr.'.[$buyoffer.buyer.knownname, $buyoffer.offeramount.{this}, $buyoffer.ware.name, $buyoffer.unitprice / 1Cr, $buyoffer.price / 1Cr]" chance="$debugchance" />
        </do_if>
        <do_if value="$selloffer.exists">
          <debug_text text="player.age + ' SELLOFFER INFO:\'%1\' sells %2 units of %3 for %4 Cr each; total price of %5 Cr.'.[$selloffer.seller.knownname, $selloffer.offeramount.{this}, $selloffer.ware.name, $selloffer.unitprice / 1Cr, $selloffer.price / 1Cr]" chance="$debugchance" />
        </do_if>
      </do_else>

      <do_if value="@$findclusters">
        <!--In 30 minutes, allow repopulation of the cluster list-->
        <set_value name="this.$traderange_nexttime" exact="player.age + 30min"/>
        <debug_text text="player.age + ' - setting this.$traderange_nexttime to ' + this.$traderange_nexttime" chance="$debugchance2"/>
      </do_if>

      <!-- TODO: if we find that traders buy too much of a ware, only fill a fraction of the cargo space with any one ware, so that we'll still have space for others left (only if the basket contains more than one ware) -->
      <!--<set_value name="$totalcargospace" exact="this.ship.cargo.{$ware}.max" />
      <set_value name="$freecargospace" exact="this.ship.cargo.{$ware}.free" />
      <set_value name="$amount" />
      <debug_text text="'Amount that will be traded: ' + $amount" chance="$debugchance" />
      <retval name="amount" value="$amount" />-->

      <return>
        <retval name="buyoffer" value="$buyoffer" />
        <retval name="selloffer" value="$selloffer" />
      </return>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.findsimpletraderun.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <params>
    <param name="warelist" />
    <param name="range" />
    <param name="sellrange" default="null"/>
    <param name="buyrange" default="null"/>
    <param name="lasttrade" default="null" comment="list: [$buyoffer, $ware, $tradepartner]"/>
    <param name="debugchance" default="0"/>
    <param name="debugchance2" default="0" comment="more spammy"/>
  </params>
  <init>
    <set_command_action commandaction="commandaction.searchingtrades" />
  </init>
  <patch sinceversion="1">
    <set_value name="$buyoffer" exact="null" />
  </patch>
  <attention min="unknown">
    <actions>

      <!-- set up initial state for trade runs -->
      <label name="start" />
      <set_value name="$selloffer" exact="null" />
      <set_value name="$buyoffer" exact="null" />
      <set_value name="$currentcargo" exact="this.ship.cargo.list" />

      <!-- strip fuel cells for own need from the list -->
      <do_if value="not $warelist.indexof.{ware.fuelcells}">
        <set_value name="$fuelindex" exact="$currentcargo.indexof.{ware.fuelcells}" />
        <do_if value="$fuelindex">
          <remove_value name="$currentcargo.{$fuelindex}" />
        </do_if>
      </do_if>
      <do_else>
        <!-- TODO: fuel trade ship needs to keep some for own use and the rest for trading -->
      </do_else>

      <debug_text text="player.age + ' finding trade offer; range: ' + $range.knownname" chance="$debugchance" />
      <debug_text text="player.age + ' current cargo: ' + $currentcargo" chance="$debugchance" />

      <label name="find trade run" />

      <do_if value="$currentcargo.count gt 0 and this.ship.cargo.capacity gt 0 and (this.ship.cargo.free / this.ship.cargo.capacity) lt 0.20f">
        <debug_text text="player.age + ' look for buy offers'" chance="$debugchance" />
        <find_buy_offer tradepartner="this.ship" wares="$currentcargo" result="$buyoffer" space="$range">
          <stocklevel max="0.5f" />
        </find_buy_offer>
        <do_if value="$buyoffer.available">
          <debug_text text="player.age + ': sell to %1[%2] (max %3)'.[$buyoffer.buyer.knownname, $buyoffer.buyer, $buyoffer.offeramount.{this}]" chance="$debugchance" />
          <resume label="finish" />
        </do_if>
      </do_if>
      <do_else>
        <debug_text text="player.age + ' look for sell offers'" chance="$debugchance" />
        <find_sell_offer tradepartner="this.ship" wares="$warelist" result="$selloffers" multiple="true" space="$range">
          <stocklevel min="0.5f" />
        </find_sell_offer>
        <debug_text text="player.age + ': found %1 selloffers for wares %2 in %3'.[$selloffers.count, $warelist, $range]" chance="$debugchance" />
        <do_if value="$selloffers.count gt 0">
          <create_list name="$tradewareoffers" />
          <create_list name="$productionoffers" />
          <do_all exact="$selloffers.count" counter="$i">
            <set_value name="$currentoffer" exact="$selloffers.{$i}" />
            <do_if value="$currentoffer.available">
              <do_if value="@$lasttrade and $lasttrade.{1} and $lasttrade.{2} == $currentoffer.ware and $lasttrade.{3} == $currentoffer.seller">
                <!-- the last thing we did was sell this ware to the seller, don't buy it back immediately! -->
                <debug_text text="'we just sold %1 to %2 (%3), don\'t try to buy it right back!'.[$lasttrade.{2}, $lasttrade.{3}.knownname, $lasttrade.{3}]" chance="$debugchance2"/>
                <continue />
              </do_if>
              <do_if value="this.ship.cargo.{$currentoffer.ware}.free lt 1">
                <!-- if we have no space for this ware, skip the offer -->
                <continue />
              </do_if>
              <do_if value="$currentoffer.seller.tradewares.{$currentoffer.ware}.exists">
                <append_to_list name="$tradewareoffers" exact="$currentoffer" />
              </do_if>
              <do_else>
                <append_to_list name="$productionoffers" exact="$currentoffer" />
              </do_else>
            </do_if>
            <wait min="1s" max="3s"/>
          </do_all>
          <debug_text text="player.age + ': found %1 tradewareoffers and %2 productionoffers'.[$tradewareoffers.count, $productionoffers.count]" chance="$debugchance" />
          <do_if value="$tradewareoffers.count gt 0">
            <!-- ensure that the offers we are trying to use are still valid because they may have become unavailable during the wait! -->
            <set_value name="$offerindex" min="1" max="$tradewareoffers.count"/>
            <do_while value="$offerindex? and not $tradewareoffers.{$offerindex}.available">
              <remove_value name="$tradewareoffers.{$offerindex}"/>
              <do_if value="$tradewareoffers.count == 0">
                <remove_value name="$offerindex"/>
              </do_if>
              <do_else>
                <set_value name="$offerindex" min="1" max="$tradewareoffers.count"/>
              </do_else>
            </do_while>
            <do_if value="$offerindex?">
              <set_value name="$selloffer" exact="$tradewareoffers.{$offerindex}" />
              <resume label="finish" />
            </do_if>
          </do_if>
          <!-- if we haven't found a valid tradewareoffer, try productionoffers -->
          <do_if value="$productionoffers.count gt 0">
            <!-- ensure that the offers we are trying to use are still valid because they may have become unavailable during the wait! -->
            <set_value name="$offerindex" min="1" max="$productionoffers.count"/>
            <do_while value="$offerindex? and not $productionoffers.{$offerindex}.available">
              <remove_value name="$productionoffers.{$offerindex}"/>
              <do_if value="$productionoffers.count == 0">
                <remove_value name="$offerindex"/>
              </do_if>
              <do_else>
                <set_value name="$offerindex" min="1" max="$productionoffers.count"/>
              </do_else>
            </do_while>
            <do_if value="$offerindex?">
              <set_value name="$selloffer" exact="$productionoffers.{$offerindex}" />
              <set_value name="$ware" exact="$selloffer.ware"/>
              <debug_text text="player.age + ': %1[%2] buy %3 (max %4) from %5[%6]'.[this.ship.knownname, this.ship, $ware.name, $selloffer.offeramount.{this}, $selloffer.seller.knownname, $selloffer.seller]" chance="$debugchance" />
              <find_buy_offer tradepartner="this.ship" wares="$ware" result="$buyoffers" space="$range" multiple="true" />
              <do_all exact="$buyoffers.count" counter="$i" reverse="true">
                <do_if value="$buyoffers.{$i}.buyer == $selloffer.seller">
                  <!-- skip offers where buyer and seller are the same! -->
                  <remove_value name="$buyoffers.{$i}" />
                </do_if>
              </do_all>
              <do_if value="$buyoffers.count gt 0">
                <set_value name="$buyoffer" exact="$buyoffers.random"/>
              </do_if>
              <remove_value name="$buyoffers"/>
              <do_if value="$buyoffer.available">
                <debug_text text="player.age + ': sell to %1[%2] (max %3)'.[$buyoffer.buyer.knownname, $buyoffer.buyer, $buyoffer.offeramount.{this}]" chance="$debugchance" />
              </do_if>
              <remove_value name="$ware" />
              <resume label="finish" />
            </do_if>
          </do_if>
          <remove_value name="$tradewareoffers" />
          <remove_value name="$productionoffers" />
        </do_if>
      </do_else>

      <!-- can't find anything good at the moment... wait a while, then check again -->
      <debug_text text="player.age + ' no good trade offer found, waiting for a while before checking again'" chance="$debugchance" />
      <debug_text text="player.age + ' no good trade offer found. \'%1\'(job: \'%3\'), selloffers: \'%2\''.[this.ship.knownname, @$selloffers, this.ship.job]" chance="$debugchance2" />

      <!-- if we haven't found any suitable tradeoffer travel to another random zone in the range before trying again -->
      <do_if value="(not $range.isclass.zone) and (not this.ship.isplayerowned)">
        <find_zone name="$idlezone" space="$range" priorityzone="true" tempzone="false">
          <match macro="this.zone.macro" negate="true" />
        </find_zone>
        <do_if value="$idlezone.exists">
          <run_script name="'move.generic.vanilla40'">
            <param name="destination" value="$idlezone" />
            <param name="debugchance" value="$debugchance" />
          </run_script>
        </do_if>
      </do_if>

      <set_value name="$idletime" min="30s" max="90s"/>
      <run_script name="'move.idle.vanilla40'">
        <param name="TimeOut" value="$idletime" />
      </run_script>
      <resume label="start" />

      <label name="finish" />
      <do_if value="$selloffer.exists">
        <debug_text text="player.age + ' SELLOFFER INFO:\n\'%1\' sells %2 units of %3 for a total price of %4 Cr.'.[$selloffer.seller.knownname, $selloffer.offeramount.{this}, $selloffer.ware.name, $selloffer.price]" chance="$debugchance" />
      </do_if>

      <!-- TODO: if we find that traders buy too much of a ware, only fill a fraction of the cargo space with any one ware, so that we'll still have space for others left (only if the basket contains more than one ware) -->
      <!--<set_value name="$totalcargospace" exact="this.ship.cargo.{$ware}.max" />
      <set_value name="$freecargospace" exact="this.ship.cargo.{$ware}.free" />
      <set_value name="$amount" />
      <debug_text text="'Amount that will be traded: ' + $amount" chance="$debugchance" />
      <retval name="amount" value="$amount" />-->

      <return>
        <retval name="buyoffer" value="$buyoffer" />
        <retval name="selloffer" value="$selloffer" />
      </return>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.findtraderun.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <params>
    <param name="warelist" />
    <param name="range" />
    <!--TODO: Support sellrange and buyrange for station working trade ships-->
    <param name="sellrange" default="null" comment="TODO"/>
    <param name="buyrange" default="null" comment="TODO"/>
    <param name="lasttrade" default="null" comment="list: [$buyoffer, $ware, $tradepartner]"/>
    <param name="debugchance" default="0"/>
    <param name="debugchance2" default="0" comment="more spammy"/>
  </params>
  <init>
    <set_command_action commandaction="commandaction.searchingtrades" />
  </init>
  <attention min="unknown">
    <actions>

      <!-- set up initial state for trade runs -->
      <label name="start" />
      <set_value name="$buyoffer" exact="null" />
      <set_value name="$selloffer" exact="null" />
      <set_value name="$currentcargo" exact="this.ship.cargo.list" />

      <!-- strip fuel cells for own need from the list -->
      <do_if value="not $warelist.indexof.{ware.fuelcells}">
        <set_value name="$fuelindex" exact="$currentcargo.indexof.{ware.fuelcells}" />
        <do_if value="$fuelindex">
          <remove_value name="$currentcargo.{$fuelindex}" />
        </do_if>
      </do_if>
      <do_else>
        <!-- TODO: fuel trade ship needs to keep some for own use and the rest for trading -->
      </do_else>

      <debug_text text="player.age + ' finding trade offer; range: ' + $range.knownname" chance="$debugchance" />
      <debug_text text="player.age + ' current cargo: ' + $currentcargo" chance="$debugchance" />
      <debug_text text="player.age + ' commander: ' + this.ship.commander.knownname" chance="$debugchance" />

      <label name="find trade run" />
      <!-- try to find a buy offer for wares in our cargo first -->
      <do_if value="$currentcargo.count gt 0">
        <!-- in case it was resources for our station, wait until we can deliver them -->
        <debug_text text="player.age + ' checking if we can sell our current cargo to our homebase'" chance="$debugchance" />
        <find_buy_offer tradepartner="this.ship" buyer="this.ship.commander" wares="$currentcargo" result="$buyoffer">
          <amount min="1" />
        </find_buy_offer>
        <do_if value="$buyoffer.available">
          <debug_text text="'we have cargo on board that our homebase needs: %1 in %2 needs %3 %4'.[$buyoffer.buyer.knownname, $buyoffer.buyer.zone.knownname, $buyoffer.offeramount.{this}, $buyoffer.ware.name]" chance="$debugchance"/>
          <resume label="finish" />
        </do_if>
        <do_else>
          <!-- in case it was wares that our homebase does not need, shop around the range to find another buyer -->
          <!-- find a buy offer that matches our cargo, proceeds will now go to our new commander -->
          <debug_text text="player.age + ' checking if we can sell our current cargo somewhere else'" chance="$debugchance" />
          <do_all exact="2" counter="$pass">
            <do_all exact="$currentcargo.count" counter="$i" reverse="1">
              <set_value name="$currentware" exact="$currentcargo.{$i}" />
              <do_if value="this.ship.commander.resources.{$currentware}.exists">
                <!-- don't sell potential resources for our homebase to someone else, just keep them. We will be able to deliver them later -->
                <remove_value name="$currentcargo.{$i}"/>
                <continue />
              </do_if>

              <do_if value="$pass == 1">
                <do_if value="this.ship.commander.istraderestricted.{$currentware}">
                  <find_buy_offer tradepartner="this.ship" wares="$currentware" space="$range" result="$buyoffer">
                    <match_buyer class="class.ship_xl" owner="this.ship.commander.owner" comment="try and find/prefer build platforms" />
                  </find_buy_offer>
                </do_if>
                <do_else>
                  <find_buy_offer tradepartner="this.ship" wares="$currentware" space="$range" result="$buyoffer" >
                    <match_buyer class="class.ship_xl" comment="try and find/prefer build platforms" />
                  </find_buy_offer>
                </do_else>
                <do_if value="$buyoffer.exists">
                  <debug_text text="'builder ship trade run found: %1 in %2 needs %3 %4'.[$buyoffer.buyer.knownname, $buyoffer.buyer.zone.knownname, $buyoffer.offeramount.{this}, $buyoffer.ware.name]" chance="$debugchance"/>
                  <resume label="finish" />
                </do_if>
                <wait min="3s" max="5s" sinceversion="1"/>
              </do_if>
              <do_else>
                <do_if value="this.ship.commander.istraderestricted.{$currentware}">
                  <!-- if we are only allowed to sell to our own faction anyway, ignore the price -->
                  <find_buy_offer tradepartner="this.ship" wares="$currentware" space="$range" result="$buyoffers" multiple="true">
                    <match_buyer owner="this.ship.commander.owner">
                      <match negate="true" class="class.ship_xl" />
                    </match_buyer>
                    <offeramount min="this.ship.cargo.{$currentware}.count * 0.25f" entity="this" />
                  </find_buy_offer>
                </do_if>
                <do_else>
                  <set_value name="$minbuyprice" exact="$currentware.minprice" />
                  <do_if value="this.ship.commander.products.{$currentware}.exists">
                    <find_sell_offer seller="this.ship.commander" wares="$currentware" result="$homebaseselloffer">
                      <amount min="1" />
                    </find_sell_offer>
                    <do_if value="$homebaseselloffer.available">
                      <!-- we don't want to make a loss when selling off products from our homebase, otherwise just try and dump the goods -->
                      <set_value name="$minbuyprice" exact="$homebaseselloffer.unitprice" />
                    </do_if>
                    <do_else>
                      <set_value name="$minbuyprice" exact="$currentware.averageprice" />
                    </do_else>
                  </do_if>
                  <find_buy_offer tradepartner="this.ship" wares="$currentware" space="$range" result="$buyoffers" multiple="true">
                    <match_buyer>
                      <match negate="true" class="class.ship_xl" />
                    </match_buyer>
                    <offeramount min="this.ship.cargo.{$currentware}.count * 0.25f" entity="this" />
                    <price min="$minbuyprice" />
                  </find_buy_offer>
                  <remove_value name="$minbuyprice" />
                </do_else>
                <debug_text text="player.age + ' found %1 buyoffers for at least %2 %3 in %4'.[$buyoffers.count, this.ship.cargo.{$currentware}.count * 0.25f, $currentware, $range.knownname]" chance="$debugchance" />
                <set_value name="$buyoffer" exact="null" />
                <do_while value="$buyoffers.count gt 0">
                  <set_value name="$buyidx" min="1" max="$buyoffers.count" />
                  <set_value name="$buyoffer" exact="$buyoffers.{$buyidx}" />
                  <do_if value="$buyoffer.buyer.owner == this.owner">
                    <!-- slight bias towards selling to same faction -->
                    <break />
                  </do_if>
                  <remove_value name="$buyoffers.{$buyidx}" />
                </do_while>
                <do_if value="$buyoffer.exists">
                  <debug_text text="'we have cargo on board that our homebase does not need, but we can sell it in the allowed range: %1 in %2 needs %3 %4'.[$buyoffer.buyer.knownname, $buyoffer.buyer.zone.knownname, $buyoffer.offeramount.{this}, $buyoffer.ware.name]" chance="$debugchance"/>
                  <resume label="finish" />
                </do_if>
                <wait min="10s" max="20s" sinceversion="1"/>
              </do_else>
            </do_all>
          </do_all>
        </do_else>
      </do_if>

      <!-- update the wares we deal with for a new trade run - ensure that we don't miss any wares if the list has changed due to the homebase being expanded -->
      <do_if value="this.ship.commander.isoperational">
        <set_value name="$homebase" exact="this.ship.commander" />
        <set_value name="$resources" exact="$homebase.resources.list" />
        <set_value name="$products" exact="$homebase.products.list" />
        <set_value name="$tradewares" exact="$homebase.tradewares.list" />
        <evaluate_ammo_storage object="$homebase" wares="$ammowares" type="missile" />
        <do_all exact="$resources.count" counter="$i">
          <set_value name="$ware" exact="$resources.{$i}" />
          <do_if value="this.ship.cargo.{$ware}.max gt 0">
            <do_if value="$warelist.indexof.{$ware}" exact="0">
              <append_to_list name="$warelist" exact="$ware" />
            </do_if>
          </do_if>
        </do_all>
        <do_all exact="$products.count" counter="$i">
          <set_value name="$ware" exact="$products.{$i}" />
          <do_if value="this.ship.cargo.{$ware}.max gt 0">
            <do_if value="$warelist.indexof.{$ware}" exact="0">
              <append_to_list name="$warelist" exact="$ware" />
            </do_if>
          </do_if>
        </do_all>
        <do_all exact="$tradewares.count" counter="$i">
          <set_value name="$ware" exact="$tradewares.{$i}" />
          <do_if value="this.ship.cargo.{$ware}.max gt 0">
            <do_if value="$warelist.indexof.{$ware}" exact="0">
              <append_to_list name="$warelist" exact="$ware" />
            </do_if>
          </do_if>
        </do_all>        
        <do_all exact="$ammowares.count" counter="$i">
          <set_value name="$ware" exact="$ammowares.{$i}" />
          <do_if value="this.ship.cargo.{$ware}.max gt 0">
            <do_if value="$warelist.indexof.{$ware}" exact="0">
              <append_to_list name="$warelist" exact="$ware" />
            </do_if>
          </do_if>
        </do_all>

        <debug_text text="'updating warelist on %1(%2) to transport %3'.[this.ship.knownname, this.ship, $warelist]" chance="$debugchance" />
        <remove_value name="$homebase" />
        <remove_value name="$ammowares" />
        <remove_value name="$tradewares" />
        <remove_value name="$products" />
        <remove_value name="$resources" />
        <remove_value name="$ware" />
      </do_if>

      <debug_text text="player.age + ' checking if we can sell products from our station somewhere'" chance="$debugchance" />
      <do_if value="this.ship.isplayerowned">
        <find_sell_offer tradepartner="this.ship" seller="this.ship.commander" wares="$warelist" result="$selloffers" multiple="true">
          <relativeprice max="0.999999f" comment="this effectively means the price must be below the average price to be considered" />
          <amount min="1" />
        </find_sell_offer>
      </do_if>
      <do_else>
        <find_sell_offer tradepartner="this.ship" seller="this.ship.commander" wares="$warelist" result="$selloffers" multiple="true">
          <amount min="1" />
        </find_sell_offer>
      </do_else>
      <do_if value="$selloffers.count gt 0">
        <!-- find a buy offer that matches one of our sell offers -->
        <!-- try to sell off the wares that we have the most of first, sort by relativeprice to avoid weirdness with intermediate wares -->
        <sort_trades name="$selloffers" tradelist="$selloffers" sorter="relativeprice" />
        <do_all exact="2" counter="$pass">
          <do_all exact="$selloffers.count" counter="$i">
            <do_if value="$selloffers.{$i}.available">
              <do_if value="@$lasttrade and $lasttrade.{1} and $lasttrade.{2} == $selloffers.{$i}.ware and $lasttrade.{3} == $selloffers.{$i}.seller">
                <!-- the last thing we did was sell this ware to our homebase, don't buy it back immediately! -->
                <debug_text text="'we just sold %1 to homebase %2 (%3), don\'t try to buy it right back!'.[$lasttrade.{2}, $lasttrade.{3}.knownname, $lasttrade.{3}]" chance="$debugchance2"/>
                <continue />
              </do_if>

              <do_if value="$pass == 1">
                <do_if value="@$selloffers.{$i}.restriction.faction">
                  <!-- if there is a faction restriction for this ware, don't look for buyers of a different faction! -->
                  <find_buy_offer tradepartner="this.ship" wares="$selloffers.{$i}.ware" space="$range" result="$buyoffer" >
                    <match_buyer class="class.ship_xl" owner="$selloffers.{$i}.restriction.faction" comment="try and find/prefer build platforms" />
                  </find_buy_offer>
                </do_if>
                <do_else>
                  <find_buy_offer tradepartner="this.ship" wares="$selloffers.{$i}.ware" space="$range" result="$buyoffer" >
                    <match_buyer class="class.ship_xl" comment="try and find/prefer build platforms" />
                  </find_buy_offer>
                </do_else>
                <do_if value="$buyoffer.exists">
                  <set_value name="$selloffer" exact="$selloffers.{$i}" />
                  <debug_text text="'builder ship trade run found: %1 in %2 needs %3 %4'.[$buyoffer.buyer.name, $buyoffer.buyer.zone.knownname, $buyoffer.offeramount.{this}, $buyoffer.ware.name]" chance="$debugchance"/>
                  <resume label="finish" />
                </do_if>
                <wait min="3s" max="5s"/>
              </do_if>
              <do_else>
                <do_if value="@$selloffers.{$i}.restriction.faction">
                  <!-- if there is a faction restriction for this ware, don't look for buyers of a different faction! -->
                  <find_buy_offer tradepartner="this.ship" wares="$selloffers.{$i}.ware" space="$range" result="$buyoffer" >
                    <match_buyer owner="$selloffers.{$i}.restriction.faction">
                      <match negate="true" class="class.ship_xl" />
                    </match_buyer>
                    <relativeprice min="1f" comment="this effectively means the price must be above the average price to be considered" />
                  </find_buy_offer>
                </do_if>
                <do_else>
                  <find_buy_offer tradepartner="this.ship" wares="$selloffers.{$i}.ware" space="$range" result="$buyoffer" >
                    <match_buyer>
                      <match negate="true" class="class.ship_xl" />
                    </match_buyer>
                    <relativeprice min="1f" comment="this effectively means the price must be above the average price to be considered" />
                  </find_buy_offer>
                </do_else>
                <do_if value="$buyoffer.exists">
                  <set_value name="$selloffer" exact="$selloffers.{$i}" />
                  <resume label="finish" />
                </do_if>
                <wait min="10s" max="20s"/>
              </do_else>
            </do_if>
          </do_all>
        </do_all>
      </do_if>

      <debug_text text="player.age + ' checking if we can buy resources for our station somewhere'" chance="$debugchance" />
      <find_buy_offer tradepartner="this.ship" buyer="this.ship.commander" wares="$warelist" result="$buyoffers" multiple="true">
        <amount min="1" />
      </find_buy_offer>
      <do_if value="$buyoffers.count gt 0">
        <!-- find a sell offer that matches one of our buy offers -->
        <!-- build table with priorities, making primary resources more "urgent" than secondaries or ammo offers -->
        <set_value name="$offertable" exact="table[]" />
        <do_all exact="$buyoffers.count" counter="$i">
          <set_value name="$offer" exact="$buyoffers.{$i}" />
          <do_if value="$offer.available">

            <do_if value="@$lasttrade and (not $lasttrade.{1}) and $lasttrade.{2} == $offer.ware and $lasttrade.{3} == $offer.buyer">
              <!-- the last thing we did was buy this ware from our homebase, don't sell it back immediately! -->
              <debug_text text="'we just bought %1 from homebase %2 (%3), don\'t try to sell it right back!'.[$lasttrade.{2}, $lasttrade.{3}.knownname, $lasttrade.{3}]" chance="$debugchance2"/>
              <continue />
            </do_if>

            <set_value name="$offertable.{$offer}" exact="$offer.stocklevel + (0.8 * this.ship.commander.resources.{$offer.ware}.primary)" />
          </do_if>
        </do_all>
        <!-- we now use the list of offers which has been sorted by the priority values -->
        <set_value name="$buyoffers" exact="$offertable.keys.sorted" />
        <!-- $table.keys.sorted gives us the listed sorted by values from lowest to highest, so we need to iterate in reverse -->
        <do_all exact="$buyoffers.count" counter="$i" reverse="true">
          <do_if value="@$buyoffers.{$i}.restriction.faction">
            <!-- if there is a faction restriction for this ware, don't look for sellers of a different faction! -->
            <find_sell_offer tradepartner="this.ship" wares="$buyoffers.{$i}.ware" space="$range" result="$selloffer">
              <match_seller owner="$buyoffers.{$i}.restriction.faction" />
            </find_sell_offer>
          </do_if>
          <do_else>
            <find_sell_offer tradepartner="this.ship" wares="$buyoffers.{$i}.ware" space="$range" result="$selloffer" />
          </do_else>
          <do_if value="$selloffer.exists">
            <set_value name="$buyoffer" exact="$buyoffers.{$i}" />
            <resume label="finish" />
          </do_if>
          <debug_text text="'waiting'" chance="$debugchance"/>
          <wait min="10s" max="20s"/>
        </do_all>
      </do_if>

      <!-- can't find anything good at the moment... wait a while, then check again -->
      <debug_text text="player.age + ' no good trade offer found, waiting for a while before checking again'" chance="$debugchance" />
      <debug_text text="player.age + ' no good trade offer found. \'%1\'(job: \'%5\'), commander: \'%2\', buyoffers: \'%3\', selloffers: \'%4\''.[this.ship.knownname, this.ship.commander.knownname, $buyoffers, $selloffers, this.ship.job]" chance="$debugchance2" />
      <do_if value="@this.ship.commanderentity.$config_subordinate_range">
        <do_if value="$range != this.ship.commanderentity.$config_subordinate_range">
          <set_value name="$range" exact="this.ship.commanderentity.$config_subordinate_range"/>
        </do_if>
      </do_if>
      <set_value name="$idletime" min="30s" max="90s"/>
      <run_script name="'move.idle.vanilla40'">
        <param name="TimeOut" value="$idletime" />
      </run_script>
      <resume label="start" />

      <label name="finish" />
      <do_if value="$buyoffer.exists">
        <debug_text text="player.age + ' BUYOFFER INFO:\n\'%1\' buys %2 (desires: %5) units of %3 for a total price of %4 Cr.'.[$buyoffer.buyer.knownname, $buyoffer.offeramount.{this}, $buyoffer.ware.name, $buyoffer.price/1Cr, $buyoffer.amount]" chance="$debugchance" />
      </do_if>
      <do_if value="$selloffer.exists">
        <debug_text text="player.age + ' SELLOFFER INFO:\n\'%1\' sells %2 units of %3 for a total price of %4 Cr.'.[$selloffer.seller.knownname, $selloffer.offeramount.{this}, $selloffer.ware.name, $selloffer.price/1Cr]" chance="$debugchance" />
      </do_if>

      <!-- TODO: if we find that traders buy too much of a ware, only fill a fraction of the cargo space with any one ware, so that we'll still have space for others left (only if the basket contains more than one ware) -->
      <!--<set_value name="$totalcargospace" exact="this.ship.cargo.{$ware}.max" />
      <set_value name="$freecargospace" exact="this.ship.cargo.{$ware}.free" />
      <set_value name="$amount" />
      <debug_text text="'Amount that will be traded: ' + $amount" chance="$debugchance" />
      <retval name="amount" value="$amount" />-->

      <return>
        <retval name="buyoffer" value="$buyoffer" />
        <retval name="selloffer" value="$selloffer" />
      </return>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1"?>
<aiscript xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="trade.performplayertraderun.vanilla40" xsi:noNamespaceSchemaLocation="aiscripts.xsd" priority="9" version="8">
	<params>
		<param name="debugchance" default="0"/>
	</params>
	<interrupts>
		<handler ref="AttackHandler.vanilla40"/>
	</interrupts>
	<init>
		<set_command_action commandaction="commandaction.searchingtrades"/>
	</init>
	<attention min="unknown">
		<actions>
			<!-- debugging -->
			<set_value name="$failreason" exact="''"/>
			<wait min="1s" max="2s" chance="0" comment="removed to set the command.trade immediately"/>
			<!-- debug information only -->
			<do_if value="$debugchance" exact="100">
				<get_trade_from_shoppinglist object="this.ship" result="$shoppinglist" multiple="true"/>
				<debug_text text="this.ship.knownname + ' has ' + $shoppinglist.count + ' entries on shopping list'" chance="$debugchance"/>
				<do_all exact="$shoppinglist.count" counter="$c">
					<set_value name="$tradeorder" exact="$shoppinglist.{$c}"/>
					<do_if value="$tradeorder.seller.exists">
						<debug_text text="'%1: buy %2 %3 from %4 for %5Cr (money virtual: %6)'.[$c, $tradeorder.amount, $tradeorder.ware, $tradeorder.seller.knownname, $tradeorder.price, $tradeorder.buyfree.{this}]" chance="$debugchance"/>
					</do_if>
					<do_else>
						<debug_text text="'%1: sell %2 %3 to %4 for %5Cr (money virtual: %6)'.[$c, $tradeorder.amount, $tradeorder.ware, $tradeorder.buyer.knownname, $tradeorder.price, $tradeorder.sellfree.{this}]" chance="$debugchance"/>
					</do_else>
				</do_all>
			</do_if>
			<!-- get top item from shopping list -->
			<label name="check shoppinglist"/>
			<remove_value name="$policefaction"/>
			<get_trade_from_shoppinglist object="this.ship" result="$shoppinglist" multiple="true"/>
			<do_if value="false">
				<!-- disabled for now -->
				<create_list name="$partnerschecked"/>
				<do_all exact="$shoppinglist.count" counter="$c">
					<set_value name="$tradeorder" exact="$shoppinglist.{$c}"/>
					<do_if value="not $tradeorder.ispassive.{this.ship}">
						<set_value name="$tradepartner" exact="if $tradeorder.seller.exists then $tradeorder.seller else $tradeorder.buyer"/>
						<do_if value="$partnerschecked.indexof.{$tradepartner} == 0">
							<remove_ware_reservation object="$tradepartner" entity="this"/>
							<remove_ware_reservation object="$tradepartner" entity="this" virtual="true"/>
							<remove_ware_reservation object="$tradepartner" entity="this" mission="true"/>
							<remove_ware_reservation object="$tradepartner" entity="this" virtual="true" mission="true"/>
							<append_to_list name="$partnerschecked" exact="$tradepartner"/>
						</do_if>
						<do_if value="$tradeorder.seller.exists">
							<!-- BUYING WARES -->
							<!-- note: it is possible that these reservations exceed the amount of goods available at the seller! -->
							<add_ware_reservation object="$tradeorder.seller" type="buy" ware="$tradeorder.ware" entity="this" amount="$tradeorder.amount" duration="1h + $c * 1h" mission="$tradeorder.ismission" virtual="$tradeorder.rebundle"/>
						</do_if>
						<do_else>
							<!-- SELLING WARES -->
							<add_ware_reservation object="$tradeorder.buyer" type="sell" ware="$tradeorder.ware" entity="this" amount="$tradeorder.amount" duration="1h + $c * 1h" mission="$tradeorder.ismission" virtual="$tradeorder.unbundle"/>
						</do_else>
					</do_if>
				</do_all>
			</do_if>
			<do_if value="$shoppinglist.count == 0">
				<resume label="finish"/>
			</do_if>
			<!-- now process the first item on the list -->
			<label name="process trade"/>
			<set_value name="$tradeorder" exact="$shoppinglist.{1}"/>
			<do_if value="not $tradeorder.exists">
				<!-- remove shoppinglist item, and check list again -->
				<remove_trade_order object="this.ship" trade="$tradeorder"/>
				<resume label="check shoppinglist"/>
			</do_if>
			<do_if value="$tradeorder.seller.isoperational">
				<set_value name="$targetobject" exact="$tradeorder.seller"/>
			</do_if>
			<do_elseif value="$tradeorder.buyer.isoperational">
				<set_value name="$targetobject" exact="$tradeorder.buyer"/>
			</do_elseif>
			<do_else>
				<!-- remove shoppinglist item, and check list again -->
				<set_value name="$failreason" exact="'ERR_TRADEPARTNER_DESTROYED'"/>
				<debug_text text="player.age + ' \'%1\' QUEUED TRADE RUN FAILED! Error: %2'.[this.ship.knownname, $failreason]" filter="error"/>
				<remove_trade_order object="this.ship" trade="$tradeorder"/>
				<resume label="check shoppinglist"/>
			</do_else>
			<!-- Correct partner if Ware Exchange -->
			<do_if value="$tradeorder.iswareexchange">
				<set_value name="$targetobject" exact="$tradeorder.exchangepartner.{this.ship}"/>
			</do_if>
			<!-- Update target object for Command Trade -->
			<set_command command="command.trade" param="$targetobject"/>
			<!-- Ware Exchange cases -->
			<do_if value="$tradeorder.iswareexchange and $targetobject.isclass.ship and not $targetobject.buildanchor.exists">
				<!-- Case involving small ships -->
				<do_if value="this.ship.isclass.[class.ship_s, class.ship_m] or $targetobject.isclass.[class.ship_s, class.ship_m]">
					<!-- we need to do the drop&collect routine rather than actual trade operations -->
					<run_script name="'move.wareexchange.vanilla40'" result="$exchangeresult" sinceversion="5">
						<param name="tradeorder" value="$tradeorder"/>
						<param name="target" value="$targetobject"/>
						<param name="debugchance" value="$debugchance"/>
					</run_script>
					<set_value name="$tradeorder" exact="null"/>
					<wait min="1s" max="5s" sinceversion="5"/>
					<resume label="check shoppinglist"/>
				</do_if>
				<!-- Capital ships: if this is a ware exchange trade where we are the passive party, go be passive -->
				<do_elseif value="$tradeorder.ispassive.{this.ship}">
					<resume label="passivetrade"/>
				</do_elseif>
			</do_if>
			<!-- move to the object that sells/buys our stuff -->
			<label name="move to target object"/>
			<do_if value="@this.ship.parkedat.container == $targetobject">
				<!-- skip the movement step if we are already there -->
				<resume label="check trade"/>
			</do_if>
			<!-- move to correct zone -->
			<do_if value="this.zone != $targetobject.zone">
				<run_script name="'move.generic.vanilla40'">
					<param name="destination" value="$targetobject"/>
					<param name="endintargetzone" value="true"/>
				</run_script>
			</do_if>
			<!-- Capital ships -->
			<do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
				<debug_text text="player.age + ' moving to park at ' + $targetobject.knownname" chance="$debugchance"/>
				<set_value name="$offer" exact="null"/>
				<!-- Ware Exchange Case: Active Partner -->
				<do_if value="$tradeorder.iswareexchange" comment="there is no point checking the offers on the target for ware exchange trades, there won't be any">
					<set_value name="$offer" exact="$tradeorder"/>
					<do_if value="$targetobject.isclass.ship">
						<do_if value="not $targetobject.buildanchor.exists" comment="treat deployed builder ships like stations">
							<debug_text text="'Me %1 (%2), target %3 (%4)'.[this, this.ship.knownname, $targetobject.pilot, $targetobject.knownname]"/>
							<!-- Wait for the passive trade to be ready  -->
							<do_if value="not @$targetobject.pilot.$readypassivetrade">
								<debug_text text="'wait for passive trader to be ready'" chance="$debugchance"/>
								<stop_moving object="this.ship"/>
								<set_command_action commandaction="commandaction.standingby"/>
								<wait max="1h" sinceversion="6">
									<interrupt>
										<conditions>
											<event_object_signalled object="this.ship" param="'wareexchange ready'" param2="$tradeorder"/>
										</conditions>
										<actions>
											<debug_text text="'passive trader is ready! He finished the movement'" chance="$debugchance"/>
										</actions>
									</interrupt>
								</wait>
							</do_if>
							<do_elseif value="$targetobject.pilot.$readypassivetrade">
								<debug_text text="'passive trader is ready!'" chance="$debugchance"/>
							</do_elseif>
						</do_if>
					</do_if>
				</do_if>
				<do_else>
					<do_if value="@$tradeorder.seller.isoperational">
						<debug_text text="'find sell offer on %1 for ware %2'.[$targetobject, $tradeorder.ware]" chance="$debugchance"/>
						<do_if value="$tradeorder.ismission">
							<find_sell_offer result="$offer" seller="$targetobject" wares="$tradeorder.ware" excludemissions="false" tradepartner="this.ship"/>
						</do_if>
						<do_else>
							<find_sell_offer result="$offer" seller="$targetobject" wares="$tradeorder.ware" tradepartner="this.ship"/>
						</do_else>
						<debug_text text="'found ' + $offer" chance="$debugchance"/>
					</do_if>
					<do_elseif value="@$tradeorder.buyer.isoperational">
						<debug_text text="'find buy offer on %1 for ware %2'.[$targetobject, $tradeorder.ware]" chance="$debugchance"/>
						<find_buy_offer result="$offer" buyer="$targetobject" wares="$tradeorder.ware" tradepartner="this.ship"/>
						<debug_text text="'found ' + $offer" chance="$debugchance"/>
					</do_elseif>
					<do_else>
						<debug_text text="player.age + ' tradepartner ' + $targetobject.knownname + ' is no longer operational'" chance="$debugchance"/>
						<resume label="check shoppinglist"/>
					</do_else>
					<do_if value="not $offer.available">
						<do_if value="$tradeorder.ismission">
							<debug_text text="'Its a mission with virtual cargo anyway so just fallback to any parking spot'" chance="$debugchance"/>
							<set_value name="$offer" exact="null"/>
						</do_if>
						<do_else>
							<debug_text text="player.age + ' tradeoffer on ' + $targetobject.knownname + ' not available'" chance="$debugchance"/>
							<!-- <do_if value="not $offer.exists">
            <remove_trade_order object="this.ship" trade="$tradeorder" />
            <resume label="check shoppinglist" />
          	</do_if> -->
							<wait min="30s" max="100s"/>
							<resume label="check shoppinglist"/>
						</do_else>
					</do_if>
				</do_else>
				<run_script name="'move.park.vanilla40'" result="$parkresult">
					<param name="destination" value="$targetobject"/>
					<param name="tradeoffer" value="$offer"/>
				</run_script>
				<do_if value="$parkresult">
					<debug_text text="player.age + ' now parked at ' + $targetobject.knownname" chance="$debugchance"/>
				</do_if>
				<do_elseif value="this.$reevaluate_parking?">
					<remove_value name="this.$reevaluate_parking"/>
					<debug_text text="player.age + ' need to re-evaluate our reason for parking at' + $targetobject.knownname" chance="$debugchance"/>
					<resume label="move to target object"/>
				</do_elseif>
				<do_else>
					<debug_text text="player.age + ' critical parking error!'" chance="$debugchance"/>
					<do_if value="$tradeorder.buyer.isoperational">
						<remove_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeorder.ware" virtual="$tradeorder.unbundle" mission="$tradeorder.ismission"/>
					</do_if>
					<do_elseif value="$tradeorder.seller.isoperational">
						<remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeorder.ware" virtual="$tradeorder.rebundle" mission="$tradeorder.ismission"/>
					</do_elseif>
					<wait min="10s" max="30s" sinceversion="7"/>
					<resume label="check shoppinglist"/>
				</do_else>
			</do_if>
			<do_else>
				<debug_text text="player.age + ' moving to dock at ' + $targetobject.knownname" chance="$debugchance"/>
				<run_script name="'move.dockat.vanilla40'" result="$dockresult">
					<param name="destination" value="$targetobject"/>
				</run_script>
				<do_if value="not $dockresult">
					<do_if value="$tradeorder.buyer.isoperational">
						<remove_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeorder.ware" virtual="$tradeorder.unbundle" mission="$tradeorder.ismission"/>
					</do_if>
					<do_elseif value="$tradeorder.seller.isoperational">
						<remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeorder.ware" virtual="$tradeorder.rebundle" mission="$tradeorder.ismission"/>
					</do_elseif>
					<wait min="10s" max="30s"/>
					<resume label="check shoppinglist"/>
				</do_if>
				<debug_text text="player.age + ' docked at ' + $targetobject.knownname" chance="$debugchance"/>
			</do_else>
			<!-- we have arrived, check if there is currently a tradeoffer matching the criteria defined by our shopping list -->
			<label name="check trade"/>
			<get_trade_from_shoppinglist object="this.ship" result="$tradeorder2"/>
			<do_if value="$tradeorder" exact="$tradeorder2" negate="true">
				<!-- the current trade is no longer at the top of the shopping list -->
				<debug_text text="player.age + ' current trade is no longer on top of shopping list, resume at \'check shoppinglist\''" chance="$debugchance"/>
				<resume label="check shoppinglist"/>
			</do_if>
			<do_if value="$tradeorder.seller.exists" comment="we want to buy something, look for sell offers">
				<debug_text text="'%1 wants to buy/transfer %2 %3 from %4 for %5Cr'.[this.ship.knownname, $tradeorder.amount, $tradeorder.ware, $tradeorder.seller.knownname, ($tradeorder.price / 1Cr)]" chance="$debugchance"/>
				<do_if value="$tradeorder.iswareexchange">
					<clamp_trade_amount trade="$tradeorder" amount="$tradeorder.amount" buyer="this.ship" seller="$tradeorder.seller" result="$transferamount"/>
					<do_if value="$transferamount != $tradeorder.amount">
						<update_trade trade="$tradeorder" amount="$transferamount" desiredamount="$transferamount"/>
					</do_if>
				</do_if>
				<do_elseif value="not $tradeorder.ismission">
					<set_value name="$tradeoffer" exact="null"/>
					<find_sell_offer result="$tradeoffers" seller="$tradeorder.seller" wares="$tradeorder.ware" tradepartner="this.ship" multiple="true">
						<offeramount min="1" entity="this"/>
					</find_sell_offer>
					<do_if value="$tradeoffers.count == 1">
						<set_value name="$tradeoffer" exact="$tradeoffers.{1}"/>
					</do_if>
					<do_elseif value="$tradeoffers.count gt 1">
						<set_value name="$tradeoffer" exact="$tradeoffers.{1}"/>
						<do_all exact="$tradeoffers.count" counter="$i">
							<do_if value="$tradeoffers.{$i}.offeramount.{this} ge $tradeorder.amount">
								<set_value name="$tradeoffer" exact="$tradeoffers.{$i}"/>
							</do_if>
						</do_all>
					</do_elseif>
					<do_if value="not $tradeoffer.available">
						<!-- seller no longer sells the ware we want -->
						<do_if value="this.sector">
							<substitute_text text="$logtext" source="{1016,60}">
								<replace string="'$ENTITYTYPE$'" with="this.typename"/>
								<replace string="'$ENTITYNAME$'" with="this.name"/>
								<replace string="'$OBJECTNAME$'" with="this.ship.name"/>
								<replace string="'$SECTOR$'" with="this.sector.name"/>
								<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
								<replace string="'$AMOUNT$'" with="$tradeorder.amount"/>
							</substitute_text>
							<write_to_logbook category="upkeep" text="$logtext"/>
							<remove_value name="$logtext"/>
						</do_if>
						<!-- TODO @Michael: Check -->
						<run_script name="'player.interaction.vanilla40'" result="$result">
							<param name="Line" value="1159" comment="(Fail Buy Ware)We have arrived at our destination but the specified good is not sold here. Moving on to the next order unless instructed otherwise."/>
							<param name="UIText" value="{1015,20}" comment="Failed buying ware"/>
							<param name="ConversationParam" value="'g_trade_fail_buyware'"/>
						</run_script>
						<do_if value="not $result">
							<remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.rebundle" mission="$tradeorder.ismission"/>
							<remove_trade_order object="this.ship" trade="$tradeorder"/>
							<resume label="check shoppinglist"/>
						</do_if>
						<do_else>
							<!-- TODO: wait for orders? -->
							<remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.rebundle" mission="$tradeorder.ismission"/>
							<remove_trade_order object="this.ship" trade="$tradeorder"/>
							<resume label="waitfororders"/>
						</do_else>
					</do_if>
					<do_elseif value="$tradeoffer.offeramount.{this} lt $tradeorder.amount">
						<assert value="true" text="'Trade Reservation failure for player trade! Amount mismatch when buying...'"/>
						<!-- seller no longer sells the amount we want -->
						<do_if value="this.sector">
							<substitute_text text="$logtext" source="{1016,61}">
								<replace string="'$ENTITYTYPE$'" with="this.typename"/>
								<replace string="'$ENTITYNAME$'" with="this.name"/>
								<replace string="'$OBJECTNAME$'" with="this.ship.name"/>
								<replace string="'$SECTOR$'" with="this.sector.name"/>
								<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
								<replace string="'$AMOUNT$'" with="$tradeorder.amount"/>
							</substitute_text>
							<write_to_logbook category="upkeep" text="$logtext"/>
							<remove_value name="$logtext"/>
						</do_if>
						<!-- TODO @Michael: Check -->
						<run_script name="'player.interaction.vanilla40'" result="$result">
							<param name="Line" value="1157" comment="(Fail Buy Amount)Unfortunately the requested amount is no longer available. We will buy as much as possible unless instructed otherwise."/>
							<param name="UIText" value="{1015,21}" comment="Failed buying amount"/>
							<param name="ConversationParam" value="'g_trade_fail_buyamount'"/>
						</run_script>
						<do_if value="not $result">
							<update_trade trade="$tradeorder" amount="$tradeoffer.offeramount.{this}"/>
						</do_if>
						<do_else>
							<!-- TODO: wait for orders? -->
							<remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.rebundle" mission="$tradeorder.ismission"/>
							<remove_trade_order object="this.ship" trade="$tradeorder"/>
							<resume label="waitfororders"/>
						</do_else>
					</do_elseif>
					<do_elseif value="not $tradeorder.buyfree.{this} and (this.money / 1Cr) lt ($tradeorder.price / 1Cr)">
						<debug_text text="'tradeorder price: %1ct(%3Cr), account money: %2ct(%4Cr)'.[$tradeorder.price, this.money, $tradeorder.price / 1Cr, this.money / 1Cr]" chance="$debugchance"/>
						<!-- we no longer have enough money in our account to make this purchase -->
						<do_if value="this.sector">
							<substitute_text text="$logtext" source="{1016,61}">
								<replace string="'$ENTITYTYPE$'" with="this.typename"/>
								<replace string="'$ENTITYNAME$'" with="this.name"/>
								<replace string="'$OBJECTNAME$'" with="this.ship.name"/>
								<replace string="'$SECTOR$'" with="this.sector.name"/>
								<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
								<replace string="'$AMOUNT$'" with="$tradeorder.amount"/>
							</substitute_text>
							<write_to_logbook category="upkeep" text="$logtext"/>
							<remove_value name="$logtext"/>
						</do_if>
						<!-- TODO @Michael: Check -->
						<run_script name="'player.interaction.vanilla40'" result="$result" sinceversion="4">
							<param name="Line" value="4800" comment="I don't have sufficient funds for this."/>
							<param name="UIText" value="{1015,21}" comment="Failed buying amount"/>
							<param name="ConversationParam" value="'g_trade_fail_buyamount'"/>
							<!-- <param name="ConversationParam" value="'g_trade_fail_buymoney'" /> -->
						</run_script>
						<do_if value="not $result">
							<set_value name="$newamount" exact="(this.money / $tradeorder.unitprice)i"/>
							<set_value name="$amountdiff" exact="$tradeorder.amount - $newamount"/>
							<update_trade trade="$tradeorder" amount="$newamount" desiredamount="$newamount"/>
							<remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeorder.ware" amount="$amountdiff" virtual="$tradeorder.rebundle" mission="$tradeorder.ismission"/>
							<debug_text text="'reducing amount by %1, new amount: %2'.[$amountdiff, $newamount]" chance="$debugchance"/>
						</do_if>
						<do_else>
							<!-- TODO: wait for orders? -->
							<remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.rebundle" mission="$tradeorder.ismission"/>
							<remove_trade_order object="this.ship" trade="$tradeorder"/>
							<resume label="waitfororders"/>
						</do_else>
					</do_elseif>
				</do_elseif>
			</do_if>
			<do_else comment="we want to sell something">
				<debug_text text="'%1 wants to sell/transfer %2 %3 to %4 for %5Cr'.[this.ship.knownname, $tradeorder.amount, $tradeorder.ware, $tradeorder.buyer.knownname, ($tradeorder.price / 1Cr)]" chance="$debugchance"/>
				<do_if value="$tradeorder.iswareexchange">
					<clamp_trade_amount trade="$tradeorder" amount="$tradeorder.amount" buyer="$tradeorder.buyer" seller="this.ship" result="$transferamount"/>
					<do_if value="$transferamount != $tradeorder.amount">
						<update_trade trade="$tradeorder" amount="$transferamount" desiredamount="$transferamount"/>
					</do_if>
				</do_if>
				<do_elseif value="not $tradeorder.ismission">
					<set_value name="$tradeoffer" exact="null"/>
					<find_buy_offer result="$tradeoffers" buyer="$tradeorder.buyer" wares="$tradeorder.ware" tradepartner="this.ship" multiple="true">
						<offeramount min="1" entity="this"/>
					</find_buy_offer>
					<do_if value="$tradeoffers.count == 1">
						<set_value name="$tradeoffer" exact="$tradeoffers.{1}"/>
					</do_if>
					<do_elseif value="$tradeoffers.count gt 1">
						<set_value name="$tradeoffer" exact="$tradeoffers.{1}"/>
						<do_all exact="$tradeoffers.count" counter="$i">
							<do_if value="$tradeoffers.{$i}.offeramount.{this} ge $tradeorder.amount">
								<set_value name="$tradeoffer" exact="$tradeoffers.{$i}"/>
							</do_if>
						</do_all>
					</do_elseif>
					<do_if value="not $tradeoffer.available">
						<!-- buyer no longer buys the ware we want to sell -->
						<do_if value="this.sector">
							<substitute_text text="$logtext" source="{1016,62}">
								<replace string="'$ENTITYTYPE$'" with="this.typename"/>
								<replace string="'$ENTITYNAME$'" with="this.name"/>
								<replace string="'$OBJECTNAME$'" with="this.ship.name"/>
								<replace string="'$SECTOR$'" with="this.sector.name"/>
								<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
								<replace string="'$AMOUNT$'" with="$tradeorder.amount"/>
							</substitute_text>
							<write_to_logbook category="upkeep" text="$logtext"/>
							<remove_value name="$logtext"/>
						</do_if>
						<!-- TODO @Michael: Check -->
						<run_script name="'player.interaction.vanilla40'" result="$result">
							<param name="Line" value="1160" comment="(Fail Sell Ware)We have arrived at our destination but the specified good is not bought here. Moving on to the next order unless instructed otherwise."/>
							<param name="UIText" value="{1015,22}" comment="Failed selling ware"/>
							<param name="ConversationParam" value="'g_trade_fail_sellware'"/>
						</run_script>
						<do_if value="not $result">
							<remove_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.unbundle" mission="$tradeorder.ismission"/>
							<remove_trade_order object="this.ship" trade="$tradeorder"/>
							<resume label="check shoppinglist"/>
						</do_if>
						<do_else>
							<!-- TODO: wait for orders? -->
							<remove_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.unbundle" mission="$tradeorder.ismission"/>
							<remove_trade_order object="this.ship" trade="$tradeorder"/>
							<resume label="waitfororders"/>
						</do_else>
					</do_if>
					<do_elseif value="$tradeoffer.offeramount.{this} lt $tradeorder.amount">
						<!-- buyer no longer buys the amount we want to sell -->
						<do_if value="this.sector">
							<substitute_text text="$logtext" source="{1016,63}">
								<replace string="'$ENTITYTYPE$'" with="this.typename"/>
								<replace string="'$ENTITYNAME$'" with="this.name"/>
								<replace string="'$OBJECTNAME$'" with="this.ship.name"/>
								<replace string="'$SECTOR$'" with="this.sector.name"/>
								<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
								<replace string="'$AMOUNT$'" with="$tradeorder.amount"/>
							</substitute_text>
							<write_to_logbook category="upkeep" text="$logtext"/>
							<remove_value name="$logtext"/>
						</do_if>
						<!-- TODO @Michael: Check -->
						<run_script name="'player.interaction.vanilla40'" result="$result">
							<param name="Line" value="1158" comment="(Fail Sell Amount)Our buyer no longer wants the full amount of goods. We will sell as many items as possible and move to the next order unless instructed otherwise."/>
							<param name="UIText" value="{1015,23}" comment="Failed selling amount"/>
							<param name="ConversationParam" value="'g_trade_fail_sellamount'"/>
						</run_script>
						<do_if value="not $result">
							<update_trade trade="$tradeorder" amount="$tradeoffer.offeramount.{this}"/>
						</do_if>
						<do_else>
							<!-- TODO: wait for orders? -->
							<remove_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.unbundle" mission="$tradeorder.ismission"/>
							<remove_trade_order object="this.ship" trade="$tradeorder"/>
							<resume label="waitfororders"/>
						</do_else>
					</do_elseif>
					<do_elseif value="this.ship.cargo.{$tradeorder.ware}.count lt $tradeorder.amount">
						<!-- can not sell as much as was planned for this trip -->
						<do_if value="this.sector">
							<substitute_text text="$logtext" source="{1016,63}">
								<replace string="'$ENTITYTYPE$'" with="this.typename"/>
								<replace string="'$ENTITYNAME$'" with="this.name"/>
								<replace string="'$OBJECTNAME$'" with="this.ship.name"/>
								<replace string="'$SECTOR$'" with="this.sector.name"/>
								<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
								<replace string="'$AMOUNT$'" with="$tradeorder.amount"/>
							</substitute_text>
							<write_to_logbook category="upkeep" text="$logtext"/>
							<remove_value name="$logtext"/>
						</do_if>
						<!-- Known issue: technically this is the wrong type of notification, but we don't have anything better for "we have less cargo than we have been ordered to sell, sell as much as possible" -->
						<run_script name="'player.interaction.vanilla40'" result="$result" sinceversion="8">
							<param name="Line" value="1158" comment="(Fail Sell Amount)Our buyer no longer wants the full amount of goods. We will sell as many items as possible and move to the next order unless instructed otherwise."/>
							<param name="UIText" value="{1015,23}" comment="Failed selling amount"/>
							<param name="ConversationParam" value="'g_trade_fail_sellamount'"/>
						</run_script>
						<do_if value="not $result">
							<update_trade trade="$tradeorder" amount="this.ship.cargo.{$tradeorder.ware}.count"/>
						</do_if>
						<do_else>
							<!-- TODO: wait for orders? -->
							<remove_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.unbundle" mission="$tradeorder.ismission"/>
							<remove_trade_order object="this.ship" trade="$tradeorder"/>
							<resume label="waitfororders"/>
						</do_else>
					</do_elseif>
				</do_elseif>
			</do_else>
			<!-- tradeoffer found, now transfer cargo -->
			<label name="perform trade"/>
			<set_value name="$timeout" exact="player.age + 2h"/>
			<debug_text text="'trade info: %1x %2 for %3Cr total'.[$tradeorder.amount, $tradeorder.ware.name, ($tradeorder.price / 1Cr)]" chance="$debugchance"/>
			<do_if value="$tradeorder.seller.isoperational">
				<!-- BUY -->
				<set_value name="$seller" exact="$tradeorder.seller"/>
				<do_if value="this.ship.commander == player.primaryship">
					<start_conversation actor="this" conversation="Speak" type="unqueued" convparam="1152" comment="Preparing to receive wares."/>
				</do_if>
				<execute_trade tradeoffer="$tradeorder" tradepartner="this.ship" amount="$tradeorder.amount" result="$traderesult" custom="true">
					<interrupt_after_time time="121min / (1 + 4 * $tradeorder.iswareexchange)"/>
				</execute_trade>
				<do_if value="$seller.isclass.station and @$tradeorder.rebundle">
					<!-- $tradeoffer.rebundle = true! in case we failed to buy ammo, trigger an update for seller ammo offers -->
					<debug_text text="'schedule immediate supply offer update for %1 (%2)'.[$seller.knownname, $seller]" chance="$debugchance"/>
					<schedule_supply_update object="$seller"/>
				</do_if>
			</do_if>
			<do_elseif value="$tradeorder.buyer.isoperational">
				<!-- SELL -->
				<!-- illegal ware check -->
				<set_value name="$policefaction" exact="this.zone.policefaction"/>
				<do_if value="$policefaction">
					<do_if value="this.ship.cargo.illegalto.{$policefaction}">
						<resume label="illegalcargo" chance="10"/>
					</do_if>
				</do_if>
				<set_value name="$buyer" exact="$tradeorder.buyer"/>
				<do_if value="this.ship.commander == player.primaryship">
					<start_conversation actor="this" conversation="Speak" type="unqueued" convparam="1153" comment="Preparing to deliver wares."/>
				</do_if>
				<execute_trade tradeoffer="$tradeorder" tradepartner="this.ship" amount="$tradeorder.amount" result="$traderesult" custom="true">
					<interrupt_after_time time="121min / (1 + 4 * $tradeorder.iswareexchange)"/>
				</execute_trade>
				<do_if value="$buyer.isclass.station and @$tradeorder.unbundle">
					<!-- $tradeoffer.unbundle = true! in case we failed to sell ammo, trigger an update for buyer ammo offers -->
					<debug_text text="'schedule immediate supply offer update for %1 (%2)'.[$buyer.knownname, $buyer]" chance="$debugchance"/>
					<schedule_supply_update object="$buyer"/>
				</do_if>
			</do_elseif>
			<do_else>
				<!-- remove shoppinglist item, and check list again -->
				<set_value name="$failreason" exact="'ERR_TRADEPARTNER_DESTROYED'"/>
				<debug_text text="player.age + ' \'%1\' QUEUED TRADE RUN FAILED! Error: %2'.[this.ship.knownname, $failreason]" filter="error"/>
				<remove_trade_order object="this.ship" trade="$tradeorder"/>
				<resume label="check shoppinglist"/>
			</do_else>
			<!-- If after execute there is no trade order(e.g. cleared by player) finish -->
			<do_if value="not $tradeorder.exists">
				<debug_text text="' trade offer not existing after execute trade (probably shopping list cleared)'" chance="$debugchance"/>
				<detach_from_masstraffic object="this.ship" wait="true" sinceversion="1"/>
				<resume label="check shoppinglist"/>
			</do_if>
			<do_if value="$traderesult">
				<set_value name="$price" exact="0Cr"/>
				<do_if value="not $tradeorder.iswareexchange">
					<set_value name="$price" exact="($tradeorder.transferredamount + $tradeorder.destroyedamount) * $tradeorder.unitprice"/>
				</do_if>
				<!-- Relation bonus for the player: Base bonus for the trade itself (max +1 UI value per 4 trades) and price-based bonus (max +1 UI value per 4M Credits) -->
				<add_faction_relation faction="$tradeorder.buyer.owner" otherfaction="$tradeorder.seller.owner" value="0.00016LF + (0.00064LF / (4000000Cr)LF * ($price)LF)"/>
				<!-- prepare texts for notifcation since the actual trade can be deleted by the time this is displayed! -->
				<do_if value="this.ship.commander == player.primaryship">
					<substitute_text text="$detail1" source="{1015, 1}">
						<replace string="'$ENTITYTYPE$'" with="this.typename"/>
						<replace string="'$ENTITYNAME$'" with="this.name"/>
						<replace string="'$OBJECTNAME$'" with="this.ship.name"/>
					</substitute_text>
					<do_if value="@$seller">
						<substitute_text text="$detail2" source="{1015, 2}">
							<replace string="'$AMOUNT$'" with="$tradeorder.transferredamount"/>
							<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
							<replace string="'$PRICE$'" with="$price.formatted.default"/>
						</substitute_text>
						<do_if value="$tradeorder.destroyedamount &gt; 0">
							<substitute_text text="$detail3" source="{1015, 3}">
								<replace string="'$AMOUNT$'" with="$tradeorder.destroyedamount"/>
								<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
							</substitute_text>
							<set_value name="$details" exact="[$detail1, $detail2, $detail3]"/>
						</do_if>
						<do_else>
							<set_value name="$details" exact="[$detail1, $detail2]"/>
						</do_else>
					</do_if>
					<do_elseif value="@$buyer">
						<substitute_text text="$detail2" source="{1015, 4}">
							<replace string="'$AMOUNT$'" with="$tradeorder.transferredamount + $tradeorder.destroyedamount"/>
							<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
							<replace string="'$PRICE$'" with="$price.formatted.default"/>
						</substitute_text>
					</do_elseif>
				</do_if>
			</do_if>
			<do_if value="not $targetobject.isplayerowned and not $targetobject.hastradesubscription">
				<!-- if a playership trades with an NPC station that doesn't have a trade subscription anyway, store one offer snapshot -->
				<store_trade_offer_snapshot object="$targetobject"/>
			</do_if>
			<do_if value="$targetobject == $tradeorder.buyer">
				<remove_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.unbundle" mission="$tradeorder.ismission"/>
			</do_if>
			<do_elseif value="$targetobject == $tradeorder.seller">
				<remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" virtual="$tradeorder.rebundle" mission="$tradeorder.ismission"/>
			</do_elseif>
			<do_else>
				<remove_ware_reservation object="$targetobject" entity="this" ware="$tradeorder.ware" amount="$tradeorder.amount" mission="$tradeorder.ismission"/>
			</do_else>
			<do_if value="player.age ge $timeout">
				<detach_from_masstraffic object="this.ship" wait="true"/>
				<!-- remove shoppinglist item, and check list again -->
				<set_value name="$failreason" exact="'ERR_EXECUTE_TRADE_TIMEOUT'"/>
				<debug_text text="player.age + ' \'%1\' QUEUED TRADE RUN FAILED! Error: %2'.[this.ship.knownname, $failreason]" filter="error"/>
				<remove_trade_order object="this.ship" trade="$tradeorder"/>
				<resume label="check shoppinglist"/>
			</do_if>
			<detach_from_masstraffic object="this.ship" wait="true"/>
			<do_if value="false">
				<debug_text text="' trade offer not existing after detach from mass traffic (probably shopping list cleared)'" chance="$debugchance"/>
				<detach_from_masstraffic object="this.ship" wait="true" sinceversion="1"/>
				<resume label="check shoppinglist"/>
			</do_if>
			<do_if value="$traderesult">
				<!-- keep this block for savegame compatibility for now -->
				<do_if value="not $detail1? and $tradeorder.exists">
					<!-- prepare texts for notifcation since the actual trade can be deleted by the time this is displayed! -->
					<set_value name="$price" exact="0Cr"/>
					<do_if value="not $tradeorder.iswareexchange">
						<set_value name="$price" exact="($tradeorder.transferredamount + $tradeorder.destroyedamount) * $tradeorder.unitprice"/>
					</do_if>
					<do_if value="this.ship.commander == player.primaryship">
						<substitute_text text="$detail1" source="{1015, 1}">
							<replace string="'$ENTITYTYPE$'" with="this.typename"/>
							<replace string="'$ENTITYNAME$'" with="this.name"/>
							<replace string="'$OBJECTNAME$'" with="this.ship.name"/>
						</substitute_text>
						<do_if value="@$tradeorder.seller">
							<substitute_text text="$detail2" source="{1015, 2}">
								<replace string="'$AMOUNT$'" with="$tradeorder.transferredamount"/>
								<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
								<replace string="'$PRICE$'" with="$price.formatted.default"/>
							</substitute_text>
							<do_if value="$tradeorder.destroyedamount &gt; 0">
								<substitute_text text="$detail3" source="{1015, 3}">
									<replace string="'$AMOUNT$'" with="$tradeorder.destroyedamount"/>
									<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
								</substitute_text>
								<set_value name="$details" exact="[$detail1, $detail2, $detail3]"/>
							</do_if>
							<do_else>
								<set_value name="$details" exact="[$detail1, $detail2]"/>
							</do_else>
						</do_if>
						<do_elseif value="@$tradeorder.buyer">
							<substitute_text text="$detail2" source="{1015, 4}">
								<replace string="'$AMOUNT$'" with="$tradeorder.transferredamount + $tradeorder.destroyedamount"/>
								<replace string="'$WARE$'" with="$tradeorder.ware.name"/>
								<replace string="'$PRICE$'" with="$price.formatted.default"/>
							</substitute_text>
						</do_elseif>
					</do_if>
				</do_if>
				<do_if value="this.ship.commander == player.primaryship">
					<start_conversation conversation="Speak" type="unqueued" actor="this" convparam="1165" comment="Deal closed, I'm sending you a report now."/>
					<do_if value="this.sector">
						<substitute_text text="$logtext1" source="{1016,3}">
							<replace string="'$ENTITYTYPE$'" with="this.typename"/>
							<replace string="'$ENTITYNAME$'" with="this.name"/>
							<replace string="'$OBJECTNAME$'" with="this.ship.name"/>
							<replace string="'$SECTOR$'" with="this.sector.name"/>
						</substitute_text>
					</do_if>
					<do_if value="@$seller">
						<show_notification caption="{1015,5}" details="$details" icon="achievement_money_down" queued="true" sound="ui_mon_eve_money_down"/>
						<do_if value="@$logtext1">
							<do_if value="@$detail3">
								<write_to_logbook category="squad" text="'%1 %2\n%3'.[$logtext1, $detail2, $detail3]"/>
							</do_if>
							<do_else>
								<write_to_logbook category="squad" text="'%1 %2'.[$logtext1, $detail2]"/>
							</do_else>
						</do_if>
					</do_if>
					<do_elseif value="@$buyer">
						<show_notification caption="{1015,30}" details="[$detail1, $detail2]" icon="achievement_money_up" queued="true" sound="ui_mon_eve_money_up" comment="Trade successful"/>
						<do_if value="@$logtext1">
							<write_to_logbook category="squad" text="'%1 %2'.[$logtext1, $detail2]"/>
						</do_if>
					</do_elseif>
				</do_if>
				<!-- we don't need to manually remove the trade order anymore, that is now done internally when the trade is deleted as long as <execute_trade /> is used to process the shoppinglist trade
        <remove_trade_order object="this.ship" trade="$tradeorder" /> -->
				<remove_value name="$buyer"/>
				<remove_value name="$seller"/>
				<remove_value name="$details"/>
				<remove_value name="$detail1"/>
				<remove_value name="$detail2"/>
				<remove_value name="$detail3"/>
				<remove_value name="$logtext1"/>
				<remove_value name="$price"/>
			</do_if>
			<do_else>
				<debug_text text="'something went wrong while attempting to perform trade operation!'" chance="$debugchance"/>
				<!-- TODO: ask player for help -->
				<do_if value="this.ship.commander == player.primaryship">
					<start_conversation actor="this" conversation="Speak" type="unqueued" convparam="1163" comment="We are unable to perform the requested trade operation, please advise."/>
				</do_if>
				<!-- remove shoppinglist item, and check list again -->
				<set_value name="$failreason" exact="'ERR_EXECUTE_TRADE'"/>
				<debug_text text="player.age + ' \'%1\' QUEUED TRADE RUN FAILED! Error: %2'.[this.ship.knownname, $failreason]" filter="error"/>
				<remove_trade_order object="this.ship" trade="$tradeorder"/>
				<resume label="check shoppinglist"/>
			</do_else>
			<!-- process the next item on the shopping list -->
			<do_if value="$tradeorder.exists">
				<wait max="15s" sinceversion="3">
					<interrupt>
						<conditions>
							<event_object_shoppinglist_trade_removed object="this.ship"/>
						</conditions>
					</interrupt>
				</wait>
			</do_if>
			<do_if value="$tradeorder.exists">
				<debug_text text="' manually remove trade from shoppinglist to ensure no-one tries to do it twice'" chance="$debugchance"/>
				<remove_trade_order object="this.ship" trade="$tradeorder"/>
			</do_if>
			<set_value name="$tradeorder" exact="null"/>
			<wait min="5s" max="15s"/>
			<resume label="check shoppinglist"/>
			<!-- if we have been caught with illegal cargo, drop it and notify the player -->
			<label name="illegalcargo"/>
			<debug_text text="'we have been caught transporting illegal cargo!'"/>
			<do_if value="$policefaction?">
				<do_if value="$tradeorder.exists">
					<drop_illegal_cargo object="this.ship" faction="$policefaction" groupname="$drops" wares="$droppedwares" amounts="$droppedamounts"/>
					<debug_text text="'dropped ' + $droppedwares"/>
					<get_trade_from_shoppinglist object="this.ship" multiple="true" result="$shoppingtrades"/>
					<do_all exact="$shoppingtrades.count" counter="$i" reverse="true">
						<do_if value="not $shoppingtrades.{$i}.ispassive.{this.ship}">
							<do_if value="$shoppingtrades.{$i}.buyer != this.ship">
								<do_all exact="$droppedwares.count" counter="$j">
									<do_if value="$shoppingtrades.{$i}.ware == $droppedwares.{$j}">
										<debug_text text="'removing order to sell %1 %2 to %3 [%4]'.[$shoppingtrades.{$i}.amount, $shoppingtrades.{$i}.ware, $shoppingtrades.{$i}.buyer.knownname, $shoppingtrades.{$i}.buyer]"/>
										<remove_trade_order object="this.ship" trade="$shoppingtrades.{$i}"/>
										<break/>
									</do_if>
								</do_all>
							</do_if>
						</do_if>
					</do_all>
					<do_if value="this.ship.commander">
						<signal_objects object="this.ship.commander" param="'IllegalCargoDropped'" param2="this.ship" param3="[this, $droppedwares, $droppedamounts, $drops, $policefaction]"/>
					</do_if>
				</do_if>
			</do_if>
			<do_if value="$droppedwares.indexof.{$tradeorder.ware} == 0">
				<!-- the current order wasn't for selling illegal stuff, so go back to performing the trade -->
				<wait min="5s" max="15s" sinceversion="4"/>
				<resume label="perform trade"/>
			</do_if>
			<set_value name="$tradeorder" exact="null"/>
			<wait min="5s" max="15s" sinceversion="4"/>
			<resume label="check shoppinglist"/>
			<!-- Ware Exchange Case: Passive Partner -->
			<label name="passivetrade"/>
			<!-- Fly to a safe position -->
			<get_safe_pos result="$pasivepos" object="this.ship" zone="this.zone" radius="this.size/2.0" ignored="this.ship"/>
			<move_to object="this.ship" destination="this.zone" sinceversion="6">
				<position value="$pasivepos"/>
				<rotation value="this.ship.rotation"/>
			</move_to>
			<remove_value name="$pasivepos"/>
			<debug_text text="'Me %1 (%2), target %3 (%4)'.[this, this.ship.knownname, $targetobject.pilot, $targetobject.knownname]" chance="$debugchance"/>
			<signal_objects object="$targetobject" param="'wareexchange ready'" param2="$tradeorder"/>
			<set_value name="this.$readypassivetrade" exact="true"/>
			<set_command_action commandaction="commandaction.waitingdrones"/>
			<wait max="1h" sinceversion="5">
				<interrupt>
					<conditions>
						<event_object_shoppinglist_trade_removed object="this.ship"/>
					</conditions>
				</interrupt>
			</wait>
			<remove_value name="this.$readypassivetrade"/>
			<detach_from_masstraffic object="this.ship" wait="true" sinceversion="5"/>
			<set_value name="$tradeorder" exact="null"/>
			<wait min="5s" max="15s" sinceversion="5"/>
			<resume label="check shoppinglist"/>
			<!-- complete, either there is nothing left on the shopping list or there was an error -->
			<label name="finish"/>
			<do_if value="$failreason != ''">
				<debug_text text="player.age + ' \'%1\' QUEUED TRADE RUN FAILED! Error: %2'.[this.ship.knownname, $failreason]" filter="error"/>
			</do_if>
			<do_else>
				<show_notification caption="{1015,31}" details="[{10002,23}, this.name, this.ship.name, '', {1015,32}]" icon="achievement_fight_1" queued="true" sound="notification_achievement" comment="All trade operations completed."/>
				<debug_text text="player.age + ' CONGRATULATIONS, QUEUED TRADE RUN COMPLETE!'" chance="$debugchance"/>
			</do_else>
			<!-- drop through for now -->
			<label name="waitfororders"/>
			<!-- make sure we're not blocking any parking spaces -->
			<do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
				<debug_text text="player.age + ' un-parking...'" chance="$debugchance"/>
				<run_script name="'move.undock.vanilla40'"/>
				<!-- in case a new trade was added to the shopping list while we were un-parking, start over -->
				<get_trade_from_shoppinglist object="this.ship" result="$shoppinglist" multiple="true"/>
				<do_if value="$shoppinglist.count gt 0">
					<resume label="process trade"/>
				</do_if>
			</do_if>
		</actions>
	</attention>
	<on_abort>
		<get_trade_from_shoppinglist object="this.ship" result="$shoppinglist" multiple="true"/>
		<do_all exact="$shoppinglist.count" counter="$c">
			<set_value name="$tradeorder" exact="$shoppinglist.{$c}"/>
			<do_if value="$tradeorder.buyer.isoperational">
				<remove_ware_reservation object="$tradeorder.buyer" type="sell" entity="this" mission="$tradeorder.ismission" virtual="$tradeorder.unbundle"/>
			</do_if>
		</do_all>
		<!-- TODO: can move.undock be called here? -->
		<do_if value="this.ship.parkedat.exists">
			<disconnect_from_trade_location ship="this.ship"/>
		</do_if>
		<!-- Remove blackboard -->
		<remove_value name="this.$readypassivetrade"/>
	</on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.performtraderun.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="4">
  <params>
    <param name="selloffer" />
    <param name="buyoffer" />
    <param name="simple" default="null" />
    <param name="debugchance" default="0" />
    <param name="debugchance2" default="0" />
  </params>
  <init>
    <set_command_action commandaction="commandaction.searchingtrades" />
  </init>
  <patch sinceversion="1">
    <set_value name="$simple" exact="null" />
  </patch>
  <patch sinceversion="2">
    <do_if value="$buyoffer.exists">
      <set_value name="$buyer" exact="$buyoffer.buyer" />
    </do_if>
  </patch>
  <patch sinceversion="3">
    <set_value name="$lasttrade" exact="[@$isbuyoffer, @$tradeware, @$targetobject]"/>
  </patch>
  <patch sinceversion="4">
    <!-- all reservations have been wiped as of 4.0, restore reservations we need, but only for L or XL ships, since smaller traders didn't do reservations before -->
    <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
      <debug_text text="'try to restore reservations for %1(%2)\n  $isbuyoffer? = %3\n  $tradeoffer.exists = %4\n  $amount = %5\n  $targetobject.isoperational = %6\n  $tradeware = %7\n  $reservation_removed? = %8'.[this.name, this, $isbuyoffer?, $tradeoffer.exists, $amount, $targetobject.isoperational, $tradeware, $reservation_removed?]" chance="$debugchance" />
      <do_if value="$isbuyoffer? and $amount gt 0 and $targetobject.isoperational and $tradeware">
        <do_if value="not $tradeoffer.exists">
          <do_if value="$isbuyoffer">
            <find_buy_offer result="$tradeoffer" buyer="$targetobject" wares="$tradeware" tradepartner="this.ship" />
          </do_if>
          <do_else>
            <find_sell_offer result="$tradeoffer" seller="$targetobject" wares="$tradeware" tradepartner="this.ship" />
          </do_else>
        </do_if>
        <do_if value="$tradeoffer.exists">
          <set_value name="$reserve_amount" exact="[$amount, $tradeoffer.amount].min"/>
          <do_if value="$reserve_amount gt 0">
            <do_if value="$isbuyoffer">
              <debug_text text="'restore sell reservation for %1 %2(virtual: %3) at %4(%5) by %6(%7)'.[$reserve_amount, $tradeware, $tradeoffer.unbundle, $targetobject.knownname, $targetobject, this.knownname, this]" chance="$debugchance" />
              <add_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeware" amount="$reserve_amount" virtual="@$tradeoffer.unbundle"/>
            </do_if>
            <do_elseif value="not $reservation_removed? and $reserve_amount gt 0">
              <debug_text text="'restore buy reservation for %1 %2(virtual: %3) at %4(%5) by %6(%7)'.[$reserve_amount, $tradeware, $tradeoffer.rebundle, $targetobject.knownname, $targetobject, this.knownname, this]" chance="$debugchance" />
              <add_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeware" amount="$reserve_amount" virtual="@$tradeoffer.rebundle"/>
            </do_elseif>
          </do_if>
          <remove_value name="$reserve_amount"/>
        </do_if>
      </do_if>
    </do_if>
    <do_else>
      <debug_text text="'skip restoring reservations for %1(%2) - not L or XL trader'.[this.name, this]" chance="$debugchance" />
    </do_else>
  </patch>
  <attention min="unknown">
    <actions>
      <!-- debugging -->
      <set_value name="$failreason" exact="''" />

      <!-- set up initial state for trade runs -->
      <label name="check trade offers" />
      <do_if value="$selloffer.available">
        <set_value name="$amount" exact="$selloffer.offeramount.{this}" />
        <do_if value="$simple">
          <!-- for simple trade runs we don't buy more than 75% -->
          <set_value name="$amount" exact="$amount * 3 / 4" />
        </do_if>
        <do_if value="$buyoffer.available">
          <do_if value="$buyoffer.offeramount.{this} lt $amount">
            <set_value name="$amount" exact="$buyoffer.offeramount.{this}" />
          </do_if>
        </do_if>
        <set_value name="$maxamount" exact="this.ship.cargo.{$selloffer.ware}.free" />
        <do_if value="$amount gt $maxamount">
          <set_value name="$amount" exact="$maxamount" />
        </do_if>
        <set_value name="$targetobject" exact="$selloffer.seller" />
        <set_value name="$tradeoffer" exact="$selloffer" />
        <!--<set_value name="$selloffer" exact="null" />-->
      </do_if>
      <do_elseif value="$buyoffer.available">
        <set_value name="$amount" exact="$buyoffer.offeramount.{this}" />
        <set_value name="$maxamount" exact="this.ship.cargo.{$buyoffer.ware}.count" />
        <do_if value="$amount gt $maxamount">
          <set_value name="$amount" exact="$maxamount" />
        </do_if>
        <set_value name="$targetobject" exact="$buyoffer.buyer" />
        <set_value name="$buyer" exact="$targetobject" />
        <set_value name="$tradeoffer" exact="$buyoffer" />
        <!--<set_value name="$buyoffer" exact="null" />-->
      </do_elseif>
      <do_elseif value="@$buyer.exists and $tradeware?">
        <!-- we are working on the buyoffer, but it is no longer available - use the stored information to find another appropriate offer -->
        <debug_text text="'original buyoffer is no longer available, try to find a new offer for %1 on %2(%3)'.[$tradeware, $buyer.knownname, $buyer]" chance="$debugchance" />
        <find_buy_offer result="$buyoffer" buyer="$buyer" wares="$tradeware" tradepartner="this.ship" />
        <debug_text text="'found %1'.[@$buyoffer]" chance="$debugchance" />
        <!-- remove the buyer variable so that if we haven't found an offer, the default handling is to return to the calling script -->
        <remove_value name="$buyer" />
        <!-- now continue as normal -->
        <resume label="check trade offers" />
      </do_elseif>
      <do_else>
        <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
          <debug_text text="player.age + ' un-parking...'" chance="$debugchance" />
          <run_script name="'move.undock.vanilla40'" />
        </do_if>
        <!-- force cleanup -->
        <do_if value="@$buyer_reserved.exists">
          <remove_ware_reservation object="$buyer_reserved" entity="this" />
          <remove_ware_reservation object="$buyer_reserved" entity="this" virtual="true" />
        </do_if>
        <do_if value="(@$buyer_reserved != $targetobject) and @$targetobject.exists">
          <remove_ware_reservation object="$targetobject" entity="this" />
          <remove_ware_reservation object="$targetobject" entity="this" virtual="true" />
        </do_if>
        <return>
          <retval name="success" value="true" />
          <retval name="lasttrade" value="@$lasttrade" />
        </return>
      </do_else>

      <do_if value="not $targetobject.isoperational">
        <set_value name="$failreason" exact="'ERR_TARGET_INVALID'" />
        <resume label="finish" />
      </do_if>

      <do_if value="$amount == 0">
        <set_value name="$failreason" exact="'ERR_NO_CARGO_SPACE'" />
        <resume label="finish" />
      </do_if>

      <set_value name="$tradeware" exact="$tradeoffer.ware" />
      <set_value name="$isbuyoffer" exact="$tradeoffer.buyer == $targetobject" />

      <!-- special handling for station-owned ships: make a reservation for the buyer if we are getting resources or selling products to better coordinate -->
      <do_if value="not $buyer_reserved? and $buyoffer.available and ($buyoffer.buyer == this.ship.commander or ($selloffer.available and $selloffer.seller == this.ship.commander))">
        <debug_text text="'adding sell reservation for %1 %2 at %3'.[$amount, $tradeware, $buyoffer.buyer]" chance="$debugchance" />
        <add_ware_reservation object="$buyoffer.buyer" type="sell" entity="this" ware="$tradeware" amount="$amount" duration="5h" virtual="$buyoffer.unbundle" />
        <set_value name="$buyer_reserved" exact="$buyoffer.buyer" />
      </do_if>

      <set_command command="command.trade" param="$targetobject" />

      <label name="move to target object" />
      <do_if value="this.zone != $targetobject.zone">
        <run_script name="'move.generic.vanilla40'">
          <param name="destination" value="$targetobject" />
          <param name="endintargetzone" value="true" />
        </run_script>
        <!-- time has passed for the movement step, make sure there is still an offer that matches what we want to buy -->
        <do_if value="not $isbuyoffer?">
          <do_if value="$tradeoffer.exists">
            <set_value name="$isbuyoffer" exact="$tradeoffer.buyer == $targetobject" />
            <set_value name="$tradeware" exact="$tradeoffer.ware" />
          </do_if>
          <do_else>
            <do_if value="$tradeware?">
              <find_buy_offer result="$tradeoffer" buyer="$targetobject" wares="$tradeware" tradepartner="this.ship" />
              <do_if value="not $tradeoffer.available">
                <find_sell_offer result="$tradeoffer" seller="$targetobject" wares="$tradeware" tradepartner="this.ship" />
              </do_if>
            </do_if>
            <do_if value="not $tradeoffer.available">
              <!-- we cannot determine what we were going to do anymore, just abort -->
              <set_value name="$failreason" exact="'ERR_STATE_LOST'" />
              <resume label="finish" />
            </do_if>
            <do_else>
              <set_value name="$skipfind" exact="true" />
            </do_else>
          </do_else>
        </do_if>
        <do_if value="not $skipfind?">
          <do_if value="$isbuyoffer">
            <find_buy_offer result="$tradeoffer" buyer="$targetobject" wares="$tradeware" tradepartner="this.ship" />
          </do_if>
          <do_else>
            <find_sell_offer result="$tradeoffer" seller="$targetobject" wares="$tradeware" tradepartner="this.ship" />
          </do_else>
        </do_if>
        <remove_value name="$skipfind" />
      </do_if>
      <do_if value="not $tradeoffer.available">
        <debug_text text="player.age + ' after movement the tradeoffer was gone'" chance="$debugchance" />
        <resume label="check trade offers" />
      </do_if>
      <set_value name="$reserved" exact="0" />
      <!-- reserve the ware amount so we can be reasonably sure that we can trade the entire amount -->
      <do_if value="$amount gt $tradeoffer.offeramount.{this}">
        <debug_text text="player.age + ' reducing amount from %1 to %2'.[$amount, $tradeoffer.offeramount.{this}]" chance="$debugchance" />
        <set_value name="$amount" exact="$tradeoffer.offeramount.{this}" />
      </do_if>
      <set_value name="$tradeware" exact="$tradeoffer.ware" />
      <do_if value="$isbuyoffer">
        <do_if value="not $buyer_reserved?">
          <!-- we don't reserve again if we already reserved an amount for the buyoffer before -->
          <debug_text text="'adding sell reservation for %1 %2 at %3'.[$amount, $tradeware, $targetobject]" chance="$debugchance" />
          <add_ware_reservation object="$targetobject" type="sell" entity="this" virtual="$tradeoffer.unbundle" ware="$tradeware" amount="$amount" result="$reserved" />
          <set_value name="$buyer_reserved" exact="$targetobject"/>
        </do_if>
        <do_else>
          <debug_text text="'checking sell reservation for %1 at %2'.[$tradeware, $targetobject]" chance="$debugchance" />
          <add_ware_reservation object="$targetobject" type="sell" entity="this" virtual="$tradeoffer.unbundle" ware="$tradeware" amount="0" result="$reserved" />
        </do_else>
      </do_if>
      <do_else>
        <debug_text text="'adding buy reservation for %1 %2 at %3'.[$amount, $tradeware, $targetobject]" chance="$debugchance" />
        <add_ware_reservation object="$targetobject" type="buy" entity="this" virtual="$tradeoffer.rebundle" ware="$tradeware" amount="$amount" result="$reserved" />
      </do_else>
      <do_if value="$reserved != $amount">
        <debug_text text="player.age + ' reserved %1 %2 at %3 (tried to reserve %4)'.[$reserved, $tradeware, $targetobject, $amount]" chance="$debugchance" />
      </do_if>
      <do_if value="$targetobject.isclass.ship">
        <debug_text text="player.age + ' reserved %1 %2 at %3'.[$reserved, $tradeware, $targetobject]" chance="$debugchance" />
      </do_if>
      <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
        <debug_text text="player.age + ' moving to park at ' + $targetobject.knownname" chance="$debugchance" />
        <run_script name="'move.park.vanilla40'" result="$parkresult">
          <param name="destination" value="$targetobject" />
          <param name="tradeoffer" value="$tradeoffer" />
          <param name="amount" value="$reserved" />
        </run_script>
        <do_if value="$parkresult">
          <debug_text text="player.age + ' now parked at ' + $targetobject.knownname" chance="$debugchance" />
        </do_if>
        <do_elseif value="this.$reevaluate_parking?">
          <remove_value name="this.$reevaluate_parking" />
          <debug_text text="player.age + ' need to re-evaluate our reason for parking at' + $targetobject.knownname" chance="$debugchance" />
          <resume label="move to target object" />
        </do_elseif>
        <do_else>
          <debug_text text="player.age + ' critical parking error!'" chance="$debugchance" />
          <resume label="check trade offers" />
        </do_else>
      </do_if>
      <do_else>
        <debug_text text="player.age + ' moving to dock at ' + $targetobject.knownname" chance="$debugchance" />
        <run_script name="'move.dockat.vanilla40'" result="$dockresult">
          <param name="destination" value="$targetobject" />
        </run_script>
        <do_if value="not $dockresult">
          <set_value name="$failreason" exact="'ERR_NO_DOCKING'" />
          <resume label="finish" />
        </do_if>
        <debug_text text="player.age + ' docked at ' + $targetobject.knownname" chance="$debugchance" />
      </do_else>
      <!-- in case the park/dock scripts returned instantly because we are already there, give the offers some time to update after adding reservations -->
      <wait exact="1s" sinceversion="4" />

      <label name="perform trade"/>
      <!-- time has passed, make sure we have a tradeoffer that fits -->
      <do_if value="not $isbuyoffer?">
        <do_if value="$tradeoffer.exists">
          <set_value name="$isbuyoffer" exact="$tradeoffer.buyer == $targetobject" />
          <set_value name="$tradeware" exact="$tradeoffer.ware" />
        </do_if>
        <do_else>
          <do_if value="$tradeware?">
            <find_buy_offer result="$tradeoffer" buyer="$targetobject" wares="$tradeware" tradepartner="this.ship" />
            <do_if value="not $tradeoffer.available">
              <find_sell_offer result="$tradeoffer" seller="$targetobject" wares="$tradeware" tradepartner="this.ship" />
            </do_if>
          </do_if>
          <do_if value="not $tradeoffer.available">
            <!-- we cannot determine what we were going to do anymore, just abort -->
            <set_value name="$failreason" exact="'ERR_STATE_LOST'" />
            <resume label="finish" />
          </do_if>
          <do_else>
            <set_value name="$isbuyoffer" exact="$tradeoffer.buyer == $targetobject" />
            <set_value name="$skipfind" exact="true" />
          </do_else>
        </do_else>
      </do_if>
      <do_if value="not $skipfind?">
        <do_if value="$isbuyoffer">
          <find_buy_offer result="$tradeoffer" buyer="$targetobject" wares="$tradeware" tradepartner="this.ship" />
        </do_if>
        <do_else>
          <find_sell_offer result="$tradeoffer" seller="$targetobject" wares="$tradeware" tradepartner="this.ship" />
        </do_else>
      </do_if>
      <remove_value name="$skipfind" />
      <do_if value="$tradeoffer.available">
        <do_if value="$tradeoffer.offeramount.{this} gt 0">
          <debug_text text="player.age + ' start trade operation!'" chance="$debugchance" />
          <do_if value="not @$isbuyoffer and not $reservation_removed?">
            <!-- for sell offers the reservation should be removed directly before the trade is started because wares are immediately put in escrow -->
            <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
              <remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeware" virtual="$tradeoffer.rebundle" />
            </do_if>
            <do_else>
              <remove_ware_reservation object="$targetobject" type="buy" entity="this" ware="$tradeware" virtual="$tradeoffer.rebundle" />
            </do_else>
            <set_value name="$reservation_removed" exact="1" />
            <!-- changing ware reservations triggers an offer update which could lead to the offer being removed -->
            <do_if value="not $tradeoffer.available">
              <!-- allow a little bit of time for the offer update to take place -->
              <wait exact="1s" sinceversion="4" />
              <resume label="perform trade" />
            </do_if>
          </do_if>
          <!-- last minute amount check -->
          <do_if value="@$isbuyoffer">
            <!-- we are selling -->
            <set_value name="$oldamount" exact="$amount" />
            <set_value name="$amount" exact="$tradeoffer.offeramount.{this}" />
            <set_value name="$maxamount" exact="this.ship.cargo.{$tradeware}.count" />
            <do_if value="$amount gt $maxamount">
              <set_value name="$amount" exact="$maxamount" />
            </do_if>
            <do_if value="$oldamount lt $amount">
              <debug_text text="'%1(%2) we can sell more %5 than we expected! Increase amount from %3 to %4 (directly before trade start)'.[this.ship.knownname, this.ship, $oldamount, $amount, $tradeware.name]" chance="$debugchance" />
            </do_if>
            <remove_value name="$oldamount" />
            <remove_value name="$maxamount" />
          </do_if>
          <do_elseif value="(not $tradeoffer.buyfree.{this}) and (($tradeoffer.unitprice * $amount) gt this.money)">
            <!-- we are buying and the transaction is not free -->
            <debug_text text="'%1(%2) reducing amount of %3 to buy from %4(%5) from %6 to %7 (directly before trade start; not enough money)'.[this.ship.knownname, this.ship, $tradeware.name, $targetobject.knownname, $targetobject, $amount, this.money / $tradeoffer.unitprice]" chance="$debugchance" />
            <set_value name="$amount" exact="this.money / $tradeoffer.unitprice"/>
          </do_elseif>
          <do_if value="$amount gt $tradeoffer.offeramount.{this}">
            <debug_text text="'%1(%2) reducing amount of %3 to trade with %4(%5) from %6 to %7 (directly before trade start; offeramount is lower)'.[this.ship.knownname, this.ship, $tradeware.name, $targetobject.knownname, $targetobject, $amount, $tradeoffer.offeramount.{this}]" chance="$debugchance" />
            <set_value name="$amount" exact="$tradeoffer.offeramount.{this}" />
          </do_if>
          <do_if value="$amount gt 0">
            <!-- now execute the trade -->
            <set_value name="$lasttrade" exact="[$isbuyoffer, $tradeware, $targetobject]"/>
            <execute_trade tradeoffer="$tradeoffer" tradepartner="this.ship" amount="$amount" result="$traderesult" />
          </do_if>
          <do_else>
            <set_value name="$traderesult" exact="false" />
          </do_else>
          <do_if value="@$isbuyoffer">
            <!-- buyoffers remove their reservation directly after the trade -->
            <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
              <remove_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeware" virtual="@$tradeoffer.unbundle" />
            </do_if>
            <do_else>
              <remove_ware_reservation object="$targetobject" type="sell" entity="this" ware="$tradeware" virtual="@$tradeoffer.unbundle" />
            </do_else>
          </do_if>
          <do_if value="$targetobject.isclass.station and ((@$isbuyoffer and @$tradeoffer.unbundle) or (not @$isbuyoffer and @$tradeoffer.rebundle))">
            <!-- in case we attempted to trade ammo, trigger an update for their ammo offers -->
            <debug_text text="'schedule immediate supply offer update for %1 (%2)'.[$targetobject.knownname, $targetobject]" chance="$debugchance" />
            <schedule_supply_update object="$targetobject" />
          </do_if>

          <do_if value="this.isplayerowned">
            <do_if value="not $targetobject.isplayerowned and not $targetobject.hastradesubscription">
              <!-- if a playership trades with an NPC station that doesn't have a trade subscription anyway, store one offer snapshot -->
              <store_trade_offer_snapshot object="$targetobject" />
            </do_if>
          </do_if>
          <remove_value name="$isbuyoffer" />
          <remove_value name="$reservation_removed" />
          <detach_from_masstraffic object="this.ship" wait="true">
            <interrupt_after_time time="5min" />
          </detach_from_masstraffic>
          <do_if value="not $traderesult">
            <do_if value="$amount le 0">
              <set_value name="$failreason" exact="'ERR_AMOUNT_0'" />
            </do_if>
            <do_else>
              <set_value name="$failreason" exact="'ERR_EXECUTE_FAIL'" />
            </do_else>
            <resume label="finish" />
          </do_if>
          <do_if value="@$buyer == $targetobject">
            <!-- we have (probably) sold the wares, make sure the script can return during the next run of check trade offers -->
            <remove_value name="$buyer" />
          </do_if>
          <debug_text text="player.age + ' successfully traded chosen goods!'" chance="$debugchance" />
        </do_if>
        <do_else>
          <set_value name="$failreason" exact="'ERR_TRADEOFFER_RESERVED'" />
          <resume label="finish" />
        </do_else>
      </do_if>
      <do_else>
        <set_value name="$failreason" exact="'ERR_TRADEOFFER_GONE'" />
        <resume label="finish" />
      </do_else>

      <remove_value name="$traderesult"/>
      <wait min="1s" max="3s" />
      <resume label="check trade offers" />

      <label name="finish" />
      <do_if value="@$targetobject.exists">
        <remove_ware_reservation object="$targetobject" entity="this" />
        <remove_ware_reservation object="$targetobject" entity="this" virtual="1" />
      </do_if>
      <do_if value="@$buyer_reserved.exists and (@$buyer_reserved != $targetobject)">
        <remove_ware_reservation object="$buyer_reserved" entity="this" />
        <remove_ware_reservation object="$buyer_reserved" entity="this" virtual="1" />
      </do_if>
      <do_if value="$failreason != ''">
        <debug_text text="player.age + ' \'%1\'(job: \'%2\') TRADE RUN FAILED! Error: %3'.[this.ship.knownname, this.ship.job, $failreason]" chance="$debugchance2" />
        <debug_text text="player.age + ' TRADE RUN FAILED! Error: ' + $failreason" chance="$debugchance" />
        <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
          <debug_text text="player.age + ' un-parking...'" chance="$debugchance" />
          <run_script name="'move.undock.vanilla40'" />
        </do_if>
        <return>
          <retval name="success" value="false" />
          <retval name="lasttrade" value="@$lasttrade" />
        </return>
      </do_if>
      <do_else>
        <do_if value="$tradeoffer.available">
          <debug_text text="player.age + ' \'%1\'(job: \'%5\') traded %2 units of %3 with %4'.[this.ship.knownname, $amount, $tradeoffer.ware, $targetobject.knownname, this.ship.job]" chance="$debugchance2" />
        </do_if>
        <do_else>
          <debug_text text="player.age + ' \'%1\'(job: \'%4\') traded %2 units of something with %3'.[this.ship.knownname, $amount, $targetobject.knownname, this.ship.job]" chance="$debugchance2" />
        </do_else>

        <debug_text text="player.age + ' CONGRATULATIONS, TRADE RUN COMPLETE!'" chance="$debugchance" />
        <do_if value="this.ship.isclass.ship_xl or this.ship.isclass.ship_l">
          <debug_text text="player.age + ' un-parking...'" chance="$debugchance" />
          <run_script name="'move.undock.vanilla40'" />
        </do_if>
        <return>
          <retval name="success" value="true" />
          <retval name="lasttrade" value="@$lasttrade" />
        </return>
      </do_else>

    </actions>
  </attention>
  <on_abort>
    <do_if value="@$buyer_reserved.exists">
      <remove_ware_reservation object="$buyer_reserved" entity="this" />
      <remove_ware_reservation object="$buyer_reserved" entity="this" virtual="1" />
    </do_if>
    <do_if value="(@$buyer_reserved != $targetobject) and @$targetobject.exists">
      <remove_ware_reservation object="$targetobject" entity="this" />
      <remove_ware_reservation object="$targetobject" entity="this" virtual="1" />
    </do_if>
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.ship.ranged.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <params>
    <param name="warelist" default="null" />
    <param name="minbuy" default="-1"/>
    <param name="maxbuy" default="-1"/>
    <param name="minsell" default="-1"/>
    <param name="maxsell" default="-1"/>
    <param name="debugchance" default="0"/>
  </params>
  <attention min="unknown">
    <actions>
      <!--TODO: Warning if there is cargo already in the ship. It may not be sellable (dangerous if set via job setup)-->
      <!-- set up initial state for trade runs -->
      <label name="start" />
      <run_script name="'trade.ship.vanilla40'">
        <param name="warelist" value="$warelist" />
        <param name="range" value="'ranged'" />
        <param name="additionalparams" value="[$minsell, $maxsell, $minbuy, $maxbuy]"/>
      </run_script>
    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.ship.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="6">
  <params>
    <param name="warelist" default="null" />
    <param name="range" default="null" />
    <param name="simple" default="null" />
    <!--if $range == 'ranged' then $additionalparams defines min and max jumps for the buy and sell ranges [$minbuy, $maxbuy, $minsell, $maxsell]-->
    <param name="additionalparams" default="null" />

    <param name="debugchance" default="0" />
    <param name="debugchance2" default="0" />
  </params>
  <interrupts>
    <handler ref="TargetInvalidHandler.vanilla40" />
    <handler ref="AttackHandler.vanilla40" />
    <handler ref="ScannedHandler.vanilla40" />
    <handler comment="handler kept local since it modifies a value local to this script">
      <conditions>
        <event_object_signalled object="this.ship" param="'range_setting_updated'" />
      </conditions>
      <actions>
        <do_if value="@event.param2">
          <set_value name="$range" exact="event.param2" />
        </do_if>
        <do_elseif value="@this.ship.commanderentity.$config_subordinate_range">
          <set_value name="$range" exact="this.ship.commanderentity.$config_subordinate_range" />
        </do_elseif>
        <do_if value="not @$range.isclass.space">
          <do_if value="$range" exact="'zone'">
            <set_value name="$range" exact="this.ship.zone" />
          </do_if>
          <do_elseif value="$range" exact="'sector'">
            <set_value name="$range" exact="this.ship.sector" />
          </do_elseif>
          <do_elseif value="$range" exact="'cluster'">
            <set_value name="$range" exact="this.ship.cluster" />
          </do_elseif>
          <do_else>
            <do_if value="(@this.ship.commander.maxradarrange gt 30km) and (this.ship.isclass.ship_l or this.ship.isclass.ship_xl)">
              <set_value name="$range" exact="this.ship.cluster" />
            </do_if>
            <do_else>
              <set_value name="$range" exact="this.ship.sector" />
            </do_else>
          </do_else>
        </do_if>
        <debug_text text="'updated operational range for %1(%2) to %3(%4)'.[this.ship.knownname, this.ship, $range.knownname, $range]" chance="$debugchance" />
      </actions>
    </handler>
  </interrupts>
  <init>
    <do_if value="this.ship.commander">
      <set_command command="command.trade" param="this.ship.commander" />
    </do_if>
    <do_else>
      <set_command command="command.freetrade" />
    </do_else>
    <!-- Main action for waiting times -->
    <set_command_action commandaction="commandaction.searchingtrades" />
  </init>
  <patch sinceversion="5">
    <set_value name="$simple" exact="null" />
  </patch>
  <patch sinceversion="6">
    <do_if value="@this.ship.commanderentity.$config_subordinate_range">
      <set_value name="$range" exact="this.ship.commanderentity.$config_subordinate_range" />
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>

      <!-- set up initial state for trade runs -->
      <label name="start" />
      <set_value name="$buyoffer" exact="null" />
      <set_value name="$selloffer" exact="null" />

      <set_value name="$idletime" min="10s" max="30s" />
      <wait chance="0" />
      <run_script name="'move.idle.vanilla40'" sinceversion="1">
        <param name="TimeOut" value="$idletime" />
      </run_script>

      <!-- TODO: we should check for things like broken jump drive, so we can go in for repairs instead of endlessly trying to jump to a trade -->

      <set_value name="$sellrange" exact="null"/>
      <set_value name="$buyrange" exact="null"/>
      <do_if value="not @$range.isclass.space">
        <do_if value="@this.ship.commanderentity.$config_subordinate_range">
          <set_value name="$range" exact="this.ship.commanderentity.$config_subordinate_range" />
        </do_if>
        <do_elseif value="$range" exact="'zone'">
          <set_value name="$range" exact="this.ship.zone" />
        </do_elseif>
        <do_elseif value="$range" exact="'sector'">
          <set_value name="$range" exact="this.ship.sector" />
        </do_elseif>
        <do_elseif value="$range" exact="'cluster'">
          <set_value name="$range" exact="this.ship.cluster" />
        </do_elseif>
        <do_elseif value="$range" exact="'ranged'">
          <set_value name="$range" exact="this.ship.cluster" />
          <set_value name="$sellrange" exact="[$additionalparams.{1}, $additionalparams.{2}]"/>
          <set_value name="$buyrange" exact="[$additionalparams.{3}, $additionalparams.{4}]"/>

          <do_if value="this.$traderange_sellclusters?">
            <remove_value name="this.$traderange_nexttime"/>
            <remove_value name="this.$traderange_sellclusters"/>
          </do_if>
        </do_elseif>
        <do_else>
          <do_if value="this.ship.isclass.ship_l or this.ship.isclass.ship_xl">
            <set_value name="$range" exact="this.ship.cluster" />
          </do_if>
          <do_else>
            <set_value name="$range" exact="this.ship.sector" />
          </do_else>
        </do_else>
      </do_if>

      <!-- use ware basket unless it has been overridden by parameter -->
      <do_if value="$warelist == null">
        <set_value name="$warelist" exact="this.ship.warebasket.list" />
      </do_if>

      <do_if value="$simple != null">
        <set_value name="$traderunscript" exact="'trade.findsimpletraderun.vanilla40'" />
      </do_if>
      <do_else>
        <do_if value="this.ship.commander">
          <set_value name="$traderunscript" exact="'trade.findtraderun.vanilla40'" />
          <!-- remove wares that might otherwise block cargo space forever because our homebase does not trade with them -->
          <do_if value="this.ship.owner" exact="faction.player" negate="true">
            <set_value name="$keepwares" exact="[ware.fuelcells]" />
            <append_to_list name="$keepwares" exact="this.ship.commander.products.list" />
            <append_to_list name="$keepwares" exact="this.ship.commander.resources.list" />
            <append_to_list name="$keepwares" exact="this.ship.commander.tradewares.list" />
            <set_value name="$cargowares" exact="this.ship.cargo.list" />
            <do_all exact="$cargowares.count" counter="$c">
              <set_value name="$currentware" exact="$cargowares.{$c}"/>
              <do_if value="$keepwares.indexof.{$currentware} == 0">
                <remove_cargo object="this.ship" ware="$currentware" exact="this.ship.cargo.{$currentware}.count"/>
              </do_if>
            </do_all>
            <remove_value name="$cargowares" />
            <remove_value name="$keepwares" />
          </do_if>
        </do_if>
        <do_else>
          <set_value name="$traderunscript" exact="'trade.findfreetraderun.vanilla40'" />
        </do_else>
      </do_else>

      <label name="find trade run"/>

      <do_if value="@this.ship.dockslot.component.external">
        <!-- make sure we clear the docking area asap -->
        <run_script name="'move.undock.vanilla40'" sinceversion="3" />
        <set_value name="$idletime" min="10s" max="30s" />
        <run_script name="'move.idle.vanilla40'" sinceversion="3">
          <param name="TimeOut" value="$idletime" />
        </run_script>
      </do_if>
      <do_else>
        <wait min="10s" max="30s" />
      </do_else>

      <!--Patch trade ships which should now run trade.ship.ranged-->
      <do_if value="this.$V1_25__Patch_Ranged_Trade_Ships?">
        <remove_value name="this.$V1_25__Patch_Ranged_Trade_Ships"/>
        <signal_objects object="player.galaxy" param="'V1_25__Patch_Ranged_Trade_Ships'" param2="this"/>
        <return/>
      </do_if>

      <!--Patch in $debugchance2, $sellrange and $buyrange-->
      <do_if value="not $sellrange?">
        <set_value name="$debugchance2" exact="0"/>
        <set_value name="$sellrange" exact="null"/>
        <set_value name="$buyrange" exact="null"/>
      </do_if>

      <run_script name="$traderunscript">
        <param name="warelist" value="$warelist" />
        <param name="range" value="$range" />
        <param name="sellrange" value="$sellrange"/>
        <param name="buyrange" value="$buyrange"/>
        <param name="lasttrade" value="@$lasttrade"/>
        <param name="debugchance" value="$debugchance"/>
        <param name="debugchance2" value="$debugchance2"/>
        <save_retval name="selloffer" variable="$selloffer" />
        <save_retval name="buyoffer" variable="$buyoffer" />
      </run_script>

      <!--If no trade was found then at least fly back to the buy area before checking again-->
      <do_if value="not $selloffer.available and not $buyoffer.available">
        <set_value name="this.$trade_failedfindruns" operation="add"/>
        <!--If the buyclusters are saved to the blackboard, fly to one of them-->
        <do_if value="this.$traderange_buyclusters?">
          <set_value name="$moveto" exact="true"/>
          <do_if value="this.$traderange_buyclusters.count">
            <!--Check if we are already in the buy area-->
            <do_all exact="this.$traderange_buyclusters.count" counter="$Counter">
              <do_if value="this.ship.hascontext.{this.$traderange_buyclusters.{$Counter}}">
                <set_value name="$moveto" exact="false"/>
                <break/>
              </do_if>
            </do_all>
            <do_if value="$moveto">
              <debug_text text="'No trade was found and we are outside of the buy range. Flying back to buy range.'" chance="$debugchance"/>
              <run_script name="'move.generic.vanilla40'" sinceversion="2">
                <param name="destination" value="this.$traderange_buyclusters.random" />
                <param name="endintargetzone" value="true" />
              </run_script>
            </do_if>
            <remove_value name="$moveto"/>
          </do_if>
        </do_if>
        <resume label="find trade run"/>
      </do_if>

      <label name="perform trade run"/>
      <set_value name="this.$trade_failedfindruns" exact="0"/>
      <do_while value="$selloffer.available or $buyoffer.available">
        <run_script name="'trade.performtraderun.vanilla40'">
          <param name="selloffer" value="$selloffer" />
          <param name="buyoffer" value="$buyoffer" />
          <param name="debugchance" value="$debugchance" />
          <save_retval name="success" variable="$success" />
          <save_retval name="lasttrade" variable="$lasttrade" />
        </run_script>
        <do_if value="not $success">
          <set_value name="$selloffer" exact="null" />
          <set_value name="$buyoffer" exact="null" />
        </do_if>
        <!--<wait min="1s" max="2s" />-->
      </do_while>

      <set_value name="$buyoffer" exact="null" />
      <set_value name="$selloffer" exact="null" />

      <!-- check if this is a jobship at the end of its lifetime -->
      <do_if value="this.ship.jobexpired">
        <debug_text text="'%1 doing job %2 has expired, die!'.[this.ship.knownname, this.ship.job]" chance="$debugchance" />
        <set_value name="$bigship" exact="this.ship.isclass.ship_l or this.ship.isclass.ship_xl" />
        <run_script name="'move.die.vanilla40'" sinceversion="4">
          <param name="byjump" value="$bigship" />
          <param name="byhighway" value="not $bigship" />
          <param name="bydock" value="not $bigship" />
          <param name="byidle" value="true" />
        </run_script>
      </do_if>

      <resume label="find trade run" />

      <debug_text text="player.age + ' END OF SCRIPT!'" chance="$debugchance" />

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.shipyard.small.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <!--
  This script allows shipyards to trade with other stations
  in the same zone using the masstraffic network.
  The shipyard tries to buy from other stations.
  Additionally the shipyard will occasionally build ships.
  by Michael
  -->
  <init>
    <set_command command="command.trade" />
    <set_command_action commandaction="commandaction.standingby" />
  </init>
  <attention min="unknown">
    <actions>
      <set_value name="$debugchance" exact="0"/>

      <do_if value="not this.station.canproduceships">
        <debug_text text="'attempting to run shipyard.small script on non-shipyard!'" />
        <return />
      </do_if>

      <label name="init"/>
      
      <!-- SET UP TRADE WARES AND ADD INITIAL AMOUNTS (first run only) -->
      <add_tradeware ware="ware.drp_scoopcollector_mk1" object="this.station" allowbuy="true" />
      <add_tradeware ware="ware.drp_scoopcollector_mk2" object="this.station" allowbuy="true" />
      <add_tradeware ware="ware.drp_surfaceminer_mk1" object="this.station" allowbuy="true" />
      <add_tradeware ware="ware.drp_surfaceminer_mk2" object="this.station" allowbuy="true" />
      <add_default_production_wares object="this.station" lowerlimit="20" upperlimit="80" />
      
      <wait min="5s" max="10min" />

      <label name="loop"/>
      <do_while value="true">
        <run_script name="'trade.station.vanilla40'">
          <param name="debugchance" value="$debugchance" />
        </run_script>
      </do_while>

    </actions>
  </attention>
  <on_abort>
    <remove_ware_reservation object="this.station" entity="this" />
  </on_abort>
</aiscript><?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.shipyard.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="4">
  <!--
  This script allows shipyards to trade with other stations
  in the same zone using the masstraffic network.
  The shipyard tries to buy from other stations.
  Additionally the shipyard will occasionally build ships.
  by Michael
  -->
  <interrupts>
    <handler>
      <conditions>
        <event_build_finished object="this.station"/>
      </conditions>
      <actions>
        <!-- <debug_text text="player.age + ': %1: object: %2[%3], param: %4[%5], param2: %6'.[event.name, event.object.knownname, event.object, event.param.knownname, event.param, event.param2]" /> -->

        <find_object_component object="this.station" name="$buildmodules" class="class.buildmodule" multiple="true" />
        <do_all exact="$buildmodules.count" counter="$i">
          <set_value name="$current_buildmodule" exact="$buildmodules.{$i}" />
          <set_value name="$ship" exact="$current_buildmodule.buildanchor" />
          <do_if value="$ship.isoperational">
            <!-- check if this ship was built by this entity -->
            <do_if value="this.$BuildShips.indexof.{$ship}">

              <debug_text text="player.age + ' finished building %1(%2) at %3(%4) in %5(%6)'.[$ship.knownname, $ship, this.station.knownname, this.station, this.zone.knownname, this.zone]" chance="$debugchance" />

              <!-- give the ship some fuel so it can jump -->
              <add_cargo ware="ware.fuelcells" object="$ship" exact="500" result="$fuel" />
              <do_if value="$fuel gt 0">
                <remove_cargo ware="ware.fuelcells" object="this.station" exact="$fuel" />
              </do_if>
              <remove_value name="$fuel"/>

              <!-- create pilot, assign to ship, set script to 'move and die' -->
              <create_ai_unit object="$ship" />
              <create_pilot name="$pilot" ship="$ship">
                <select faction="$ship.owner" tags="tag.pilot"/>
                <owner exact="$ship.owner"/>
              </create_pilot>
              <do_if value="$pilot.exists">
                <start_script object="$ship.pilot" name="'move.die'">
                  <param name="byjump" value="true" />
                </start_script>
              </do_if>
              <do_else>
                <debug_text text="'creating pilot for newly built ship %1(%2) at %3(%4) failed!'.[$ship.macro.id, $ship, this.station.knownname, this.zone.knownname]" />
              </do_else>
              <do_if value="$ship.isclass.ship_l or $ship.isclass.ship_xl">
                <create_engineer name="$engineer" ship="$ship">
                  <select faction="$ship.owner" tags="tag.engineer"/>
                  <owner exact="$ship.owner"/>
                </create_engineer>
                <do_if value="$engineer.exists">
                  <start_script object="$engineer" name="'engineer.ai'"/>
                </do_if>
                <create_defence_officer name="$defencenpc" ship="$ship">
                  <select faction="$ship.owner" tags="tag.defencecontrol"/>
                  <owner exact="$ship.owner"/>
                </create_defence_officer>
                <do_if value="$defencenpc.exists">
                  <start_script object="$defencenpc" name="'fight.defend.capital'"/>
                </do_if>
              </do_if>

              <!-- drain some drone units from shipyard -->
              <set_value name="$maxunits" exact="$ship.units.maxcount" />
              <do_if value="$maxunits gt 0">
                <set_value name="$stationcargo" exact="this.station.cargo.list" />
                <create_list name="$dronewares" />
                <do_all exact="$stationcargo.count" counter="$c">
                  <set_value name="$ware" exact="$stationcargo.{$c}" />
                  <set_value name="$waremacro" exact="$ware.objectmacro" />
                  <do_if value="$waremacro">
                    <do_if value="$waremacro.isclass.ship_xs">
                      <do_if value="this.station.cargo.{$ware}.target gt 0">
                        <do_if value="true" chance="(100 * this.station.cargo.{$ware}.count) / this.station.cargo.{$ware}.target">
                          <append_to_list name="$dronewares" exact="$ware" />
                        </do_if>
                      </do_if>
                    </do_if>
                  </do_if>
                </do_all>

                <do_if value="$dronewares.count gt 0">
                  <!-- we have decided which drone wares we want to drain, now go do it -->
                  <set_value name="$limit" exact="(($dronewares.count)f / 2.0f + 0.5f)i" />
                  <do_all exact="$limit">
                    <set_value name="$amount_limit" exact="$maxunits / $limit" />
                    <set_value name="$ware_index" min="1" max="$dronewares.count" />
                    <do_if value="$ware_index gt 0">
                      <set_value name="$ware" exact="$dronewares.{$ware_index}" />
                      <remove_value name="$dronewares.{$ware_index}"/>
                      <set_value name="$amount" min="this.station.cargo.{$ware}.count / 3"  max="this.station.cargo.{$ware}.count / 2" />
                      <do_if value="$amount gt $amount_limit">
                        <set_value name="$amount" exact="$amount_limit" />
                      </do_if>
                      <do_if value="$amount gt 0">
                        <debug_text text="'drain %1 %2 from %3 [%4] in %5 [%6]'.[$amount, $ware, this.station.knownname, this.station, this.zone.knownname, this.zone]" chance="$debugchance" />
                        <remove_cargo object="this.station" ware="$ware" exact="$amount" />
                        <add_units object="$ship" macro="$ware.objectmacro" exact="$amount" />
                      </do_if>
                    </do_if>
                  </do_all>
                </do_if>
              </do_if>

              <!-- drain some missiles from shipyard -->
              <set_value name="$maxammo" exact="$ship.ammostorage.missile.capacity" />
              <do_if value="$maxammo gt 0">
                <set_value name="$stationcargo" exact="this.station.cargo.list" />
                <create_list name="$missilewares" />
                <do_all exact="$stationcargo.count" counter="$c">
                  <set_value name="$ware" exact="$stationcargo.{$c}" />
                  <set_value name="$waremacro" exact="$ware.objectmacro" />
                  <do_if value="$waremacro">
                    <do_if value="$waremacro.isclass.missile">
                      <do_if value="this.station.cargo.{$ware}.target gt 0">
                        <do_if value="true" chance="(100 * this.station.cargo.{$ware}.count) / this.station.cargo.{$ware}.target">
                          <append_to_list name="$missilewares" exact="$ware" />
                        </do_if>
                      </do_if>
                    </do_if>
                  </do_if>
                </do_all>

                <do_if value="$missilewares.count gt 0">
                  <!-- we have decided which missile wares we want to drain, now go do it -->
                  <set_value name="$limit" exact="(($missilewares.count)f / 2.0f + 0.5f)i" />
                  <do_all exact="$limit">
                    <set_value name="$amount_limit" exact="$maxammo / $limit" />
                    <set_value name="$ware_index" min="1" max="$missilewares.count" />
                    <do_if value="$ware_index gt 0">
                      <set_value name="$ware" exact="$missilewares.{$ware_index}" />
                      <remove_value name="$missilewares.{$ware_index}"/>
                      <set_value name="$amount" min="this.station.cargo.{$ware}.count / 3"  max="this.station.cargo.{$ware}.count / 2" />
                      <do_if value="$amount gt $amount_limit">
                        <set_value name="$amount" exact="$amount_limit" />
                      </do_if>
                      <do_if value="$amount gt 0">
                        <debug_text text="'drain %1 %2 from %3 [%4] in %5 [%6]'.[$amount, $ware, this.station.knownname, this.station, this.zone.knownname, this.zone]" chance="$debugchance" />
                        <remove_cargo object="this.station" ware="$ware" exact="$amount" />
                        <add_ammo object="$ship" macro="$ware.objectmacro" amount="$amount" />
                      </do_if>
                    </do_if>
                  </do_all>
                </do_if>
              </do_if>

              <!-- Block all dockslots to prevent the player from docking at this ship -->
              <find_dock_location name="$ship_docks" container="$ship" size="tag.dock_p" multiple="true"/>
              <do_all exact="$ship_docks.count" counter="$Count">
                <set_room_locked room="$ship_docks.{$Count}.component" locked="true"/>
              </do_all>
              <remove_value name="$ship_docks" />

              <!-- And free the buildmodule for the next thing to be built-->
              <clear_buildmodule buildmodule="$current_buildmodule"/>
              <remove_from_group group="this.$BuildShips" object="$ship" />

              <!-- let trade.station know we may want to build another ship -->
              <set_value name="this.$stop_trading" exact="player.age" />
              <!-- ship building delay is cluster dependent for now -->
              <do_if value="this.station.cluster.macro.ismacro.cluster_b_macro">
                <set_value name="this.$stop_trading" min="25min" max="35min" operation="add" />
              </do_if>
              <do_elseif value="this.station.cluster.macro.ismacro.cluster_d_macro">
                <set_value name="this.$stop_trading" min="170min" max="190min" operation="add" />
              </do_elseif>
              <do_else>
                <set_value name="this.$stop_trading" min="10min" max="20min" operation="add" />
              </do_else>
              <debug_text text="player.age + ' request stop trading at ' + this.$stop_trading" chance="$debugchance" />

            </do_if>
          </do_if>

        </do_all>

      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.trade" />
    <set_command_action commandaction="commandaction.standingby" />
  </init>
  <patch sinceversion="4">
    <do_if value="not this.station.products.{ware.fuelcells}.exists">
      <add_tradeware ware="ware.fuelcells" object="this.station" allowbuy="true" />
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>
      <set_value name="$debugchance" exact="0"/>

      <label name="init"/>
      <do_if value="not this.station.canbuildships">
        <debug_text text="'attempting to run shipyard script on non-shipyard!'" chance="$debugchance" />
        <return />
      </do_if>

      <!-- station init -->
      <do_if value="not this.station.products.{ware.fuelcells}.exists">
        <add_cargo ware="ware.fuelcells" min="12000" max="18000" object="this.station"/>
      </do_if>

      <set_value name="$tradewares" exact="[
                  ware.drp_assault,
                  ware.drp_cargolifter,
                  ware.drp_construction,
                  ware.drp_interceptor_mk1,
                  ware.drp_interceptor_mk2,
                  ware.drp_intrepid_mk1,
                  ware.drp_intrepid_mk2,
                  ware.drp_overrun_mk1,
                  ware.drp_overrun_mk2,
                  ware.drp_scoopcollector_mk1,
                  ware.drp_scoopcollector_mk2,
                  ware.drp_surfaceminer_mk1,
                  ware.drp_surfaceminer_mk2,
                  ware.dumbfiremissile,
                  ware.swarmmissile,
                  ware.fuelcells
      ]" />

      <set_value name="$resources" exact="this.station.resources.list" />
      <set_value name="$products" exact="this.station.products.list" />
      <do_all exact="$tradewares.count" counter="$i">
        <set_value name="$tradeware" exact="$tradewares.{$i}" />
        <do_if value="$resources.indexof.{$tradeware} + $products.indexof.{$tradeware}" exact="0">
          <add_tradeware ware="$tradeware" object="this.station" allowbuy="true" />
        </do_if>
      </do_all>
      <remove_value name="$resources" />
      <remove_value name="$products" />
      <remove_value name="$tradeware" />
      <remove_value name="$tradewares" />

      <add_default_production_wares object="this.station" lowerlimit="20" upperlimit="80" />

      <wait min="5s" max="10min" />

      <create_group groupname="this.$BuildShips"/>

      <label name="loop"/>
      <do_while value="true">
        <do_if value="this.$BuildShips.count == 0">
          <remove_value name="this.$stop_trading" />

          <do_if value="player.platform">
            <find_object_component entitytype="entitytype.shiptrader" name="$shiptrader" object="player.platform" />
            <do_if value="$shiptrader">
              <set_value name="$blocked_buildmodule" exact="$shiptrader.buildmodule" />
            </do_if>
          </do_if>
          <do_else>
            <find_object_component entitytype="entitytype.shiptrader" name="$shiptraders" object="this.station" multiple="true" />
            <do_all counter="$s" exact="$shiptraders.count">
              <do_if value="@$shiptraders.{$s}.$block_buildmodule">
                <set_value name="$blocked_buildmodule" exact="$shiptraders.{$s}.buildmodule" />
              </do_if>
            </do_all>
          </do_else>

          <!-- tell a random buildmodule to build something (random) -->
          <set_value name="$buildmodule" exact="null" />
          <find_object_component entitytype="entitytype.shiptrader" name="$shiptrader" object="this.station" />
          <do_if value="$shiptrader">
            <do_if value="not $shiptrader.$shiptrader_isbusy?">
              <set_value name="$buildmodule" exact="$shiptrader.buildmodule" />
            </do_if>
          </do_if>

          <do_if value="$buildmodule.exists">
            <do_if value="$buildmodule == @$blocked_buildmodule">
              <debug_text text="'skipping buildmodule %1 because the player is docked at the corresponding platform'.[$blocked_buildmodule]" chance="$debugchance" />
              <wait min="1min" max="2min" sinceversion="1" />
              <continue />
            </do_if>
            <remove_value name="$blocked_buildmodule" />

            <do_if value="not $buildmodule.buildanchor.exists and $buildmodule.freedockslot" comment="If nothing is currently under construction...">
              <set_value name="$selected_macro" exact="$buildmodule.buildmacros.random"/>
              <debug_text text="player.age + ' build %1 in module %2'.[$selected_macro.id, $buildmodule]" chance="$debugchance" />

              <create_build_plan macro="$selected_macro" buildplan="$build_plan">
                <buildplan>
                  <buildsequence sequence="''" stage="0"/>
                </buildplan>
                <upgradeplan>
                  <!-- See defaults.xml for valid upgrades -->
                  <upgradeentry upgrade="'turret_small_sg'" level="1"/>
                  <upgradeentry upgrade="'turret_small_mg'" level="1"/>
                  <upgradeentry upgrade="'turret_medium_pe'" level="1"/>
                  <upgradeentry upgrade="'turret_medium_lb'" level="1"/>
                  <upgradeentry upgrade="'turret_missile_df'" level="1"/>
                  <upgradeentry upgrade="'turret_missile_sm'" level="1"/>
                  <upgradeentry upgrade="'shieldgenerator'" level="1"/>
                </upgradeplan>
              </create_build_plan>

              <construct_ship object="this.station" buildmodule="$buildmodule" macro="$selected_macro" faction="this.station.owner" buildplan="$build_plan" updatebuild="true"/>

              <!-- keep reference to what we are building -->
              <debug_text text="player.age + ' build anchor: ' + $buildmodule.buildanchor" chance="$debugchance" />
              <do_if value="$buildmodule.buildanchor.exists">
                <add_to_group groupname="this.$BuildShips" object="$buildmodule.buildanchor" />
              </do_if>
            </do_if>
          </do_if>
        </do_if>

        <wait min="5s" max="10s" />

        <do_if value="this.$BuildShips.count gt 0">
          <run_script name="'trade.station.vanilla40'">
            <param name="debugchance" value="$debugchance" />
          </run_script>
        </do_if>
        <!-- entire delay block disabled, this is now handled using the this.$stop_trading variable to prevent long pauses where trade.station does not run -->
        <!-- BEGIN DISABLED BLOCK -->
        <do_if value="0" comment="disable this entire block">
          <do_if value="this.station.cluster.macro.ismacro.cluster_b_macro">
            <wait min="25min" max="35min" sinceversion="3" />
          </do_if>
          <do_elseif value="this.station.cluster.macro.ismacro.cluster_d_macro">
            <wait min="170min" max="190min" sinceversion="2" />
          </do_elseif>
          <do_else>
            <wait min="10min" max="20min" />
          </do_else>
        </do_if>
        <!-- END DISABLED BLOCK -->
      </do_while>

    </actions>
  </attention>
  <on_abort>
    <remove_ware_reservation object="this.station" entity="this" />
    <!-- TEMP to clean up -->
    <find_object_component name="$buildmodules" object="this.station" class="class.buildmodule" multiple="true"/>
    <do_all exact="$buildmodules.count" counter="$Count">
      <do_if value="$buildmodules.{$Count}.buildanchor.exists">
        <do_if value="$buildmodules.{$Count}.buildanchor.owner != faction.player">
          <clear_buildmodule buildmodule="$buildmodules.{$Count}"/>
        </do_if>
      </do_if>
    </do_all>
  </on_abort>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.station.player.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd">
  <params>
    <param name="debugchance" default="0" />
  </params>
  <interrupts>
    <handler>
      <conditions>
        <event_object_money_updated object="this"/>
      </conditions>
      <actions>
        <do_if value="not @$belowbudget and (this.minbudget gt 0) and (event.param2 lt this.minbudget)">
          <debug_text text="'money below budget. Money: ' + event.param2 + ' Min budget: ' + this.minbudget" chance="$debugchance"/>
          <set_value name="$belowbudget" exact="true" />
          <do_if value="player.age" min="@$nextbudgetwarning">
            <set_value name="$nextbudgetwarning" exact="player.age + 10min" />
            <run_interrupt_script name="'player.interaction.budget.vanilla40'"/>
          </do_if>
        </do_if>
        <do_else>
          <remove_value name="$belowbudget" />
        </do_else>
      </actions>
    </handler>
  </interrupts>
  <attention min="unknown">
    <actions>

      <!-- first time init -->
      <label name="init" />

      <do_all exact="this.station.subordinates.{entitytype.manager}.count" counter="$s">
        <!-- when we get include actions in the future we could move this code there instead of duplicating it in the event handler -->
        <set_value name="$subordinate" exact="this.station.subordinates.{entitytype.manager}.{$s}" />
        <do_if value="$subordinate == @this.station.buildingmodule.container">
          <continue />
        </do_if>
        <set_value name="$resources" exact="this.station.resources.list" />
        <set_value name="$products" exact="this.station.products.list" />
        <!-- <set_value name="$tradewares" exact="this.station.tradewares.list" /> -->
        <evaluate_ammo_storage object="this.station" wares="$ammowares" type="missile" />
        <create_list name="$warelist" />
        <do_all exact="$resources.count" counter="$i">
          <set_value name="$ware" exact="$resources.{$i}" />
          <do_if value="$subordinate.cargo.{$ware}.free gt 0">
            <do_if value="$warelist.indexof.{$ware}" exact="0">
              <append_to_list name="$warelist" exact="$ware" />
            </do_if>
          </do_if>
        </do_all>
        <do_all exact="$products.count" counter="$i">
          <set_value name="$ware" exact="$products.{$i}" />
          <do_if value="$subordinate.cargo.{$ware}.free gt 0">
            <do_if value="$warelist.indexof.{$ware}" exact="0">
              <append_to_list name="$warelist" exact="$ware" />
            </do_if>
          </do_if>
        </do_all>
        <do_all exact="$ammowares.count" counter="$i">
          <set_value name="$ware" exact="$ammowares.{$i}" />
          <do_if value="$subordinate.cargo.{$ware}.free gt 0">
            <do_if value="$warelist.indexof.{$ware}" exact="0">
              <append_to_list name="$warelist" exact="$ware" />
            </do_if>
          </do_if>
        </do_all>
        <!-- <do_all exact="$tradewares.count" counter="$i">
          <set_value name="$ware" exact="$tradewares.{$i}" />
          <do_if value="$subordinate.cargo.{$ware}.free gt 0">
            <do_if value="$warelist.indexof.{$ware}" exact="0">
              <append_to_list name="$warelist" exact="$ware" />
            </do_if>
          </do_if>
        </do_all> -->

        <set_value name="$bigship" exact="$subordinate.isclass.ship_l or $subordinate.isclass.ship_xl" />
        <set_value name="$maxrange" exact="this.sector" />
        <!-- hack: if we are above 30km (50km) then the radar component has been built allowing cluster-wide operations -->
        <do_if value="$bigship and (this.station.maxradarrange gt 30km)">
          <set_value name="$maxrange" exact="this.cluster" />
        </do_if>
        <do_if value="this.$config_subordinate_range?">
          <do_if value="this.$config_subordinate_range.isclass.cluster and $maxrange.isclass.cluster">
            <set_value name="$maxrange" exact="this.$config_subordinate_range" />
          </do_if>
        </do_if>

        <create_list name="$collect_warelist" />
        <do_all exact="$warelist.count" counter="$i">
          <set_value name="$ware" exact="$warelist.{$i}" />
          <do_if value="$ware.tags.indexof.{tag.minable}">
            <do_if value="$subordinate.units.collect.{$ware}.count gt 0">
              <append_to_list name="$collect_warelist" exact="$warelist.{$i}" />
            </do_if>
          </do_if>
        </do_all>

        <do_if value="$collect_warelist.count gt 0">
          <debug_text text="'using %1(%2) to gather %3'.[$subordinate.knownname, $subordinate, $collect_warelist]" chance="$debugchance" />
          <start_script name="'mining.ship.station.vanilla40'" object="$subordinate.pilot">
            <param name="warebasket" value="$collect_warelist" />
          </start_script>
        </do_if>
        <do_elseif value="$warelist.count gt 0">
          <debug_text text="'using %1(%2) to transport %3'.[$subordinate.knownname, $subordinate, $warelist]" chance="$debugchance" />
          <start_script name="'trade.ship.vanilla40'" object="$subordinate.pilot">
            <param name="warelist" value="$warelist" />
            <param name="range" value="$maxrange" />
          </start_script>
        </do_elseif>
        <do_else>
          <debug_text text="'ship %1(%2) cannot transport anything useful for us.'.[$subordinate.knownname, $subordinate]" chance="$debugchance" />

          <do_if value="$subordinate.dps.all" min="50.0f">
            <debug_text text="'ship %1(%2) will patrol the station in range %3.'.[$subordinate.knownname, $subordinate, $Object.size/2 + $subordinate.maxradarrange/2]" chance="$debugchance" />
            <start_script name="'move.patrol.vanilla40'" object="$subordinate.pilot">
              <param name="range" value="'station'" comment="this Station" />
              <param name="range_max" value="this.station.size/2 + $subordinate.maxradarrange/2" />
            </start_script>
          </do_if>
          <do_else>
            <debug_text text="'ship %1(%2) is not useful for combat purposes.'.[$subordinate.knownname, $subordinate]" chance="$debugchance" />
            <start_script name="'move.generic.vanilla40'" object="$subordinate.pilot" >
              <param name="destination" value="this.station" />
            </start_script>
          </do_else>
          
          
        </do_else>

      </do_all>

      <remove_value name="$ware"/>
      <remove_value name="$collect_warelist"/>
      <remove_value name="$warelist"/>
      <remove_value name="$maxrange"/>
      <remove_value name="$bigship"/>
      <remove_value name="$resources"/>
      <remove_value name="$ammooffers"/>
      <!--<remove_value name="$tradewares"/>-->
      <remove_value name="$products"/>
      <remove_value name="$subordinate"/>

      <label name="loop" />

      <!-- run the standard trading script, while waiting to assign ships when needed -->
      <do_while value="true">
        <run_script name="'trade.station.vanilla40'" />
        <wait min="1s" max="10s" />
      </do_while>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.station.tradingstation.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="1">
  <params>
    <param name="warelist" default="null"/>
  </params>
  <init>
    <set_command command="command.trade" />
  </init>
  <patch sinceversion="1">
    <do_if value="this.station.owner == faction.player">
      <!-- this script was not meant to be run on player stations, return to caller which is trade.station -->
      <debug_text text="'returning from player owned trading station script'"/>
      <signal_objects object="this.station" delay="1s" param="'V4_00__Abort_Player_Tradestation_Script'"/>
    </do_if>
  </patch>
  <attention min="unknown">
    <actions>
      <set_value name="$debugchance" exact="0"/>

      <label name="init"/>
      <do_if value="this.station.macro.ismacro.struct_econ_ref_ar_pmc_north_macro">
        <add_cargo ware="ware.ore" min="4400" max="4800" object="this.station"/>
        <add_cargo ware="ware.silicon" min="3900" max="4300" object="this.station"/>
        <add_cargo ware="ware.crystals" min="3300" max="3600" object="this.station"/>
        <add_cargo ware="ware.nividium" min="2200" max="2600" object="this.station"/>
        <add_tradeware ware="ware.ore" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.silicon" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.crystals" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.nividium" object="this.station" allowbuy="true" allowsell="true"/>
      </do_if>
      <do_elseif value="this.station.macro.ismacro.struct_econ_ref_ar_pmc_orbital_l_macro">
        <add_cargo ware="ware.dumbfiremissile" min="700" max="800" object="this.station"/>
        <add_cargo ware="ware.guidedmissile" min="470" max="530" object="this.station"/>
        <add_cargo ware="ware.swarmmissile" min="130" max="170" object="this.station"/>
        <add_cargo ware="ware.torpedo" min="125" max="155" object="this.station"/>
        <add_tradeware ware="ware.dumbfiremissile" object="this.station" allowbuy="true"/>
        <add_tradeware ware="ware.guidedmissile" object="this.station" allowbuy="true"/>
        <add_tradeware ware="ware.swarmmissile" object="this.station" allowbuy="true"/>
        <add_tradeware ware="ware.torpedo" object="this.station" allowbuy="true"/>
      </do_elseif>
      <do_elseif value="this.station.macro.ismacro.struct_bt_alb_warehouse_macro">
        <add_tradeware ware="ware.crystals" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.cutcrystals" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.energycells" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.foodrations" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.ice" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.meat" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.medicalsupplies" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.narcotics" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.nividium" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.ore" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.refinedmetals" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.silicon" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.siliconwafers" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.spacefuel" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.water" object="this.station" allowbuy="true" allowsell="true"/>
        <add_tradeware ware="ware.wheat" object="this.station" allowbuy="true" allowsell="true"/>
        <add_default_production_wares object="this.station" lowerlimit="40" upperlimit="60"/>
      </do_elseif>

      <label name="loop"/>
      <do_while value="true">
        <wait min="2min" max="4min"/>
      </do_while>

    </actions>
  </attention>
</aiscript>
<?xml version="1.0" encoding="iso-8859-1" ?>
<aiscript name="trade.station.vanilla40" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="aiscripts.xsd" version="3">
  <!--
  This script allows stations to trade with other stations
  in the same zone using the masstraffic network.
  The current station tries to buy from other stations.
  by Benedikt
  -->
  <params>
    <param name="warelist" default="null"/>
    <param name="debugchance" default="0"/>
  </params>
  <interrupts>
    <handler>
      <conditions>
        <event_object_update_supply object="this.station" />
      </conditions>
      <actions>
        <debug_text text="'%1: %2, %3'.[event.name, event.object, @event.param]" chance="$debugchance" />
        <run_interrupt_script name="'lib.ammo.station.vanilla40'" />
      </actions>
    </handler>
    <handler>
      <conditions>
        <event_object_signalled object="this.station" param="'V4_00__Abort_Player_Tradestation_Script'"/>
      </conditions>
      <actions>
        <abort_called_scripts />
      </actions>
    </handler>
  </interrupts>
  <init>
    <set_command command="command.freetrade" />
  </init>
  <patch sinceversion="1">
    <do_if value="@$finalamount gt 0 and @$tradeware and $finalselloffer.exists">
      <set_value name="$d_startamount" exact="[$finalselloffer.amount, @$finalamount].min"/>
      <do_if value="$d_startamount gt 0">
        <add_ware_reservation object="this.station" type="sell" entity="this" ware="$tradeware" amount="$d_startamount" virtual="@$unbundle" duration="3h" />
      </do_if>
    </do_if>
    <!-- remove deprecated values -->
    <remove_value name="$reserved"/>
    <remove_value name="$d_startamount"/>
    <remove_value name="$d_reserved"/>
  </patch>
  <patch sinceversion="2">
    <set_value name="$nextsupplycheck" min="2s" max="4min"/>
    <schedule_supply_update object="this.station" delay="$nextsupplycheck"/>
    <remove_value name="$nextsupplycheck"/>
  </patch>
  <attention min="unknown">
    <actions>

      <label name="init"/>
      <!-- get the ball rolling for supply updates -->
      <set_value name="$nextsupplycheck" min="1min" max="5min"/>
      <schedule_supply_update object="this.station" delay="$nextsupplycheck"/>
      <remove_value name="$nextsupplycheck"/>

      <!-- run specialised script for stations that focus on trading rather than production -->
      <do_if value="this.station.owner != faction.player">
        <set_value name="$tradingstations" exact="[macro.struct_econ_ref_ar_pmc_north_macro, macro.struct_econ_ref_ar_pmc_orbital_l_macro, macro.struct_bt_alb_warehouse_macro]"/>
        <do_all exact="$tradingstations.count" counter="$i">
          <do_if value="this.station.macro.ismacro.{$tradingstations.{$i}}">
            <run_script name="'trade.station.tradingstation.vanilla40'"/>
          </do_if>
        </do_all>
        <remove_value name="$tradingstations" />
      </do_if>

      <label name="loop"/>
      <do_if value="this.$stop_trading?">
        <do_if value="this.$stop_trading lt player.age">
          <return />
        </do_if>
      </do_if>

      <!-- finding offers is expensive, we don't need to check this frequently -->
      <set_command_action commandaction="commandaction.searchingtrades" />

      <wait min="2min" max="4min" />

      <set_value name="$buyoffer" exact="null"/>

      <!-- find the best trade opportunity -->
      <find_buy_offer buyer="this.station" result="$buyoffers" multiple="true">
        <stocklevel min="0.2" />
      </find_buy_offer>

      <do_if value="$buyoffers.count gt 0">
        <create_list name="$buywares" />
        <!-- build list of wares that we are interested in -->
        <do_all exact="$buyoffers.count" counter="$i">
          <append_to_list name="$buywares" exact="$buyoffers.{$i}.ware" />
          <debug_text text="player.age + ' %1 in %2 wants %3 units of %4'.[this.station.knownname, this.station.zone.knownname, $buyoffers.{$i}.amount, $buyoffers.{$i}.ware.name]" chance="$debugchance" />
        </do_all>

        <find_sell_offer tradepartner="this.station" wares="$buywares" space="this.station.zone" result="$selloffers" multiple="true">
          <stocklevel min="0.2" />
        </find_sell_offer>
        <remove_value name="$buywares" />

        <do_all exact="$selloffers.count" counter="$j" reverse="true">
          <set_value name="$currentselloffer" exact="$selloffers.{$j}" />
          <set_value name="$currentware" exact="$currentselloffer.ware"/>
          <!-- we don't want two stations shipping the same tradeware back and forth, so check if ware is a tradeware on both stations and negate -->
          <do_if value="this.station.tradewares.{$currentware}.exists and $currentselloffer.seller.tradewares.{$currentware}.exists">
            <remove_value name="$selloffers.{$j}" />
          </do_if>
        </do_all>

        <sort_trades name="$selloffers" tradelist="$selloffers" sorter="relativeprice" />

        <do_all exact="$buyoffers.count">
          <!-- find the selloffer with the highest amount -->
          <set_value name="$currentbuyoffer" exact="$buyoffers.random"/>
          <set_value name="$offerindex" exact="$buyoffers.indexof.{$currentbuyoffer}"/>
          <remove_value name="$buyoffers.{$offerindex}" />
          <remove_value name="$offerindex" />

          <set_value name="$currentware" exact="$currentbuyoffer.ware"/>

          <set_value name="$maxsellamount" exact="0"/>
          <set_value name="$selloffer" exact="null"/>
          <do_all exact="$selloffers.count" counter="$j">
            <set_value name="$currentselloffer" exact="$selloffers.{$j}" />
            <do_if value="$currentselloffer.ware == $currentware">
              <!-- we don't want two stations shipping the same tradeware back and forth, so check if ware is a tradeware on both stations and negate -->
              <do_if value="this.station.tradewares.{$currentware}.exists and $currentselloffer.seller.tradewares.{$currentware}.exists" negate="true">

                <set_value name="$finalamount" exact="$currentselloffer.offeramount.{this}"/>
                <do_if value="$currentbuyoffer.amount lt $currentselloffer.offeramount.{this}">
                  <set_value name="$finalamount" exact="$currentbuyoffer.amount"/>
                </do_if>

                <do_if value="$finalamount * $currentware.volume gt 100000">
                  <!-- cap the max trade volume at 100000 to avoid super-long huge trades -->
                  <debug_text text="'reducing station trade volume for ware %4 from %1 (%2 units) to 100000 (%3 units)'.[$finalamount * $currentware.volume, $finalamount, 100000 / $currentware.volume, $currentware]" chance="$debugchance" />
                  <set_value name="$finalamount" exact="100000 / $currentware.volume"/>
                </do_if>

                <set_value name="$finalselloffer" exact="$currentselloffer"/>
                <set_value name="$buyoffer" exact="$currentbuyoffer"/>

                <break />
              </do_if>
            </do_if>
          </do_all>
          <do_if value="$selloffer">
            <break />
          </do_if>
        </do_all>
      </do_if>

      <remove_value name="$buyoffers"/>
      <remove_value name="$selloffers" />

      <!-- execute the trade -->
      <remove_value name="$traderesult"/>
      <label name="executetrade" />
      <do_if value="$buyoffer.exists">
        <do_if value="$traderesult?">
          <wait exact="$tradestart + 5h - player.age" sinceversion="3">
            <interrupt>
              <conditions>
                <check_any>
                  <event_trade_order_completed buyer="this.station" tradeoffer="$finalselloffer" />
                  <event_trade_order_cancelled buyer="this.station" tradeoffer="$finalselloffer" />
                </check_any>
              </conditions>
            </interrupt>
          </wait>
        </do_if>
        <do_else>
          <set_value name="$tradestart" exact="player.age"/>
          <set_value name="$tradeware" exact="$finalselloffer.ware"/>
          <do_if value="$buyoffer.unbundle">
            <set_value name="$unbundle" exact="true" />
          </do_if>
          <debug_text text="player.age + ' %1 in %2 wants %3 units of %4 from %5...'.[this.station.knownname, this.station.zone.knownname, $finalamount, $tradeware.name, $finalselloffer.seller.knownname]" chance="$debugchance"/>
          <!-- use a 3hour duration for station trades, as these can be inherently slower -->
          <add_ware_reservation object="this.station" type="sell" entity="this" ware="$tradeware" amount="$finalamount" virtual="@$unbundle" duration="3h" />
          <set_command command="command.trade" param="$finalselloffer.seller" />
          <execute_trade tradeoffer="$finalselloffer" amount="$finalamount" tradepartner="this.station" result="$traderesult" unbundle="@$unbundle">
            <interrupt_after_time time="5h" />
          </execute_trade>
        </do_else>
        <!-- no need to call detach_from_masstraffic since stations in the same zone are linked with a static network that persists anyway -->
        <do_if value="@$unbundle">
          <!-- in case we attempted to buy ammo, trigger an update for our ammo offers -->
          <schedule_supply_update object="this.station" />
        </do_if>
        <remove_ware_reservation object="this.station" type="sell" entity="this" ware="$tradeware" virtual="@$unbundle" />
        <remove_value name="$unbundle" />
        <debug_text text="player.age + ' trade executed in %1 seconds'.[player.age - $tradestart]" chance="$debugchance"/>

      </do_if>

      <!-- hacked version to bypass trading ships; set space to this.station.cluster in find_sell_offer -->
      <!-- <do_if value="$buyoffer">
          <debug_text text="player.age + ' %1 in %2 wants %3 units of %4 from %5...'.[this.station.knownname, this.station.zone.knownname, $finalamount, $buyoffer.ware.name, $finalselloffer.seller.knownname]" chance="$debugchance"/>
          <add_cargo object="this.station" ware="$buyoffer.ware" exact="$finalamount"/>
          <remove_cargo object="$finalselloffer.seller" ware="$buyoffer.ware" exact="$finalamount"/>
        </do_if> -->
      <resume label="loop" />

    </actions>
  </attention>
  <on_abort>
    <remove_ware_reservation object="this.station" type="sell" entity="this" />
    <remove_ware_reservation object="this.station" type="sell" entity="this" virtual="true" />
  </on_abort>
</aiscript>
﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>
﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>﻿<?xml version="1.0" encoding="UTF-8"?>
<diff>
<!-- deactivate unneeded MD File -->
<replace sel="/mdscript/cues">
  <cues/>
</replace>
</diff>